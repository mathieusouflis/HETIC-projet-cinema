{"version":3,"file":"config-CfalXEai.mjs","names":["GENERATOR_CLIENT: GeneratorClients","generateClientImports: GeneratorClientImports","generateClientHeader: GeneratorClientHeader","generateClientFooter: GeneratorClientFooter","implementation: string","generateClientTitle: GeneratorClientTitle","generateExtraFiles","acc","context: ContextSpec","validateSpec","out: Record<string, unknown>","refObj: unknown","result: Record<string, unknown>","result","name","version","mock: GlobalMockOptions | ClientMockBuilder | undefined","globalQueryOptions: NormalizedQueryOptions","normalizedOptions: NormalizedOptions","path","query","zod","hono","pkg.name","pkg.version","description","version","name","context: ContextSpec","implementationPaths: string[]","path","config: Partial<TypeDocOptions>","configPath: string | null","fs"],"sources":["../package.json","../src/client.ts","../src/api.ts","../src/import-open-api.ts","../src/import-specs.ts","../src/utils/execute-hook.ts","../src/utils/package-json.ts","../src/utils/tsconfig.ts","../src/utils/options.ts","../src/utils/watcher.ts","../src/write-zod-specs.ts","../src/write-specs.ts","../src/generate-spec.ts","../src/utils/config.ts"],"sourcesContent":["","import angular from '@orval/angular';\nimport axios from '@orval/axios';\nimport {\n  asyncReduce,\n  type ClientFileBuilder,\n  type ClientMockGeneratorBuilder,\n  type ContextSpec,\n  generateDependencyImports,\n  type GeneratorClientFooter,\n  type GeneratorClientHeader,\n  type GeneratorClientImports,\n  type GeneratorClients,\n  type GeneratorClientTitle,\n  type GeneratorOperations,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  type GeneratorVerbsOptions,\n  isFunction,\n  type NormalizedOutputOptions,\n  OutputClient,\n  type OutputClientFunc,\n  pascal,\n} from '@orval/core';\nimport fetchClient from '@orval/fetch';\nimport hono from '@orval/hono';\nimport mcp from '@orval/mcp';\nimport * as mock from '@orval/mock';\nimport query from '@orval/query';\nimport solidStart from '@orval/solid-start';\nimport swr from '@orval/swr';\nimport zod from '@orval/zod';\n\nconst DEFAULT_CLIENT = OutputClient.AXIOS;\n\nconst getGeneratorClient = (\n  outputClient: OutputClient | OutputClientFunc,\n  output: NormalizedOutputOptions,\n) => {\n  const GENERATOR_CLIENT: GeneratorClients = {\n    axios: axios({ type: 'axios' })(),\n    'axios-functions': axios({ type: 'axios-functions' })(),\n    angular: angular()(),\n    'angular-query': query({ output, type: 'angular-query' })(),\n    'react-query': query({ output, type: 'react-query' })(),\n    'solid-start': solidStart()(),\n    'solid-query': query({ output, type: 'solid-query' })(),\n    'svelte-query': query({ output, type: 'svelte-query' })(),\n    'vue-query': query({ output, type: 'vue-query' })(),\n    swr: swr()(),\n    zod: zod()(),\n    hono: hono()(),\n    fetch: fetchClient()(),\n    mcp: mcp()(),\n  };\n\n  const generator = isFunction(outputClient)\n    ? outputClient(GENERATOR_CLIENT)\n    : GENERATOR_CLIENT[outputClient];\n\n  if (!generator) {\n    throw new Error(`Oups... üçª. Client not found: ${outputClient}`);\n  }\n\n  return generator;\n};\n\nexport const generateClientImports: GeneratorClientImports = ({\n  client,\n  implementation,\n  imports,\n  projectName,\n  hasSchemaDir,\n  isAllowSyntheticDefaultImports,\n  hasGlobalMutator,\n  hasTagsMutator,\n  hasParamsSerializerOptions,\n  packageJson,\n  output,\n}) => {\n  const { dependencies } = getGeneratorClient(client, output);\n  return generateDependencyImports(\n    implementation,\n    dependencies\n      ? [\n          ...dependencies(\n            hasGlobalMutator,\n            hasParamsSerializerOptions,\n            packageJson,\n            output.httpClient,\n            hasTagsMutator,\n            output.override,\n          ),\n          ...imports,\n        ]\n      : imports,\n    projectName,\n    hasSchemaDir,\n    isAllowSyntheticDefaultImports,\n  );\n};\n\nexport const generateClientHeader: GeneratorClientHeader = ({\n  outputClient = DEFAULT_CLIENT,\n  isRequestOptions,\n  isGlobalMutator,\n  isMutator,\n  provideIn,\n  hasAwaitedType,\n  titles,\n  output,\n  verbOptions,\n  tag,\n  clientImplementation,\n}) => {\n  const { header } = getGeneratorClient(outputClient, output);\n  return {\n    implementation: header\n      ? header({\n          title: titles.implementation,\n          isRequestOptions,\n          isGlobalMutator,\n          isMutator,\n          provideIn,\n          hasAwaitedType,\n          output,\n          verbOptions,\n          tag,\n          clientImplementation,\n        })\n      : '',\n    implementationMock: `export const ${titles.implementationMock} = () => [\\n`,\n  };\n};\n\nexport const generateClientFooter: GeneratorClientFooter = ({\n  outputClient,\n  operationNames,\n  hasMutator,\n  hasAwaitedType,\n  titles,\n  output,\n}) => {\n  const { footer } = getGeneratorClient(outputClient, output);\n\n  if (!footer) {\n    return {\n      implementation: '',\n      implementationMock: `\\n]\\n`,\n    };\n  }\n\n  let implementation: string;\n  try {\n    if (isFunction(outputClient)) {\n      implementation = (footer as (operationNames: any) => string)(\n        operationNames,\n      );\n      // being here means that the previous call worked\n      console.warn(\n        '[WARN] Passing an array of strings for operations names to the footer function is deprecated and will be removed in a future major release. Please pass them in an object instead: { operationNames: string[] }.',\n      );\n    } else {\n      implementation = footer({\n        operationNames,\n        title: titles.implementation,\n        hasMutator,\n        hasAwaitedType,\n      });\n    }\n  } catch {\n    implementation = footer({\n      operationNames,\n      title: titles.implementation,\n      hasMutator,\n      hasAwaitedType,\n    });\n  }\n\n  return {\n    implementation,\n    implementationMock: `]\\n`,\n  };\n};\n\nexport const generateClientTitle: GeneratorClientTitle = ({\n  outputClient = DEFAULT_CLIENT,\n  title,\n  customTitleFunc,\n  output,\n}) => {\n  const { title: generatorTitle } = getGeneratorClient(outputClient, output);\n\n  if (!generatorTitle) {\n    return {\n      implementation: '',\n      implementationMock: `get${pascal(title)}Mock`,\n    };\n  }\n\n  if (customTitleFunc) {\n    const customTitle = customTitleFunc(title);\n    return {\n      implementation: generatorTitle(customTitle),\n      implementationMock: `get${pascal(customTitle)}Mock`,\n    };\n  }\n  return {\n    implementation: generatorTitle(title),\n    implementationMock: `get${pascal(title)}Mock`,\n  };\n};\n\nconst generateMock = (\n  verbOption: GeneratorVerbOptions,\n  options: GeneratorOptions,\n): ClientMockGeneratorBuilder => {\n  if (!options.mock) {\n    return {\n      implementation: {\n        function: '',\n        handler: '',\n        handlerName: '',\n      },\n      imports: [],\n    };\n  }\n\n  if (isFunction(options.mock)) {\n    return options.mock(verbOption, options);\n  }\n\n  return mock.generateMock(\n    verbOption,\n    options as typeof options & {\n      mock: Exclude<(typeof options)['mock'], Function | undefined>;\n    },\n  );\n};\n\nexport const generateOperations = (\n  outputClient: OutputClient | OutputClientFunc = DEFAULT_CLIENT,\n  verbsOptions: GeneratorVerbsOptions,\n  options: GeneratorOptions,\n  output: NormalizedOutputOptions,\n): Promise<GeneratorOperations> => {\n  return asyncReduce(\n    verbsOptions,\n    async (acc, verbOption) => {\n      const { client: generatorClient } = getGeneratorClient(\n        outputClient,\n        output,\n      );\n      const client = await generatorClient(\n        verbOption,\n        options,\n        outputClient,\n        output,\n      );\n\n      if (!client.implementation) {\n        return acc;\n      }\n\n      const generatedMock = generateMock(verbOption, options);\n\n      acc[verbOption.operationId] = {\n        implementation: verbOption.doc + client.implementation,\n        imports: client.imports,\n        implementationMock: generatedMock.implementation,\n        importsMock: generatedMock.imports,\n        tags: verbOption.tags,\n        mutator: verbOption.mutator,\n        clientMutators: client.mutators,\n        formData: verbOption.formData,\n        formUrlEncoded: verbOption.formUrlEncoded,\n        paramsSerializer: verbOption.paramsSerializer,\n        operationName: verbOption.operationName,\n        fetchReviver: verbOption.fetchReviver,\n      };\n\n      return acc;\n    },\n    {} as GeneratorOperations,\n  );\n};\n\nexport const generateExtraFiles = (\n  outputClient: OutputClient | OutputClientFunc = DEFAULT_CLIENT,\n  verbsOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n): Promise<ClientFileBuilder[]> => {\n  const { extraFiles: generateExtraFiles } = getGeneratorClient(\n    outputClient,\n    output,\n  );\n\n  if (!generateExtraFiles) {\n    return Promise.resolve([]);\n  }\n\n  return generateExtraFiles(verbsOptions, output, context);\n};\n","import {\n  asyncReduce,\n  type ContextSpec,\n  generateVerbsOptions,\n  type GeneratorApiBuilder,\n  type GeneratorApiOperations,\n  type GeneratorSchema,\n  getFullRoute,\n  getRoute,\n  GetterPropType,\n  isReference,\n  type NormalizedInputOptions,\n  type NormalizedOutputOptions,\n  type OpenApiPathItemObject,\n  resolveRef,\n} from '@orval/core';\nimport { generateMockImports } from '@orval/mock';\n\nimport {\n  generateClientFooter,\n  generateClientHeader,\n  generateClientImports,\n  generateClientTitle,\n  generateExtraFiles,\n  generateOperations,\n} from './client';\n\nexport async function getApiBuilder({\n  input,\n  output,\n  context,\n}: {\n  input: NormalizedInputOptions;\n  output: NormalizedOutputOptions;\n  context: ContextSpec;\n}): Promise<GeneratorApiBuilder> {\n  const api = await asyncReduce(\n    Object.entries(context.spec.paths ?? {}),\n    async (acc, [pathRoute, verbs]) => {\n      const route = getRoute(pathRoute);\n\n      let resolvedVerbs = verbs;\n\n      if (isReference(verbs)) {\n        const { schema, imports } = resolveRef<OpenApiPathItemObject>(\n          verbs,\n          context,\n        );\n\n        resolvedVerbs = schema;\n      }\n\n      let verbsOptions = await generateVerbsOptions({\n        verbs: resolvedVerbs,\n        input,\n        output,\n        route,\n        pathRoute,\n        context,\n      });\n\n      // GitHub #564 check if we want to exclude deprecated operations\n      if (output.override.useDeprecatedOperations === false) {\n        verbsOptions = verbsOptions.filter((verb) => {\n          return !verb.deprecated;\n        });\n      }\n\n      const schemas = verbsOptions.reduce<GeneratorSchema[]>(\n        (acc, { queryParams, headers, body, response, props }) => {\n          if (props) {\n            acc.push(\n              ...props.flatMap((param) =>\n                param.type === GetterPropType.NAMED_PATH_PARAMS\n                  ? param.schema\n                  : [],\n              ),\n            );\n          }\n          if (queryParams) {\n            acc.push(queryParams.schema, ...queryParams.deps);\n          }\n          if (headers) {\n            acc.push(headers.schema, ...headers.deps);\n          }\n\n          acc.push(...body.schemas, ...response.schemas);\n\n          return acc;\n        },\n        [],\n      );\n\n      const fullRoute = getFullRoute(\n        route,\n        verbs.servers ?? context.spec.servers,\n        output.baseUrl,\n      );\n      if (!output.target) {\n        throw new Error('Output does not have a target');\n      }\n      const pathOperations = await generateOperations(\n        output.client,\n        verbsOptions,\n        {\n          route: fullRoute,\n          pathRoute,\n          override: output.override,\n          context,\n          mock: output.mock,\n          output: output.target,\n        },\n        output,\n      );\n\n      for (const verbOption of verbsOptions) {\n        acc.verbOptions[verbOption.operationId] = verbOption;\n      }\n      acc.schemas.push(...schemas);\n      acc.operations = { ...acc.operations, ...pathOperations };\n\n      return acc;\n    },\n    {\n      operations: {},\n      verbOptions: {},\n      schemas: [],\n    } as GeneratorApiOperations,\n  );\n\n  const extraFiles = await generateExtraFiles(\n    output.client,\n    api.verbOptions,\n    output,\n    context,\n  );\n\n  return {\n    operations: api.operations,\n    schemas: api.schemas,\n    verbOptions: api.verbOptions,\n    title: generateClientTitle,\n    header: generateClientHeader,\n    footer: generateClientFooter,\n    imports: generateClientImports,\n    importsMock: generateMockImports,\n    extraFiles,\n  };\n}\n","import {\n  type ContextSpec,\n  dynamicImport,\n  generateComponentDefinition,\n  generateParameterDefinition,\n  generateSchemasDefinition,\n  type ImportOpenApi,\n  type InputOptions,\n  type NormalizedOutputOptions,\n  type OpenApiComponentsObject,\n  type OpenApiDocument,\n  type OverrideInput,\n  type WriteSpecBuilder,\n} from '@orval/core';\nimport { validate } from '@scalar/openapi-parser';\n\nimport { getApiBuilder } from './api';\n\nexport async function importOpenApi({\n  spec,\n  input,\n  output,\n  target,\n  workspace,\n  projectName,\n}: ImportOpenApi): Promise<WriteSpecBuilder> {\n  const transformedOpenApi = await applyTransformer(\n    spec,\n    input.override.transformer,\n    workspace,\n  );\n\n  const schemas = getApiSchemas({\n    input,\n    output,\n    target,\n    workspace,\n    spec: transformedOpenApi,\n  });\n\n  const api = await getApiBuilder({\n    input,\n    output,\n    context: {\n      projectName,\n      target,\n      workspace,\n      spec: transformedOpenApi,\n      output,\n    } satisfies ContextSpec,\n  });\n\n  return {\n    ...api,\n    schemas: [...schemas, ...api.schemas],\n    target,\n    // a valid spec will have info\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    info: transformedOpenApi.info!,\n    spec: transformedOpenApi,\n  };\n}\n\nasync function applyTransformer(\n  openApi: OpenApiDocument,\n  transformer: OverrideInput['transformer'],\n  workspace: string,\n): Promise<OpenApiDocument> {\n  const transformerFn = transformer\n    ? await dynamicImport(transformer, workspace)\n    : undefined;\n\n  if (!transformerFn) {\n    return openApi;\n  }\n\n  const transformedOpenApi = transformerFn(openApi);\n\n  const { valid, errors } = await validate(transformedOpenApi);\n  if (!valid) {\n    throw new Error(`Validation failed`, { cause: errors });\n  }\n\n  return transformedOpenApi;\n}\n\ninterface GetApiSchemasOptions {\n  input: InputOptions;\n  output: NormalizedOutputOptions;\n  workspace: string;\n  target: string;\n  spec: OpenApiDocument;\n}\n\nfunction getApiSchemas({\n  input,\n  output,\n  target,\n  workspace,\n  spec,\n}: GetApiSchemasOptions) {\n  const context: ContextSpec = {\n    target,\n    workspace,\n    spec,\n    output,\n  };\n\n  const schemaDefinition = generateSchemasDefinition(\n    spec.components?.schemas,\n    context,\n    output.override.components.schemas.suffix,\n    input.filters,\n  );\n\n  const responseDefinition = generateComponentDefinition(\n    spec.components?.responses,\n    context,\n    output.override.components.responses.suffix,\n  );\n\n  const swaggerResponseDefinition = generateComponentDefinition(\n    'responses' in spec\n      ? (spec as { responses?: OpenApiComponentsObject['responses'] }).responses\n      : undefined,\n    context,\n    '',\n  );\n\n  const bodyDefinition = generateComponentDefinition(\n    spec.components?.requestBodies,\n    context,\n    output.override.components.requestBodies.suffix,\n  );\n\n  const parameters = generateParameterDefinition(\n    spec.components?.parameters,\n    context,\n    output.override.components.parameters.suffix,\n  );\n\n  const schemas = [\n    ...schemaDefinition,\n    ...responseDefinition,\n    ...swaggerResponseDefinition,\n    ...bodyDefinition,\n    ...parameters,\n  ];\n\n  return schemas;\n}\n","import {\n  type NormalizedOptions,\n  type OpenApiDocument,\n  type WriteSpecBuilder,\n} from '@orval/core';\nimport { bundle } from '@scalar/json-magic/bundle';\nimport {\n  fetchUrls,\n  parseJson,\n  parseYaml,\n  readFiles,\n} from '@scalar/json-magic/bundle/plugins/node';\nimport { upgrade, validate as validateSpec } from '@scalar/openapi-parser';\n\nimport { importOpenApi } from './import-open-api';\n\nasync function resolveSpec(\n  input: string | Record<string, unknown>,\n  parserOptions?: {\n    headers?: {\n      domains: string[];\n      headers: Record<string, string>;\n    }[];\n  },\n): Promise<OpenApiDocument> {\n  const data = await bundle(input, {\n    plugins: [\n      readFiles(),\n      fetchUrls({\n        headers: parserOptions?.headers,\n      }),\n      parseJson(),\n      parseYaml(),\n    ],\n    treeShake: true,\n  });\n  const dereferencedData = dereferenceExternalRef(data);\n  const { valid, errors } = await validateSpec(dereferencedData);\n  if (!valid) {\n    throw new Error('Validation failed', { cause: errors });\n  }\n\n  const { specification } = upgrade(dereferencedData);\n\n  return specification;\n}\n\nexport async function importSpecs(\n  workspace: string,\n  options: NormalizedOptions,\n  projectName?: string,\n): Promise<WriteSpecBuilder> {\n  const { input, output } = options;\n\n  const spec = await resolveSpec(input.target, input.parserOptions);\n\n  return importOpenApi({\n    spec,\n    input,\n    output,\n    target: input.target,\n    workspace,\n    projectName,\n  });\n}\n\n/**\n * The plugins from `@scalar/json-magic` does not dereference $ref.\n * Instead it fetches them and puts them under x-ext, and changes the $ref to point to #x-ext/<name>.\n * This function dereferences those x-ext $ref's.\n */\nexport function dereferenceExternalRef(data: object): object {\n  const extensions = data['x-ext'] ?? {};\n\n  const UNWANTED_KEYS = new Set(['$schema', '$id']);\n\n  function scrub(obj: unknown): unknown {\n    if (obj === null || obj === undefined) return obj;\n    if (Array.isArray(obj)) return obj.map((x) => scrub(x));\n    if (typeof obj === 'object') {\n      const rec = obj as Record<string, unknown>;\n      const out: Record<string, unknown> = {};\n      for (const [k, v] of Object.entries(rec)) {\n        if (UNWANTED_KEYS.has(k)) continue;\n        out[k] = scrub(v);\n      }\n      return out;\n    }\n    return obj;\n  }\n\n  function replaceRefs(obj: unknown): unknown {\n    if (obj === null || obj === undefined) {\n      return obj;\n    }\n\n    if (typeof obj === 'object') {\n      if (Array.isArray(obj)) {\n        return obj.map((element) => replaceRefs(element));\n      }\n\n      const record = obj as Record<string, unknown>;\n\n      // Check if this object is a $ref to x-ext\n      if ('$ref' in record && typeof record.$ref === 'string') {\n        const refValue = record.$ref;\n        if (refValue.startsWith('#/x-ext/')) {\n          const pathStr = refValue.replace('#/x-ext/', '');\n          const parts = pathStr.split('/');\n          const extKey = parts.shift();\n          if (extKey) {\n            let refObj: unknown = extensions[extKey];\n            // Traverse remaining path parts inside the extension object\n            for (const p of parts) {\n              if (\n                refObj &&\n                typeof refObj === 'object' &&\n                p in (refObj as Record<string, unknown>)\n              ) {\n                refObj = (refObj as Record<string, unknown>)[p];\n              } else {\n                refObj = undefined;\n                break;\n              }\n            }\n\n            if (refObj) {\n              // Scrub unwanted keys from the extension before inlining\n              const cleaned = scrub(refObj);\n              // Replace the $ref with the dereferenced (and scrubbed) object\n              return replaceRefs(cleaned);\n            }\n          }\n        }\n      }\n\n      // Recursively process all properties\n      const result: Record<string, unknown> = {};\n      for (const [key, value] of Object.entries(record)) {\n        result[key] = replaceRefs(value);\n      }\n      return result;\n    }\n\n    return obj;\n  }\n\n  // Create a new object with dereferenced properties (excluding x-ext)\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(data)) {\n    if (key !== 'x-ext') {\n      result[key] = replaceRefs(value);\n    }\n  }\n\n  return result;\n}\n","import {\n  type Hook,\n  type HookOption,\n  isFunction,\n  isObject,\n  isString,\n  log,\n  logError,\n  type NormalizedHookCommand,\n} from '@orval/core';\nimport chalk from 'chalk';\nimport { execa } from 'execa';\nimport { parseArgsStringToArgv } from 'string-argv';\n\nexport const executeHook = async (\n  name: Hook,\n  commands: NormalizedHookCommand = [],\n  args: string[] = [],\n) => {\n  log(chalk.white(`Running ${name} hook...`));\n\n  for (const command of commands) {\n    try {\n      if (isString(command)) {\n        await executeCommand(command, args);\n      } else if (isFunction(command)) {\n        await command(args);\n      } else if (isObject(command)) {\n        await executeObjectCommand(command as HookOption, args);\n      }\n    } catch (error) {\n      logError(error, `Failed to run ${name} hook`);\n    }\n  }\n};\n\nasync function executeCommand(command: string, args: string[]) {\n  const [cmd, ..._args] = [...parseArgsStringToArgv(command), ...args];\n\n  await execa(cmd, _args);\n}\n\nasync function executeObjectCommand(command: HookOption, args: string[]) {\n  if (command.injectGeneratedDirsAndFiles === false) {\n    args = [];\n  }\n\n  if (isString(command.command)) {\n    await executeCommand(command.command, args);\n  } else if (isFunction(command.command)) {\n    await command.command();\n  }\n}\n","import { dynamicImport, isString, log, type PackageJson } from '@orval/core';\nimport chalk from 'chalk';\nimport { findUp, findUpMultiple } from 'find-up';\nimport fs from 'fs-extra';\nimport yaml from 'js-yaml';\n\nimport { normalizePath } from './options';\n\ntype CatalogData = Pick<PackageJson, 'catalog' | 'catalogs'>;\n\nexport const loadPackageJson = async (\n  packageJson?: string,\n  workspace = process.cwd(),\n): Promise<PackageJson | undefined> => {\n  if (!packageJson) {\n    const pkgPath = await findUp(['package.json'], { cwd: workspace });\n    if (pkgPath) {\n      const pkg = await dynamicImport<unknown>(pkgPath, workspace);\n\n      if (isPackageJson(pkg)) {\n        return await maybeReplaceCatalog(pkg, workspace);\n      } else {\n        throw new Error('Invalid package.json file');\n      }\n    }\n    return;\n  }\n\n  const normalizedPath = normalizePath(packageJson, workspace);\n  if (fs.existsSync(normalizedPath)) {\n    const pkg = await dynamicImport<unknown>(normalizedPath);\n\n    if (isPackageJson(pkg)) {\n      return await maybeReplaceCatalog(pkg, workspace);\n    } else {\n      throw new Error(`Invalid package.json file: ${normalizedPath}`);\n    }\n  }\n  return;\n};\n\nconst isPackageJson = (obj: any): obj is PackageJson =>\n  typeof obj === 'object' && obj !== null;\n\nconst hasCatalogReferences = (pkg: PackageJson): boolean => {\n  return [\n    ...Object.entries(pkg.dependencies ?? {}),\n    ...Object.entries(pkg.devDependencies ?? {}),\n    ...Object.entries(pkg.peerDependencies ?? {}),\n  ].some(([, value]) => isString(value) && value.startsWith('catalog:'));\n};\n\nconst loadPnpmWorkspaceCatalog = async (\n  workspace: string,\n): Promise<CatalogData | undefined> => {\n  const filePath = await findUp('pnpm-workspace.yaml', { cwd: workspace });\n  if (!filePath) return undefined;\n  try {\n    const file = await fs.readFile(filePath, 'utf8');\n    const data = yaml.load(file) as Record<string, any> | undefined;\n    if (!data?.catalog && !data?.catalogs) return undefined;\n    return { catalog: data.catalog, catalogs: data.catalogs };\n  } catch {\n    return undefined;\n  }\n};\n\nconst loadPackageJsonCatalog = async (\n  workspace: string,\n): Promise<CatalogData | undefined> => {\n  const filePaths = await findUpMultiple('package.json', { cwd: workspace });\n\n  for (const filePath of filePaths) {\n    try {\n      const pkg = await fs.readJson(filePath);\n      if (pkg?.catalog || pkg?.catalogs) {\n        return { catalog: pkg.catalog, catalogs: pkg.catalogs };\n      }\n    } catch {\n      // Continue to next file\n    }\n  }\n  return undefined;\n};\n\nconst loadYarnrcCatalog = async (\n  workspace: string,\n): Promise<CatalogData | undefined> => {\n  const filePath = await findUp('.yarnrc.yml', { cwd: workspace });\n  if (!filePath) return undefined;\n  try {\n    const file = await fs.readFile(filePath, 'utf8');\n    const data = yaml.load(file) as Record<string, any> | undefined;\n    if (!data?.catalog && !data?.catalogs) return undefined;\n    return { catalog: data.catalog, catalogs: data.catalogs };\n  } catch {\n    return undefined;\n  }\n};\n\nconst maybeReplaceCatalog = async (\n  pkg: PackageJson,\n  workspace: string,\n): Promise<PackageJson> => {\n  if (!hasCatalogReferences(pkg)) {\n    return pkg;\n  }\n\n  const catalogData =\n    (await loadPnpmWorkspaceCatalog(workspace)) ??\n    (await loadPackageJsonCatalog(workspace)) ??\n    (await loadYarnrcCatalog(workspace));\n\n  if (!catalogData) {\n    log(\n      `‚ö†Ô∏è  ${chalk.yellow('package.json contains catalog: references, but no catalog source was found (checked: pnpm-workspace.yaml, package.json, .yarnrc.yml).')}`,\n    );\n    return pkg;\n  }\n\n  performSubstitution(pkg.dependencies, catalogData);\n  performSubstitution(pkg.devDependencies, catalogData);\n  performSubstitution(pkg.peerDependencies, catalogData);\n\n  return pkg;\n};\n\nconst performSubstitution = (\n  dependencies: Record<string, string> | undefined,\n  catalogData: CatalogData,\n) => {\n  if (!dependencies) return;\n  for (const [packageName, version] of Object.entries(dependencies)) {\n    if (version === 'catalog:' || version === 'catalog:default') {\n      if (!catalogData.catalog) {\n        log(\n          `‚ö†Ô∏è  ${chalk.yellow(`catalog: substitution for the package '${packageName}' failed as there is no default catalog.`)}`,\n        );\n        continue;\n      }\n      const sub = catalogData.catalog[packageName];\n      if (!sub) {\n        log(\n          `‚ö†Ô∏è  ${chalk.yellow(`catalog: substitution for the package '${packageName}' failed as there is no matching package in the default catalog.`)}`,\n        );\n        continue;\n      }\n      dependencies[packageName] = sub;\n    } else if (version.startsWith('catalog:')) {\n      const catalogName = version.slice('catalog:'.length);\n      const catalog = catalogData.catalogs?.[catalogName];\n      if (!catalog) {\n        log(\n          `‚ö†Ô∏è  ${chalk.yellow(`'${version}' substitution for the package '${packageName}' failed as there is no matching catalog named '${catalogName}'. (available named catalogs are: ${Object.keys(catalogData.catalogs ?? {}).join(', ')})`)}`,\n        );\n        continue;\n      }\n      const sub = catalog[packageName];\n      if (!sub) {\n        log(\n          `‚ö†Ô∏è  ${chalk.yellow(`'${version}' substitution for the package '${packageName}' failed as there is no package in the catalog named '${catalogName}'. (packages in the catalog are: ${Object.keys(catalog).join(', ')})`)}`,\n        );\n        continue;\n      }\n      dependencies[packageName] = sub;\n    }\n  }\n};\n","import { isObject, isString, isUndefined, type Tsconfig } from '@orval/core';\nimport { findUp } from 'find-up';\nimport fs from 'fs-extra';\nimport { parse } from 'tsconfck';\n\nimport { normalizePath } from './options';\n\nexport const loadTsconfig = async (\n  tsconfig?: Tsconfig | string,\n  workspace = process.cwd(),\n): Promise<Tsconfig | undefined> => {\n  if (isUndefined(tsconfig)) {\n    const configPath = await findUp(['tsconfig.json', 'jsconfig.json'], {\n      cwd: workspace,\n    });\n    if (configPath) {\n      const config = await parse(configPath);\n      return config.tsconfig;\n    }\n    return;\n  }\n\n  if (isString(tsconfig)) {\n    const normalizedPath = normalizePath(tsconfig, workspace);\n    if (fs.existsSync(normalizedPath)) {\n      const config = await parse(normalizedPath);\n\n      const tsconfig =\n        config.referenced?.find(\n          ({ tsconfigFile }) => tsconfigFile === normalizedPath,\n        )?.tsconfig || config.tsconfig;\n\n      return tsconfig;\n    }\n    return;\n  }\n\n  if (isObject(tsconfig)) {\n    return tsconfig;\n  }\n  return;\n};\n","import {\n  type ClientMockBuilder,\n  type ConfigExternal,\n  createLogger,\n  FormDataArrayHandling,\n  type GlobalMockOptions,\n  type GlobalOptions,\n  type HonoOptions,\n  type Hook,\n  type HookFunction,\n  type HookOption,\n  type HooksOptions,\n  isBoolean,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n  isUrl,\n  type JsDocOptions,\n  type Mutator,\n  NamingConvention,\n  type NormalizedHonoOptions,\n  type NormalizedHookOptions,\n  type NormalizedJsDocOptions,\n  type NormalizedMutator,\n  type NormalizedOperationOptions,\n  type NormalizedOptions,\n  type NormalizedOverrideOutput,\n  type NormalizedQueryOptions,\n  type NormalizedSchemaOptions,\n  type OperationOptions,\n  type OptionsExport,\n  OutputClient,\n  OutputHttpClient,\n  OutputMode,\n  type OverrideOutput,\n  PropertySortOrder,\n  type QueryOptions,\n  RefComponentSuffix,\n  type SchemaGenerationType,\n  type SchemaOptions,\n  upath,\n} from '@orval/core';\nimport { DEFAULT_MOCK_OPTIONS } from '@orval/mock';\nimport chalk from 'chalk';\n\nimport pkg from '../../package.json';\nimport { loadPackageJson } from './package-json';\nimport { loadTsconfig } from './tsconfig';\n\n/**\n * Type helper to make it easier to use orval.config.ts\n * accepts a direct {@link ConfigExternal} object.\n */\nexport function defineConfig(options: ConfigExternal): ConfigExternal {\n  return options;\n}\n\nfunction createFormData(\n  workspace: string,\n  formData: OverrideOutput['formData'],\n): NormalizedOverrideOutput['formData'] {\n  const defaultArrayHandling = FormDataArrayHandling.SERIALIZE;\n  if (formData === undefined)\n    return { disabled: false, arrayHandling: defaultArrayHandling };\n  if (isBoolean(formData))\n    return { disabled: !formData, arrayHandling: defaultArrayHandling };\n  if (isString(formData))\n    return {\n      disabled: false,\n      mutator: normalizeMutator(workspace, formData),\n      arrayHandling: defaultArrayHandling,\n    };\n  if ('mutator' in formData || 'arrayHandling' in formData)\n    return {\n      disabled: false,\n      mutator: normalizeMutator(workspace, formData.mutator),\n      arrayHandling: formData.arrayHandling ?? defaultArrayHandling,\n    };\n  return {\n    disabled: false,\n    mutator: normalizeMutator(workspace, formData),\n    arrayHandling: defaultArrayHandling,\n  };\n}\n\nfunction normalizeSchemasOption(\n  schemas: string | SchemaOptions | undefined,\n  workspace: string,\n): string | NormalizedSchemaOptions | undefined {\n  if (!schemas) {\n    return undefined;\n  }\n\n  if (isString(schemas)) {\n    return normalizePath(schemas, workspace);\n  }\n\n  return {\n    path: normalizePath(schemas.path, workspace),\n    type: schemas.type,\n  };\n}\n\nexport async function normalizeOptions(\n  optionsExport: OptionsExport,\n  workspace = process.cwd(),\n  globalOptions: GlobalOptions = {},\n): Promise<NormalizedOptions> {\n  const options = await (isFunction(optionsExport)\n    ? optionsExport()\n    : optionsExport);\n\n  if (!options.input) {\n    throw new Error(chalk.red(`Config require an input`));\n  }\n\n  if (!options.output) {\n    throw new Error(chalk.red(`Config require an output`));\n  }\n\n  const inputOptions = isString(options.input)\n    ? { target: options.input }\n    : options.input;\n\n  const outputOptions = isString(options.output)\n    ? { target: options.output }\n    : options.output;\n\n  const outputWorkspace = normalizePath(\n    outputOptions.workspace || '',\n    workspace,\n  );\n\n  const { clean, prettier, client, httpClient, mode, biome } = globalOptions;\n\n  const tsconfig = await loadTsconfig(\n    outputOptions.tsconfig || globalOptions.tsconfig,\n    workspace,\n  );\n\n  const packageJson = await loadPackageJson(\n    outputOptions.packageJson || globalOptions.packageJson,\n    workspace,\n  );\n\n  const mockOption = outputOptions.mock ?? globalOptions.mock;\n  let mock: GlobalMockOptions | ClientMockBuilder | undefined;\n  if (typeof mockOption === 'boolean' && mockOption) {\n    mock = DEFAULT_MOCK_OPTIONS;\n  } else if (isFunction(mockOption)) {\n    mock = mockOption;\n  } else if (mockOption) {\n    mock = {\n      ...DEFAULT_MOCK_OPTIONS,\n      ...mockOption,\n    };\n  } else {\n    mock = undefined;\n  }\n\n  const defaultFileExtension = '.ts';\n\n  const globalQueryOptions: NormalizedQueryOptions = {\n    useQuery: true,\n    useMutation: true,\n    signal: true,\n    shouldExportMutatorHooks: true,\n    shouldExportHttpClient: true,\n    shouldExportQueryKey: true,\n    shouldSplitQueryKey: false,\n    ...normalizeQueryOptions(outputOptions.override?.query, workspace),\n  };\n\n  const normalizedOptions: NormalizedOptions = {\n    input: {\n      target: globalOptions.input\n        ? normalizePathOrUrl(globalOptions.input, process.cwd())\n        : normalizePathOrUrl(inputOptions.target, workspace),\n      override: {\n        transformer: normalizePath(\n          inputOptions.override?.transformer,\n          workspace,\n        ),\n      },\n      filters: inputOptions.filters,\n      parserOptions: inputOptions.parserOptions,\n    },\n    output: {\n      target: globalOptions.output\n        ? normalizePath(globalOptions.output, process.cwd())\n        : normalizePath(outputOptions.target, outputWorkspace),\n      schemas: normalizeSchemasOption(outputOptions.schemas, outputWorkspace),\n      operationSchemas: outputOptions.operationSchemas\n        ? normalizePath(outputOptions.operationSchemas, outputWorkspace)\n        : undefined,\n      namingConvention:\n        outputOptions.namingConvention || NamingConvention.CAMEL_CASE,\n      fileExtension: outputOptions.fileExtension || defaultFileExtension,\n      workspace: outputOptions.workspace ? outputWorkspace : undefined,\n      client: outputOptions.client ?? client ?? OutputClient.AXIOS_FUNCTIONS,\n      httpClient:\n        outputOptions.httpClient ??\n        httpClient ??\n        // Auto-detect: use Angular HttpClient for angular-query by default\n        ((outputOptions.client ?? client) === OutputClient.ANGULAR_QUERY\n          ? OutputHttpClient.ANGULAR\n          : OutputHttpClient.FETCH),\n      mode: normalizeOutputMode(outputOptions.mode ?? mode),\n      mock,\n      clean: outputOptions.clean ?? clean ?? false,\n      docs: outputOptions.docs ?? false,\n      prettier: outputOptions.prettier ?? prettier ?? false,\n      biome: outputOptions.biome ?? biome ?? false,\n      tsconfig,\n      packageJson,\n      headers: outputOptions.headers ?? false,\n      indexFiles: outputOptions.indexFiles ?? true,\n      baseUrl: outputOptions.baseUrl,\n      unionAddMissingProperties:\n        outputOptions.unionAddMissingProperties ?? false,\n      override: {\n        ...outputOptions.override,\n        mock: {\n          arrayMin: outputOptions.override?.mock?.arrayMin ?? 1,\n          arrayMax: outputOptions.override?.mock?.arrayMax ?? 10,\n          stringMin: outputOptions.override?.mock?.stringMin ?? 10,\n          stringMax: outputOptions.override?.mock?.stringMax ?? 20,\n          fractionDigits: outputOptions.override?.mock?.fractionDigits ?? 2,\n          ...outputOptions.override?.mock,\n        },\n        operations: normalizeOperationsAndTags(\n          outputOptions.override?.operations ?? {},\n          outputWorkspace,\n          {\n            query: globalQueryOptions,\n          },\n        ),\n        tags: normalizeOperationsAndTags(\n          outputOptions.override?.tags ?? {},\n          outputWorkspace,\n          {\n            query: globalQueryOptions,\n          },\n        ),\n        mutator: normalizeMutator(\n          outputWorkspace,\n          outputOptions.override?.mutator,\n        ),\n        formData: createFormData(\n          outputWorkspace,\n          outputOptions.override?.formData,\n        ),\n        formUrlEncoded:\n          (isBoolean(outputOptions.override?.formUrlEncoded)\n            ? outputOptions.override?.formUrlEncoded\n            : normalizeMutator(\n                outputWorkspace,\n                outputOptions.override?.formUrlEncoded,\n              )) ?? true,\n        paramsSerializer: normalizeMutator(\n          outputWorkspace,\n          outputOptions.override?.paramsSerializer,\n        ),\n        header:\n          outputOptions.override?.header === false\n            ? false\n            : isFunction(outputOptions.override?.header)\n              ? outputOptions.override?.header!\n              : getDefaultFilesHeader,\n        requestOptions: outputOptions.override?.requestOptions ?? true,\n        namingConvention: outputOptions.override?.namingConvention ?? {},\n        components: {\n          schemas: {\n            suffix: RefComponentSuffix.schemas,\n            itemSuffix:\n              outputOptions.override?.components?.schemas?.itemSuffix ?? 'Item',\n            ...outputOptions.override?.components?.schemas,\n          },\n          responses: {\n            suffix: RefComponentSuffix.responses,\n            ...outputOptions.override?.components?.responses,\n          },\n          parameters: {\n            suffix: RefComponentSuffix.parameters,\n            ...outputOptions.override?.components?.parameters,\n          },\n          requestBodies: {\n            suffix: RefComponentSuffix.requestBodies,\n            ...outputOptions.override?.components?.requestBodies,\n          },\n        },\n        hono: normalizeHonoOptions(outputOptions.override?.hono, workspace),\n        jsDoc: normalizeJSDocOptions(outputOptions.override?.jsDoc),\n        query: globalQueryOptions,\n        zod: {\n          strict: {\n            param: outputOptions.override?.zod?.strict?.param ?? false,\n            query: outputOptions.override?.zod?.strict?.query ?? false,\n            header: outputOptions.override?.zod?.strict?.header ?? false,\n            body: outputOptions.override?.zod?.strict?.body ?? false,\n            response: outputOptions.override?.zod?.strict?.response ?? false,\n          },\n          generate: {\n            param: outputOptions.override?.zod?.generate?.param ?? true,\n            query: outputOptions.override?.zod?.generate?.query ?? true,\n            header: outputOptions.override?.zod?.generate?.header ?? true,\n            body: outputOptions.override?.zod?.generate?.body ?? true,\n            response: outputOptions.override?.zod?.generate?.response ?? true,\n          },\n          coerce: {\n            param: outputOptions.override?.zod?.coerce?.param ?? false,\n            query: outputOptions.override?.zod?.coerce?.query ?? false,\n            header: outputOptions.override?.zod?.coerce?.header ?? false,\n            body: outputOptions.override?.zod?.coerce?.body ?? false,\n            response: outputOptions.override?.zod?.coerce?.response ?? false,\n          },\n          preprocess: {\n            ...(outputOptions.override?.zod?.preprocess?.param\n              ? {\n                  param: normalizeMutator(\n                    workspace,\n                    outputOptions.override.zod.preprocess.param,\n                  ),\n                }\n              : {}),\n            ...(outputOptions.override?.zod?.preprocess?.query\n              ? {\n                  query: normalizeMutator(\n                    workspace,\n                    outputOptions.override.zod.preprocess.query,\n                  ),\n                }\n              : {}),\n            ...(outputOptions.override?.zod?.preprocess?.header\n              ? {\n                  header: normalizeMutator(\n                    workspace,\n                    outputOptions.override.zod.preprocess.header,\n                  ),\n                }\n              : {}),\n            ...(outputOptions.override?.zod?.preprocess?.body\n              ? {\n                  body: normalizeMutator(\n                    workspace,\n                    outputOptions.override.zod.preprocess.body,\n                  ),\n                }\n              : {}),\n            ...(outputOptions.override?.zod?.preprocess?.response\n              ? {\n                  response: normalizeMutator(\n                    workspace,\n                    outputOptions.override.zod.preprocess.response,\n                  ),\n                }\n              : {}),\n          },\n          generateEachHttpStatus:\n            outputOptions.override?.zod?.generateEachHttpStatus ?? false,\n          dateTimeOptions: outputOptions.override?.zod?.dateTimeOptions ?? {},\n          timeOptions: outputOptions.override?.zod?.timeOptions ?? {},\n        },\n        swr: {\n          generateErrorTypes: false,\n          ...outputOptions.override?.swr,\n        },\n        angular: {\n          provideIn: outputOptions.override?.angular?.provideIn ?? 'root',\n        },\n        fetch: {\n          includeHttpResponseReturnType:\n            outputOptions.override?.fetch?.includeHttpResponseReturnType ??\n            true,\n          forceSuccessResponse:\n            outputOptions.override?.fetch?.forceSuccessResponse ?? false,\n          runtimeValidation:\n            outputOptions.override?.fetch?.runtimeValidation ?? false,\n          ...outputOptions.override?.fetch,\n        },\n        useDates: outputOptions.override?.useDates || false,\n        useDeprecatedOperations:\n          outputOptions.override?.useDeprecatedOperations ?? true,\n        enumGenerationType:\n          outputOptions.override?.enumGenerationType ?? 'const',\n        suppressReadonlyModifier:\n          outputOptions.override?.suppressReadonlyModifier || false,\n        aliasCombinedTypes: outputOptions.override?.aliasCombinedTypes ?? false,\n      },\n      allParamsOptional: outputOptions.allParamsOptional ?? false,\n      urlEncodeParameters: outputOptions.urlEncodeParameters ?? false,\n      optionsParamRequired: outputOptions.optionsParamRequired ?? false,\n      propertySortOrder:\n        outputOptions.propertySortOrder ?? PropertySortOrder.SPECIFICATION,\n    },\n    hooks: options.hooks ? normalizeHooks(options.hooks) : {},\n  };\n\n  if (!normalizedOptions.input.target) {\n    throw new Error(chalk.red(`Config require an input target`));\n  }\n\n  if (!normalizedOptions.output.target && !normalizedOptions.output.schemas) {\n    throw new Error(chalk.red(`Config require an output target or schemas`));\n  }\n\n  return normalizedOptions;\n}\n\nfunction normalizeMutator(\n  workspace: string,\n  mutator?: Mutator,\n): NormalizedMutator | undefined {\n  if (isObject(mutator)) {\n    if (!mutator.path) {\n      throw new Error(chalk.red(`Mutator need a path`));\n    }\n\n    return {\n      ...mutator,\n      path: upath.resolve(workspace, mutator.path),\n      default: (mutator.default || !mutator.name) ?? false,\n    };\n  }\n\n  if (isString(mutator)) {\n    return {\n      path: upath.resolve(workspace, mutator),\n      default: true,\n    };\n  }\n\n  return mutator;\n}\n\nfunction normalizePathOrUrl<T>(path: T, workspace: string) {\n  if (isString(path) && !isUrl(path)) {\n    return normalizePath(path, workspace);\n  }\n\n  return path;\n}\n\nexport function normalizePath<T>(path: T, workspace: string) {\n  if (!isString(path)) {\n    return path;\n  }\n  return upath.resolve(workspace, path);\n}\n\nfunction normalizeOperationsAndTags(\n  operationsOrTags: Record<string, OperationOptions>,\n  workspace: string,\n  global: {\n    query: NormalizedQueryOptions;\n  },\n): Record<string, NormalizedOperationOptions> {\n  return Object.fromEntries(\n    Object.entries(operationsOrTags).map(\n      ([\n        key,\n        {\n          transformer,\n          mutator,\n          formData,\n          formUrlEncoded,\n          paramsSerializer,\n          query,\n          zod,\n          ...rest\n        },\n      ]) => {\n        return [\n          key,\n          {\n            ...rest,\n            ...(query\n              ? {\n                  query: normalizeQueryOptions(query, workspace, global.query),\n                }\n              : {}),\n            ...(zod\n              ? {\n                  zod: {\n                    strict: {\n                      param: zod.strict?.param ?? false,\n                      query: zod.strict?.query ?? false,\n                      header: zod.strict?.header ?? false,\n                      body: zod.strict?.body ?? false,\n                      response: zod.strict?.response ?? false,\n                    },\n                    generate: {\n                      param: zod.generate?.param ?? true,\n                      query: zod.generate?.query ?? true,\n                      header: zod.generate?.header ?? true,\n                      body: zod.generate?.body ?? true,\n                      response: zod.generate?.response ?? true,\n                    },\n                    coerce: {\n                      param: zod.coerce?.param ?? false,\n                      query: zod.coerce?.query ?? false,\n                      header: zod.coerce?.header ?? false,\n                      body: zod.coerce?.body ?? false,\n                      response: zod.coerce?.response ?? false,\n                    },\n                    preprocess: {\n                      ...(zod.preprocess?.param\n                        ? {\n                            param: normalizeMutator(\n                              workspace,\n                              zod.preprocess.param,\n                            ),\n                          }\n                        : {}),\n                      ...(zod.preprocess?.query\n                        ? {\n                            query: normalizeMutator(\n                              workspace,\n                              zod.preprocess.query,\n                            ),\n                          }\n                        : {}),\n                      ...(zod.preprocess?.header\n                        ? {\n                            header: normalizeMutator(\n                              workspace,\n                              zod.preprocess.header,\n                            ),\n                          }\n                        : {}),\n                      ...(zod.preprocess?.body\n                        ? {\n                            body: normalizeMutator(\n                              workspace,\n                              zod.preprocess.body,\n                            ),\n                          }\n                        : {}),\n                      ...(zod.preprocess?.response\n                        ? {\n                            response: normalizeMutator(\n                              workspace,\n                              zod.preprocess.response,\n                            ),\n                          }\n                        : {}),\n                    },\n                    generateEachHttpStatus:\n                      zod?.generateEachHttpStatus ?? false,\n                    dateTimeOptions: zod?.dateTimeOptions ?? {},\n                    timeOptions: zod?.timeOptions ?? {},\n                  },\n                }\n              : {}),\n            ...(transformer\n              ? { transformer: normalizePath(transformer, workspace) }\n              : {}),\n            ...(mutator\n              ? { mutator: normalizeMutator(workspace, mutator) }\n              : {}),\n            ...createFormData(workspace, formData),\n            ...(formUrlEncoded\n              ? {\n                  formUrlEncoded: isBoolean(formUrlEncoded)\n                    ? formUrlEncoded\n                    : normalizeMutator(workspace, formUrlEncoded),\n                }\n              : {}),\n            ...(paramsSerializer\n              ? {\n                  paramsSerializer: normalizeMutator(\n                    workspace,\n                    paramsSerializer,\n                  ),\n                }\n              : {}),\n          },\n        ];\n      },\n    ),\n  );\n}\n\nfunction normalizeOutputMode(mode?: OutputMode): OutputMode {\n  if (!mode) {\n    return OutputMode.SINGLE;\n  }\n\n  if (!Object.values(OutputMode).includes(mode)) {\n    createLogger().warn(chalk.yellow(`Unknown the provided mode => ${mode}`));\n    return OutputMode.SINGLE;\n  }\n\n  return mode;\n}\n\nfunction normalizeHooks(hooks: HooksOptions): NormalizedHookOptions {\n  const keys = Object.keys(hooks) as unknown as Hook[];\n\n  return keys.reduce<NormalizedHookOptions>((acc, key: Hook) => {\n    if (isString(hooks[key])) {\n      return {\n        ...acc,\n        [key]: [hooks[key]] as string[],\n      };\n    } else if (Array.isArray(hooks[key])) {\n      return {\n        ...acc,\n        [key]: hooks[key] as string[],\n      };\n    } else if (isFunction(hooks[key])) {\n      return {\n        ...acc,\n        [key]: [hooks[key]] as HookFunction[],\n      };\n    } else if (isObject(hooks[key])) {\n      return {\n        ...acc,\n        [key]: [hooks[key]] as HookOption[],\n      };\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction normalizeHonoOptions(\n  hono: HonoOptions = {},\n  workspace: string,\n): NormalizedHonoOptions {\n  return {\n    ...(hono.handlers\n      ? { handlers: upath.resolve(workspace, hono.handlers) }\n      : {}),\n    compositeRoute: hono.compositeRoute ?? '',\n    validator: hono.validator ?? true,\n    validatorOutputPath: hono.validatorOutputPath\n      ? upath.resolve(workspace, hono.validatorOutputPath)\n      : '',\n  };\n}\n\nfunction normalizeJSDocOptions(\n  jsdoc: JsDocOptions = {},\n): NormalizedJsDocOptions {\n  return {\n    ...jsdoc,\n  };\n}\n\nfunction normalizeQueryOptions(\n  queryOptions: QueryOptions = {},\n  outputWorkspace: string,\n  globalOptions: NormalizedQueryOptions = {},\n): NormalizedQueryOptions {\n  if (queryOptions.options) {\n    console.warn(\n      '[WARN] Using query options is deprecated and will be removed in a future major release. Please use queryOptions or mutationOptions instead.',\n    );\n  }\n\n  return {\n    ...(isUndefined(queryOptions.usePrefetch)\n      ? {}\n      : { usePrefetch: queryOptions.usePrefetch }),\n    ...(isUndefined(queryOptions.useInvalidate)\n      ? {}\n      : { useInvalidate: queryOptions.useInvalidate }),\n    ...(isUndefined(queryOptions.useQuery)\n      ? {}\n      : { useQuery: queryOptions.useQuery }),\n    ...(isUndefined(queryOptions.useSuspenseQuery)\n      ? {}\n      : { useSuspenseQuery: queryOptions.useSuspenseQuery }),\n    ...(isUndefined(queryOptions.useMutation)\n      ? {}\n      : { useMutation: queryOptions.useMutation }),\n    ...(isUndefined(queryOptions.useInfinite)\n      ? {}\n      : { useInfinite: queryOptions.useInfinite }),\n    ...(isUndefined(queryOptions.useSuspenseInfiniteQuery)\n      ? {}\n      : { useSuspenseInfiniteQuery: queryOptions.useSuspenseInfiniteQuery }),\n    ...(queryOptions.useInfiniteQueryParam\n      ? { useInfiniteQueryParam: queryOptions.useInfiniteQueryParam }\n      : {}),\n    ...(queryOptions.options ? { options: queryOptions.options } : {}),\n    ...(globalOptions.queryKey\n      ? {\n          queryKey: globalOptions.queryKey,\n        }\n      : {}),\n    ...(queryOptions?.queryKey\n      ? {\n          queryKey: normalizeMutator(outputWorkspace, queryOptions?.queryKey),\n        }\n      : {}),\n    ...(globalOptions.queryOptions\n      ? {\n          queryOptions: globalOptions.queryOptions,\n        }\n      : {}),\n    ...(queryOptions?.queryOptions\n      ? {\n          queryOptions: normalizeMutator(\n            outputWorkspace,\n            queryOptions?.queryOptions,\n          ),\n        }\n      : {}),\n    ...(globalOptions.mutationOptions\n      ? {\n          mutationOptions: globalOptions.mutationOptions,\n        }\n      : {}),\n    ...(queryOptions?.mutationOptions\n      ? {\n          mutationOptions: normalizeMutator(\n            outputWorkspace,\n            queryOptions?.mutationOptions,\n          ),\n        }\n      : {}),\n    ...(isUndefined(globalOptions.shouldExportQueryKey)\n      ? {}\n      : {\n          shouldExportQueryKey: globalOptions.shouldExportQueryKey,\n        }),\n    ...(isUndefined(queryOptions.shouldExportQueryKey)\n      ? {}\n      : { shouldExportQueryKey: queryOptions.shouldExportQueryKey }),\n    ...(isUndefined(globalOptions.shouldExportHttpClient)\n      ? {}\n      : {\n          shouldExportHttpClient: globalOptions.shouldExportHttpClient,\n        }),\n    ...(isUndefined(queryOptions.shouldExportHttpClient)\n      ? {}\n      : { shouldExportHttpClient: queryOptions.shouldExportHttpClient }),\n    ...(isUndefined(globalOptions.shouldExportMutatorHooks)\n      ? {}\n      : {\n          shouldExportMutatorHooks: globalOptions.shouldExportMutatorHooks,\n        }),\n    ...(isUndefined(queryOptions.shouldExportMutatorHooks)\n      ? {}\n      : { shouldExportMutatorHooks: queryOptions.shouldExportMutatorHooks }),\n    ...(isUndefined(globalOptions.shouldSplitQueryKey)\n      ? {}\n      : {\n          shouldSplitQueryKey: globalOptions.shouldSplitQueryKey,\n        }),\n    ...(isUndefined(queryOptions.shouldSplitQueryKey)\n      ? {}\n      : { shouldSplitQueryKey: queryOptions.shouldSplitQueryKey }),\n    ...(isUndefined(globalOptions.signal)\n      ? {}\n      : {\n          signal: globalOptions.signal,\n        }),\n    ...(isUndefined(globalOptions.useOperationIdAsQueryKey)\n      ? {}\n      : {\n          useOperationIdAsQueryKey: globalOptions.useOperationIdAsQueryKey,\n        }),\n    ...(isUndefined(queryOptions.useOperationIdAsQueryKey)\n      ? {}\n      : { useOperationIdAsQueryKey: queryOptions.useOperationIdAsQueryKey }),\n    ...(isUndefined(globalOptions.signal)\n      ? {}\n      : {\n          signal: globalOptions.signal,\n        }),\n    ...(isUndefined(queryOptions.signal)\n      ? {}\n      : { signal: queryOptions.signal }),\n    ...(isUndefined(globalOptions.version)\n      ? {}\n      : {\n          version: globalOptions.version,\n        }),\n    ...(isUndefined(queryOptions.version)\n      ? {}\n      : { version: queryOptions.version }),\n    ...(queryOptions.mutationInvalidates\n      ? { mutationInvalidates: queryOptions.mutationInvalidates }\n      : {}),\n  };\n}\n\nexport function getDefaultFilesHeader({\n  title,\n  description,\n  version,\n}: {\n  title?: string;\n  description?: string;\n  version?: string;\n} = {}) {\n  return [\n    `Generated by ${pkg.name} v${pkg.version} üç∫`,\n    `Do not edit manually.`,\n    ...(title ? [title] : []),\n    ...(description ? [description] : []),\n    ...(version ? [`OpenAPI spec version: ${version}`] : []),\n  ];\n}\n","import { log, logError } from '@orval/core';\n\n/**\n * Start a file watcher and invoke an async callback on file changes.\n *\n * If `watchOptions` is falsy the watcher is not started. Supported shapes:\n *  - boolean: when true the `defaultTarget` is watched\n *  - string: a single path to watch\n *  - string[]: an array of paths to watch\n *\n * @param watchOptions - false to disable watching, or a path/paths to watch\n * @param watchFn - async callback executed on change events\n * @param defaultTarget - path(s) to watch when `watchOptions` is `true` (default: '.')\n * @returns Resolves once the watcher has been started (or immediately if disabled)\n *\n * @example\n * await startWatcher(true, async () => { await buildProject(); }, 'src');\n */\nexport async function startWatcher(\n  watchOptions: boolean | string | string[],\n  watchFn: () => Promise<void>,\n  defaultTarget: string | string[] = '.',\n) {\n  if (!watchOptions) return;\n  const { watch } = await import('chokidar');\n\n  const ignored = ['**/{.git,node_modules}/**'];\n\n  const watchPaths =\n    typeof watchOptions === 'boolean' ? defaultTarget : watchOptions;\n\n  log(\n    `Watching for changes in ${\n      Array.isArray(watchPaths)\n        ? watchPaths.map((v) => '\"' + v + '\"').join(' | ')\n        : '\"' + watchPaths + '\"'\n    }`,\n  );\n\n  const watcher = watch(watchPaths, {\n    ignorePermissionErrors: true,\n    ignored,\n  });\n  watcher.on('all', (type, file) => {\n    log(`Change detected: ${type} ${file}`);\n\n    watchFn().catch((error: unknown) => {\n      logError(error);\n    });\n  });\n}\n","import {\n  type ContextSpec,\n  conventionName,\n  type GeneratorVerbOptions,\n  type NamingConvention,\n  type NormalizedOutputOptions,\n  type OpenApiSchemaObject,\n  pascal,\n  upath,\n  type WriteSpecBuilder,\n} from '@orval/core';\nimport {\n  dereference,\n  generateZodValidationSchemaDefinition,\n  isZodVersionV4,\n  parseZodValidationSchemaDefinition,\n} from '@orval/zod';\nimport fs from 'fs-extra';\n\nfunction generateZodSchemaFileContent(\n  header: string,\n  schemaName: string,\n  zodContent: string,\n): string {\n  return `${header}import { z as zod } from 'zod';\n\nexport const ${schemaName} = ${zodContent}\n\nexport type ${schemaName} = zod.infer<typeof ${schemaName}>;\n`;\n}\n\nasync function writeZodSchemaIndex(\n  schemasPath: string,\n  fileExtension: string,\n  header: string,\n  schemaNames: string[],\n  namingConvention: NamingConvention,\n  shouldMergeExisting = false,\n) {\n  const importFileExtension = fileExtension.replace(/\\.ts$/, '');\n  const indexPath = upath.join(schemasPath, `index${fileExtension}`);\n\n  let existingExports = '';\n  if (shouldMergeExisting && (await fs.pathExists(indexPath))) {\n    const existingContent = await fs.readFile(indexPath, 'utf8');\n    const headerMatch = /^(\\/\\*\\*[\\s\\S]*?\\*\\/\\n)?/.exec(existingContent);\n    const headerPart = headerMatch ? headerMatch[0] : '';\n    existingExports = existingContent.slice(headerPart.length).trim();\n  }\n\n  const newExports = schemaNames\n    .map((schemaName) => {\n      const fileName = conventionName(schemaName, namingConvention);\n      return `export * from './${fileName}${importFileExtension}';`;\n    })\n    .sort()\n    .join('\\n');\n\n  const allExports = existingExports\n    ? `${existingExports}\\n${newExports}`\n    : newExports;\n\n  const uniqueExports = [...new Set(allExports.split('\\n'))]\n    .filter((line) => line.trim())\n    .sort()\n    .join('\\n');\n\n  await fs.outputFile(indexPath, `${header}\\n${uniqueExports}\\n`);\n}\n\nexport async function writeZodSchemas(\n  builder: WriteSpecBuilder,\n  schemasPath: string,\n  fileExtension: string,\n  header: string,\n  output: NormalizedOutputOptions,\n) {\n  const schemasWithOpenApiDef = builder.schemas.filter((s) => s.schema);\n\n  await Promise.all(\n    schemasWithOpenApiDef.map(async (generatorSchema) => {\n      const { name, schema: schemaObject } = generatorSchema;\n\n      if (!schemaObject) {\n        return;\n      }\n\n      const fileName = conventionName(name, output.namingConvention);\n      const filePath = upath.join(schemasPath, `${fileName}${fileExtension}`);\n      const context: ContextSpec = {\n        spec: builder.spec,\n        target: builder.target,\n        workspace: '',\n        output,\n      };\n\n      const isZodV4 =\n        !!output.packageJson && isZodVersionV4(output.packageJson);\n      const strict =\n        typeof output.override?.zod?.strict === 'object'\n          ? (output.override.zod.strict.body ?? false)\n          : (output.override?.zod?.strict ?? false);\n      const coerce =\n        typeof output.override?.zod?.coerce === 'object'\n          ? (output.override.zod.coerce.body ?? false)\n          : (output.override?.zod?.coerce ?? false);\n\n      // Dereference the schema to resolve $ref\n      const dereferencedSchema = dereference(schemaObject, context);\n\n      const zodDefinition = generateZodValidationSchemaDefinition(\n        dereferencedSchema,\n        context,\n        name,\n        strict,\n        isZodV4,\n        {\n          required: true,\n        },\n      );\n\n      const parsedZodDefinition = parseZodValidationSchemaDefinition(\n        zodDefinition,\n        context,\n        coerce,\n        strict,\n        isZodV4,\n      );\n\n      const zodContent = parsedZodDefinition.consts\n        ? `${parsedZodDefinition.consts}\\n${parsedZodDefinition.zod}`\n        : parsedZodDefinition.zod;\n\n      const fileContent = generateZodSchemaFileContent(\n        header,\n        name,\n        zodContent,\n      );\n\n      await fs.outputFile(filePath, fileContent);\n    }),\n  );\n\n  if (output.indexFiles) {\n    const schemaNames = schemasWithOpenApiDef.map((schema) => schema.name);\n    await writeZodSchemaIndex(\n      schemasPath,\n      fileExtension,\n      header,\n      schemaNames,\n      output.namingConvention,\n      false,\n    );\n  }\n}\n\nexport async function writeZodSchemasFromVerbs(\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  schemasPath: string,\n  fileExtension: string,\n  header: string,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) {\n  const verbOptionsArray = Object.values(verbOptions);\n\n  if (verbOptionsArray.length === 0) {\n    return;\n  }\n\n  const isZodV4 = !!output.packageJson && isZodVersionV4(output.packageJson);\n  const strict =\n    typeof output.override?.zod?.strict === 'object'\n      ? (output.override.zod.strict.body ?? false)\n      : (output.override?.zod?.strict ?? false);\n  const coerce =\n    typeof output.override?.zod?.coerce === 'object'\n      ? (output.override.zod.coerce.body ?? false)\n      : (output.override?.zod?.coerce ?? false);\n\n  const generateVerbsSchemas = verbOptionsArray.flatMap((verbOption) => {\n    const operation = verbOption.originalOperation;\n\n    const bodySchema =\n      operation.requestBody && 'content' in operation.requestBody\n        ? operation.requestBody.content['application/json']?.schema\n        : undefined;\n\n    const bodySchemas = bodySchema\n      ? [\n          {\n            name: `${pascal(verbOption.operationName)}Body`,\n            schema: dereference(bodySchema as OpenApiSchemaObject, context),\n          },\n        ]\n      : [];\n\n    const queryParams = operation.parameters?.filter(\n      (p) => 'in' in p && p.in === 'query',\n    );\n\n    const queryParamsSchemas =\n      queryParams && queryParams.length > 0\n        ? [\n            {\n              name: `${pascal(verbOption.operationName)}Params`,\n              schema: {\n                type: 'object' as const,\n                properties: Object.fromEntries(\n                  queryParams\n                    .filter((p) => 'schema' in p && p.schema)\n                    .map((p) => [\n                      p.name,\n                      dereference(p.schema as OpenApiSchemaObject, context),\n                    ]),\n                ),\n                required: queryParams\n                  .filter((p) => p.required)\n                  .map((p) => p.name),\n              },\n            },\n          ]\n        : [];\n\n    const headerParams = operation.parameters?.filter(\n      (p) => 'in' in p && p.in === 'header',\n    );\n\n    const headerParamsSchemas =\n      headerParams && headerParams.length > 0\n        ? [\n            {\n              name: `${pascal(verbOption.operationName)}Headers`,\n              schema: {\n                type: 'object' as const,\n                properties: Object.fromEntries(\n                  headerParams\n                    .filter((p) => 'schema' in p && p.schema)\n                    .map((p) => [\n                      p.name,\n                      dereference(p.schema as OpenApiSchemaObject, context),\n                    ]),\n                ),\n                required: headerParams\n                  .filter((p) => p.required)\n                  .map((p) => p.name),\n              },\n            },\n          ]\n        : [];\n\n    return [...bodySchemas, ...queryParamsSchemas, ...headerParamsSchemas];\n  });\n\n  await Promise.all(\n    generateVerbsSchemas.map(async ({ name, schema }) => {\n      const fileName = conventionName(name, output.namingConvention);\n      const filePath = upath.join(schemasPath, `${fileName}${fileExtension}`);\n\n      const zodDefinition = generateZodValidationSchemaDefinition(\n        schema,\n        context,\n        name,\n        strict,\n        isZodV4,\n        {\n          required: true,\n        },\n      );\n\n      const parsedZodDefinition = parseZodValidationSchemaDefinition(\n        zodDefinition,\n        context,\n        coerce,\n        strict,\n        isZodV4,\n      );\n\n      const zodContent = parsedZodDefinition.consts\n        ? `${parsedZodDefinition.consts}\\n${parsedZodDefinition.zod}`\n        : parsedZodDefinition.zod;\n\n      const fileContent = generateZodSchemaFileContent(\n        header,\n        name,\n        zodContent,\n      );\n\n      await fs.outputFile(filePath, fileContent);\n    }),\n  );\n\n  if (output.indexFiles && generateVerbsSchemas.length > 0) {\n    const schemaNames = generateVerbsSchemas.map((s) => s.name);\n    await writeZodSchemaIndex(\n      schemasPath,\n      fileExtension,\n      header,\n      schemaNames,\n      output.namingConvention,\n      true,\n    );\n  }\n}\n","import {\n  createSuccessMessage,\n  fixCrossDirectoryImports,\n  fixRegularSchemaImports,\n  getFileInfo,\n  getMockFileExtensionByTypeName,\n  isString,\n  jsDoc,\n  log,\n  type NormalizedOptions,\n  type OpenApiInfoObject,\n  OutputMode,\n  splitSchemasByType,\n  upath,\n  writeSchemas,\n  writeSingleMode,\n  type WriteSpecBuilder,\n  writeSplitMode,\n  writeSplitTagsMode,\n  writeTagsMode,\n} from '@orval/core';\nimport chalk from 'chalk';\nimport { execa, ExecaError } from 'execa';\nimport fs from 'fs-extra';\nimport { unique } from 'remeda';\nimport type { TypeDocOptions } from 'typedoc';\n\nimport { executeHook } from './utils';\nimport { writeZodSchemas, writeZodSchemasFromVerbs } from './write-zod-specs';\n\nfunction getHeader(\n  option: false | ((info: OpenApiInfoObject) => string | string[]),\n  info: OpenApiInfoObject,\n): string {\n  if (!option) {\n    return '';\n  }\n\n  const header = option(info);\n  return Array.isArray(header) ? jsDoc({ description: header }) : header;\n}\n\n/**\n * Add re-export of operation schemas from the main schemas index file.\n * Handles the case where the index file doesn't exist (no regular schemas).\n */\nasync function addOperationSchemasReExport(\n  schemaPath: string,\n  operationSchemasPath: string,\n  fileExtension: string,\n  header: string,\n): Promise<void> {\n  const relativePath = upath.relativeSafe(schemaPath, operationSchemasPath);\n  const schemaIndexPath = upath.join(schemaPath, `index${fileExtension}`);\n  const exportLine = `export * from '${relativePath}';\\n`;\n\n  const indexExists = await fs.pathExists(schemaIndexPath);\n  if (!indexExists) {\n    // Create index with header if file doesn't exist (no regular schemas case)\n    const content =\n      header && header.trim().length > 0\n        ? `${header}\\n${exportLine}`\n        : exportLine;\n    await fs.outputFile(schemaIndexPath, content);\n  } else {\n    // Check if export already exists to prevent duplicates on re-runs\n    // Use regex to handle both single and double quotes\n    const existingContent = await fs.readFile(schemaIndexPath, 'utf8');\n    const exportPattern = new RegExp(\n      `export\\\\s*\\\\*\\\\s*from\\\\s*['\"]${relativePath.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}['\"]`,\n    );\n    if (!exportPattern.test(existingContent)) {\n      await fs.appendFile(schemaIndexPath, exportLine);\n    }\n  }\n}\n\nexport async function writeSpecs(\n  builder: WriteSpecBuilder,\n  workspace: string,\n  options: NormalizedOptions,\n  projectName?: string,\n) {\n  const { info, schemas, target } = builder;\n  const { output } = options;\n  const projectTitle = projectName ?? info.title;\n\n  const header = getHeader(output.override.header, info);\n\n  if (output.schemas) {\n    if (isString(output.schemas)) {\n      const fileExtension = output.fileExtension || '.ts';\n      const schemaPath = output.schemas;\n\n      // Split schemas if operationSchemas path is configured\n      if (output.operationSchemas) {\n        const { regularSchemas, operationSchemas: opSchemas } =\n          splitSchemasByType(schemas);\n\n        // Fix cross-directory imports before writing (both directions)\n        const regularSchemaNames = new Set(regularSchemas.map((s) => s.name));\n        const operationSchemaNames = new Set(opSchemas.map((s) => s.name));\n        fixCrossDirectoryImports(\n          opSchemas,\n          regularSchemaNames,\n          schemaPath,\n          output.operationSchemas,\n          output.namingConvention,\n        );\n        fixRegularSchemaImports(\n          regularSchemas,\n          operationSchemaNames,\n          schemaPath,\n          output.operationSchemas,\n          output.namingConvention,\n        );\n\n        // Write regular schemas to schemas path\n        if (regularSchemas.length > 0) {\n          await writeSchemas({\n            schemaPath,\n            schemas: regularSchemas,\n            target,\n            namingConvention: output.namingConvention,\n            fileExtension,\n            header,\n            indexFiles: output.indexFiles,\n          });\n        }\n\n        // Write operation schemas to operationSchemas path\n        if (opSchemas.length > 0) {\n          await writeSchemas({\n            schemaPath: output.operationSchemas,\n            schemas: opSchemas,\n            target,\n            namingConvention: output.namingConvention,\n            fileExtension,\n            header,\n            indexFiles: output.indexFiles,\n          });\n\n          // Add re-export from operations in the main schemas index\n          if (output.indexFiles) {\n            await addOperationSchemasReExport(\n              schemaPath,\n              output.operationSchemas,\n              fileExtension,\n              header,\n            );\n          }\n        }\n      } else {\n        await writeSchemas({\n          schemaPath,\n          schemas,\n          target,\n          namingConvention: output.namingConvention,\n          fileExtension,\n          header,\n          indexFiles: output.indexFiles,\n        });\n      }\n    } else {\n      const schemaType = output.schemas.type;\n\n      if (schemaType === 'typescript') {\n        const fileExtension = output.fileExtension || '.ts';\n\n        // Split schemas if operationSchemas path is configured\n        if (output.operationSchemas) {\n          const { regularSchemas, operationSchemas: opSchemas } =\n            splitSchemasByType(schemas);\n\n          // Fix cross-directory imports before writing (both directions)\n          const regularSchemaNames = new Set(regularSchemas.map((s) => s.name));\n          const operationSchemaNames = new Set(opSchemas.map((s) => s.name));\n          fixCrossDirectoryImports(\n            opSchemas,\n            regularSchemaNames,\n            output.schemas.path,\n            output.operationSchemas,\n            output.namingConvention,\n          );\n          fixRegularSchemaImports(\n            regularSchemas,\n            operationSchemaNames,\n            output.schemas.path,\n            output.operationSchemas,\n            output.namingConvention,\n          );\n\n          if (regularSchemas.length > 0) {\n            await writeSchemas({\n              schemaPath: output.schemas.path,\n              schemas: regularSchemas,\n              target,\n              namingConvention: output.namingConvention,\n              fileExtension,\n              header,\n              indexFiles: output.indexFiles,\n            });\n          }\n\n          if (opSchemas.length > 0) {\n            await writeSchemas({\n              schemaPath: output.operationSchemas,\n              schemas: opSchemas,\n              target,\n              namingConvention: output.namingConvention,\n              fileExtension,\n              header,\n              indexFiles: output.indexFiles,\n            });\n\n            // Add re-export from operations in the main schemas index\n            if (output.indexFiles) {\n              await addOperationSchemasReExport(\n                output.schemas.path,\n                output.operationSchemas,\n                fileExtension,\n                header,\n              );\n            }\n          }\n        } else {\n          await writeSchemas({\n            schemaPath: output.schemas.path,\n            schemas,\n            target,\n            namingConvention: output.namingConvention,\n            fileExtension,\n            header,\n            indexFiles: output.indexFiles,\n          });\n        }\n      } else if (schemaType === 'zod') {\n        const fileExtension = '.zod.ts';\n\n        await writeZodSchemas(\n          builder,\n          output.schemas.path,\n          fileExtension,\n          header,\n          output,\n        );\n\n        if (builder.verbOptions) {\n          await writeZodSchemasFromVerbs(\n            builder.verbOptions,\n            output.schemas.path,\n            fileExtension,\n            header,\n            output,\n            {\n              spec: builder.spec,\n              target: builder.target,\n              workspace,\n              output,\n            },\n          );\n        }\n      }\n    }\n  }\n\n  let implementationPaths: string[] = [];\n\n  if (output.target) {\n    const writeMode = getWriteMode(output.mode);\n    implementationPaths = await writeMode({\n      builder,\n      workspace,\n      output,\n      projectName,\n      header,\n      needSchema: !output.schemas && output.client !== 'zod',\n    });\n  }\n\n  if (output.workspace) {\n    const workspacePath = output.workspace;\n    const imports = implementationPaths\n      .filter(\n        (path) =>\n          !output.mock ||\n          !path.endsWith(`.${getMockFileExtensionByTypeName(output.mock)}.ts`),\n      )\n      .map((path) =>\n        upath.relativeSafe(\n          workspacePath,\n          getFileInfo(path).pathWithoutExtension,\n        ),\n      );\n\n    if (output.schemas) {\n      const schemasPath =\n        typeof output.schemas === 'string'\n          ? output.schemas\n          : output.schemas.path;\n      imports.push(\n        upath.relativeSafe(workspacePath, getFileInfo(schemasPath).dirname),\n      );\n    }\n\n    if (output.operationSchemas) {\n      imports.push(\n        upath.relativeSafe(\n          workspacePath,\n          getFileInfo(output.operationSchemas).dirname,\n        ),\n      );\n    }\n\n    if (output.indexFiles) {\n      const indexFile = upath.join(workspacePath, '/index.ts');\n\n      if (await fs.pathExists(indexFile)) {\n        const data = await fs.readFile(indexFile, 'utf8');\n        const importsNotDeclared = imports.filter((imp) => !data.includes(imp));\n        await fs.appendFile(\n          indexFile,\n          unique(importsNotDeclared)\n            .map((imp) => `export * from '${imp}';\\n`)\n            .join(''),\n        );\n      } else {\n        await fs.outputFile(\n          indexFile,\n          unique(imports)\n            .map((imp) => `export * from '${imp}';`)\n            .join('\\n') + '\\n',\n        );\n      }\n\n      implementationPaths = [indexFile, ...implementationPaths];\n    }\n  }\n\n  if (builder.extraFiles.length > 0) {\n    await Promise.all(\n      builder.extraFiles.map(async (file) =>\n        fs.outputFile(file.path, file.content),\n      ),\n    );\n\n    implementationPaths = [\n      ...implementationPaths,\n      ...builder.extraFiles.map((file) => file.path),\n    ];\n  }\n\n  const paths = [\n    ...(output.schemas\n      ? [\n          getFileInfo(\n            typeof output.schemas === 'string'\n              ? output.schemas\n              : output.schemas.path,\n          ).dirname,\n        ]\n      : []),\n    ...(output.operationSchemas\n      ? [getFileInfo(output.operationSchemas).dirname]\n      : []),\n    ...implementationPaths,\n  ];\n\n  if (options.hooks.afterAllFilesWrite) {\n    await executeHook(\n      'afterAllFilesWrite',\n      options.hooks.afterAllFilesWrite,\n      paths,\n    );\n  }\n\n  if (output.prettier) {\n    try {\n      await execa('prettier', ['--write', ...paths]);\n    } catch {\n      log(\n        chalk.yellow(\n          `‚ö†Ô∏è  ${projectTitle ? `${projectTitle} - ` : ''}Globally installed prettier not found`,\n        ),\n      );\n    }\n  }\n\n  if (output.biome) {\n    try {\n      await execa('biome', ['check', '--write', ...paths]);\n    } catch (error) {\n      let message = `‚ö†Ô∏è  ${projectTitle ? `${projectTitle} - ` : ''}biome not found`;\n      if (error instanceof ExecaError && error.exitCode === 1)\n        message = error.message;\n\n      log(chalk.yellow(message));\n    }\n  }\n\n  if (output.docs) {\n    try {\n      let config: Partial<TypeDocOptions> = {};\n      let configPath: string | null = null;\n      if (typeof output.docs === 'object') {\n        ({ configPath = null, ...config } = output.docs);\n        if (configPath) {\n          config.options = configPath;\n        }\n      }\n\n      const getTypedocApplication = async () => {\n        const { Application } = await import('typedoc');\n        return Application;\n      };\n\n      const Application = await getTypedocApplication();\n      const app = await Application.bootstrapWithPlugins({\n        entryPoints: paths,\n        theme: 'markdown',\n        // Set the custom config location if it has been provided.\n        ...config,\n        plugin: ['typedoc-plugin-markdown', ...(config.plugin ?? [])],\n      });\n      // Set defaults if the have not been provided by the external config.\n      if (!app.options.isSet('readme')) {\n        app.options.setValue('readme', 'none');\n      }\n      if (!app.options.isSet('logLevel')) {\n        app.options.setValue('logLevel', 'None');\n      }\n      const project = await app.convert();\n      if (project) {\n        await app.generateDocs(project, app.options.getValue('out') as string);\n      } else {\n        throw new Error('TypeDoc not initialized');\n      }\n    } catch (error) {\n      const message =\n        error instanceof Error\n          ? error.message\n          : `‚ö†Ô∏è  ${projectTitle ? `${projectTitle} - ` : ''}Unable to generate docs`;\n\n      log(chalk.yellow(message));\n    }\n  }\n\n  createSuccessMessage(projectTitle);\n}\n\nfunction getWriteMode(mode: OutputMode) {\n  switch (mode) {\n    case OutputMode.SPLIT: {\n      return writeSplitMode;\n    }\n    case OutputMode.TAGS: {\n      return writeTagsMode;\n    }\n    case OutputMode.TAGS_SPLIT: {\n      return writeSplitTagsMode;\n    }\n    case OutputMode.SINGLE:\n    default: {\n      return writeSingleMode;\n    }\n  }\n}\n","import {\n  getFileInfo,\n  log,\n  type NormalizedOptions,\n  removeFilesAndEmptyFolders,\n} from '@orval/core';\n\nimport { importSpecs } from './import-specs';\nimport { writeSpecs } from './write-specs';\n\n/**\n * Generate client/spec files for a single Orval project.\n *\n * @param workspace - Absolute or relative workspace path used to resolve imports.\n * @param options - Normalized generation options for this project.\n * @param projectName - Optional project name used in logging output.\n * @returns A promise that resolves once generation (and optional cleaning) completes.\n *\n * @example\n * await generateSpec(process.cwd(), normalizedOptions, 'my-project');\n */\nexport async function generateSpec(\n  workspace: string,\n  options: NormalizedOptions,\n  projectName?: string,\n) {\n  if (options.output.clean) {\n    const extraPatterns = Array.isArray(options.output.clean)\n      ? options.output.clean\n      : [];\n\n    if (options.output.target) {\n      await removeFilesAndEmptyFolders(\n        ['**/*', '!**/*.d.ts', ...extraPatterns],\n        getFileInfo(options.output.target).dirname,\n      );\n    }\n    if (options.output.schemas) {\n      await removeFilesAndEmptyFolders(\n        ['**/*', '!**/*.d.ts', ...extraPatterns],\n        getFileInfo(options.output.schemas).dirname,\n      );\n    }\n    log(`${projectName} Cleaning output folder`);\n  }\n\n  const writeSpecBuilder = await importSpecs(workspace, options, projectName);\n  await writeSpecs(writeSpecBuilder, workspace, options, projectName);\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport { type Config, type ConfigExternal, isFunction } from '@orval/core';\nimport { createJiti } from 'jiti';\n\n/**\n * Resolve the Orval config file path.\n *\n * @param configFilePath - Optional path to the config file (absolute or relative).\n * @returns The absolute path to the resolved config file.\n * @throws If a provided path does not exist or if no config file is found.\n *\n * @example\n * // explicit path\n * const p = findConfigFile('./orval.config.ts');\n *\n * @example\n * // automatic discovery (searches process.cwd())\n * const p = findConfigFile();\n */\nexport function findConfigFile(configFilePath?: string) {\n  if (configFilePath) {\n    const absolutePath = path.isAbsolute(configFilePath)\n      ? configFilePath\n      : path.resolve(process.cwd(), configFilePath);\n\n    if (!fs.existsSync(absolutePath))\n      throw new Error(`Config file ${configFilePath} does not exist`);\n\n    return absolutePath;\n  }\n\n  const root = process.cwd();\n  const exts = ['.ts', '.js', '.mjs', '.mts'];\n  for (const ext of exts) {\n    const fullPath = path.resolve(root, `orval.config${ext}`);\n    if (fs.existsSync(fullPath)) {\n      return fullPath;\n    }\n  }\n\n  throw new Error(`No config file found in ${root}`);\n}\n\n/**\n * Load an Orval config file\n * @param configFilePath - Path to the config file (absolute or relative).\n * @returns The resolved Orval `Config` object.\n * @throws If the module does not provide a default export or the default export resolves to `undefined`.\n *\n * @example\n * // load a config object\n * const cfg = await loadConfigFile('./orval.config.ts');\n */\nexport async function loadConfigFile(configFilePath: string): Promise<Config> {\n  const jiti = createJiti(process.cwd(), {\n    interopDefault: true,\n  });\n\n  const configExternal = await jiti.import<ConfigExternal | undefined>(\n    configFilePath,\n    {\n      default: true,\n    },\n  );\n\n  if (configExternal === undefined) {\n    throw new Error(`${configFilePath} doesn't have a default export`);\n  }\n\n  const config = await (isFunction(configExternal)\n    ? configExternal()\n    : configExternal);\n\n  return config;\n}\n"],"mappings":"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"}