{"version":3,"file":"index.mjs","names":["path","path","isFunction","isString","basepath","propName","path","pascalMemory: Record<string, string>","log","regex","filter","count","LogLevels: Record<LogLevel, number>","lastType: LogType | undefined","lastMsg: string | undefined","options","logger: Logger","isObject","path","prop","parts: string[]","valueImports: string[]","RefComponentSuffix: Record<RefComponent, string>","upath.getSchemaFileName","getSchema","formDataContext: FormDataContext | undefined","name","schema","additionalImports: GeneratorImport[]","imports","imports","schemas","name","entries","propertyFormDataContext: FormDataContext | undefined","constLiteral: string | undefined","aliasedImports: GeneratorImport[]","recordType","keyType","resolvedValue","separator","prop","resolvedData: CombinedData[]","propName: string | undefined","resolvedValue","resolvedValue: ScalarValue | undefined","path","paramGetterProps: GetterProps","imports","schemas","imports","schemas","contentType","path","generatorSchemas: GeneratorSchema[]","imports","schemas","name","alias","path","prop","upath.relativeSafe","fs","generatorSchemas: GeneratorSchema[]","filter","deduplicatedModels: GeneratorSchema[]","sorted: GeneratorSchema[]","imp","schema","verbOption: GeneratorVerbOptions","regularSchemas: GeneratorSchema[]","operationSchemas: GeneratorSchema[]","upath.relativeSafe","upath.joinSafe","upath\n    .join","path","upath.join","fs","upath.joinSafe","upath.relativeSafe","dirname","fs","path","upath.relativeSafe","dirname","upath.join","fs","tag","acc","upath.join","dirname","fs","target","upath.relativeSafe","tag","upath.joinSafe","target","upath.relativeSafe","dirname","tag","upath.join","fs"],"sources":["../src/types.ts","../src/constants.ts","../src/utils/extension.ts","../src/utils/file.ts","../src/utils/path.ts","../src/utils/assertion.ts","../src/utils/async-reduce.ts","../src/utils/case.ts","../src/utils/content-type.ts","../src/utils/compare-version.ts","../src/utils/debug.ts","../src/utils/doc.ts","../src/utils/dynamic-import.ts","../src/utils/file-extensions.ts","../src/utils/get-property-safe.ts","../src/utils/is-body-verb.ts","../src/utils/logger.ts","../src/utils/merge-deep.ts","../src/utils/occurrence.ts","../src/utils/sort.ts","../src/utils/string.ts","../src/utils/tsconfig.ts","../src/getters/enum.ts","../src/getters/ref.ts","../src/resolvers/ref.ts","../src/resolvers/value.ts","../src/resolvers/object.ts","../src/getters/array.ts","../src/getters/res-req-types.ts","../src/getters/body.ts","../src/getters/imports.ts","../src/getters/keys.ts","../src/getters/object.ts","../src/getters/scalar.ts","../src/getters/combine.ts","../src/getters/discriminators.ts","../src/getters/operation.ts","../src/getters/parameters.ts","../src/getters/params.ts","../src/getters/props.ts","../src/getters/query-params.ts","../src/getters/response.ts","../src/getters/route.ts","../src/generators/component-definition.ts","../src/generators/imports.ts","../src/generators/models-inline.ts","../src/generators/mutator-info.ts","../src/generators/mutator.ts","../src/generators/options.ts","../src/generators/parameter-definition.ts","../src/generators/interface.ts","../src/generators/schema-definition.ts","../src/generators/verbs-options.ts","../src/writers/schemas.ts","../src/writers/generate-imports-for-builder.ts","../src/writers/target.ts","../src/writers/types.ts","../src/writers/single-mode.ts","../src/writers/split-mode.ts","../src/writers/target-tags.ts","../src/writers/split-tags-mode.ts","../src/writers/tags-mode.ts"],"sourcesContent":["import type { allLocales } from '@faker-js/faker';\nimport type { OpenAPIV3_1 } from '@scalar/openapi-types';\nimport type { TypeDocOptions } from 'typedoc';\n\nexport interface Options {\n  output?: string | OutputOptions;\n  input?: string | InputOptions;\n  hooks?: Partial<HooksOptions>;\n}\n\nexport type OptionsFn = () => Options | Promise<Options>;\nexport type OptionsExport = Options | Promise<Options> | OptionsFn;\n\nexport type Config = Record<string, OptionsExport>;\nexport type ConfigFn = () => Config | Promise<Config>;\n\nexport type ConfigExternal = Config | Promise<Config> | ConfigFn;\n\nexport type NormalizedConfig = Record<string, NormalizedOptions | undefined>;\n\nexport interface NormalizedOptions {\n  output: NormalizedOutputOptions;\n  input: NormalizedInputOptions;\n  hooks: NormalizedHookOptions;\n}\n\nexport type NormalizedOutputOptions = {\n  workspace?: string;\n  target: string;\n  schemas?: string | SchemaOptions;\n  operationSchemas?: string;\n  namingConvention: NamingConvention;\n  fileExtension: string;\n  mode: OutputMode;\n  mock?: GlobalMockOptions | ClientMockBuilder;\n  override: NormalizedOverrideOutput;\n  client: OutputClient | OutputClientFunc;\n  httpClient: OutputHttpClient;\n  clean: boolean | string[];\n  docs: boolean | OutputDocsOptions;\n  prettier: boolean;\n  biome: boolean;\n  tsconfig?: Tsconfig;\n  packageJson?: PackageJson;\n  headers: boolean;\n  indexFiles: boolean;\n  baseUrl?: string | BaseUrlFromSpec | BaseUrlFromConstant;\n  allParamsOptional: boolean;\n  urlEncodeParameters: boolean;\n  unionAddMissingProperties: boolean;\n  optionsParamRequired: boolean;\n  propertySortOrder: PropertySortOrder;\n};\n\nexport type NormalizedParamsSerializerOptions = {\n  qs?: Record<string, any>;\n};\n\nexport type NormalizedOverrideOutput = {\n  title?: (title: string) => string;\n  transformer?: OutputTransformer;\n  mutator?: NormalizedMutator;\n  operations: Record<string, NormalizedOperationOptions | undefined>;\n  tags: Record<string, NormalizedOperationOptions | undefined>;\n  mock?: OverrideMockOptions;\n  contentType?: OverrideOutputContentType;\n  header: false | ((info: OpenApiInfoObject) => string[] | string);\n  formData: NormalizedFormDataType<NormalizedMutator>;\n  formUrlEncoded: boolean | NormalizedMutator;\n  paramsSerializer?: NormalizedMutator;\n  paramsSerializerOptions?: NormalizedParamsSerializerOptions;\n  namingConvention: {\n    enum?: NamingConvention;\n  };\n  components: {\n    schemas: {\n      suffix: string;\n      itemSuffix: string;\n    };\n    responses: {\n      suffix: string;\n    };\n    parameters: {\n      suffix: string;\n    };\n    requestBodies: {\n      suffix: string;\n    };\n  };\n  hono: NormalizedHonoOptions;\n  query: NormalizedQueryOptions;\n  angular: Required<AngularOptions>;\n  swr: SwrOptions;\n  zod: NormalizedZodOptions;\n  fetch: NormalizedFetchOptions;\n  operationName?: (\n    operation: OpenApiOperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  requestOptions: Record<string, any> | boolean;\n  useDates?: boolean;\n  useTypeOverInterfaces?: boolean;\n  useDeprecatedOperations?: boolean;\n  useBigInt?: boolean;\n  useNamedParameters?: boolean;\n  enumGenerationType: EnumGeneration;\n  suppressReadonlyModifier?: boolean;\n  jsDoc: NormalizedJsDocOptions;\n  aliasCombinedTypes: boolean;\n  /**\n   * When enabled, optional properties will be typed as `T | null` instead of just `T`.\n   * @default false\n   */\n  useNullForOptional?: boolean;\n};\n\nexport type NormalizedMutator = {\n  path: string;\n  name?: string;\n  default: boolean;\n  alias?: Record<string, string>;\n  external?: string[];\n  extension?: string;\n};\n\nexport type NormalizedOperationOptions = {\n  transformer?: OutputTransformer;\n  mutator?: NormalizedMutator;\n  mock?: {\n    data?: MockData;\n    properties?: MockProperties;\n  };\n  contentType?: OverrideOutputContentType;\n  query?: NormalizedQueryOptions;\n  angular?: Required<AngularOptions>;\n  swr?: SwrOptions;\n  zod?: NormalizedZodOptions;\n  operationName?: (\n    operation: OpenApiOperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  fetch?: FetchOptions;\n  formData?: NormalizedFormDataType<NormalizedMutator>;\n  formUrlEncoded?: boolean | NormalizedMutator;\n  paramsSerializer?: NormalizedMutator;\n  requestOptions?: object | boolean;\n};\n\nexport type NormalizedInputOptions = {\n  target: string | OpenApiDocument;\n  override: OverrideInput;\n  filters?: InputFiltersOptions;\n  parserOptions?: {\n    headers?: {\n      domains: string[];\n      headers: Record<string, string>;\n    }[];\n  };\n};\n\nexport type OutputClientFunc = (\n  clients: GeneratorClients,\n) => ClientGeneratorsBuilder;\n\nexport type BaseUrlFromSpec = {\n  getBaseUrlFromSpecification: true;\n  variables?: Record<string, string>;\n  index?: number;\n  baseUrl?: never;\n};\n\nexport type BaseUrlFromConstant = {\n  getBaseUrlFromSpecification: false;\n  variables?: never;\n  index?: never;\n  baseUrl: string;\n};\n\nexport const PropertySortOrder = {\n  ALPHABETICAL: 'Alphabetical',\n  SPECIFICATION: 'Specification',\n} as const;\n\nexport type PropertySortOrder =\n  (typeof PropertySortOrder)[keyof typeof PropertySortOrder];\n\nexport const NamingConvention = {\n  CAMEL_CASE: 'camelCase',\n  PASCAL_CASE: 'PascalCase',\n  SNAKE_CASE: 'snake_case',\n  KEBAB_CASE: 'kebab-case',\n} as const;\n\nexport type NamingConvention =\n  (typeof NamingConvention)[keyof typeof NamingConvention];\n\nexport const EnumGeneration = {\n  CONST: 'const',\n  ENUM: 'enum',\n  UNION: 'union',\n} as const;\n\nexport type EnumGeneration =\n  (typeof EnumGeneration)[keyof typeof EnumGeneration];\n\nexport type SchemaGenerationType = 'typescript' | 'zod';\n\nexport type SchemaOptions = {\n  path: string;\n  type: SchemaGenerationType;\n};\n\nexport type NormalizedSchemaOptions = {\n  path: string;\n  type: SchemaGenerationType;\n};\n\nexport type OutputOptions = {\n  workspace?: string;\n  target: string;\n  schemas?: string | SchemaOptions;\n  /**\n   * Separate path for operation-derived types (params, bodies, responses).\n   * When set, types matching operation patterns (e.g., *Params, *Body) are written here\n   * while regular schema types remain in the `schemas` path.\n   */\n  operationSchemas?: string;\n  namingConvention?: NamingConvention;\n  fileExtension?: string;\n  mode?: OutputMode;\n  // If mock is a boolean, it will use the default mock options (type: msw)\n  mock?: boolean | GlobalMockOptions | ClientMockBuilder;\n  override?: OverrideOutput;\n  client?: OutputClient | OutputClientFunc;\n  httpClient?: OutputHttpClient;\n  clean?: boolean | string[];\n  docs?: boolean | OutputDocsOptions;\n  prettier?: boolean;\n  biome?: boolean;\n  tsconfig?: string | Tsconfig;\n  packageJson?: string;\n  headers?: boolean;\n  indexFiles?: boolean;\n  baseUrl?: string | BaseUrlFromSpec | BaseUrlFromConstant;\n  allParamsOptional?: boolean;\n  urlEncodeParameters?: boolean;\n  unionAddMissingProperties?: boolean;\n  optionsParamRequired?: boolean;\n  propertySortOrder?: PropertySortOrder;\n};\n\nexport type InputFiltersOptions = {\n  mode?: 'include' | 'exclude';\n  tags?: (string | RegExp)[];\n  schemas?: (string | RegExp)[];\n};\n\nexport type InputOptions = {\n  target: string | Record<string, unknown> | OpenApiDocument;\n  override?: OverrideInput;\n  filters?: InputFiltersOptions;\n  parserOptions?: {\n    headers?: {\n      domains: string[];\n      headers: Record<string, string>;\n    }[];\n  };\n};\n\nexport const OutputClient = {\n  ANGULAR: 'angular',\n  ANGULAR_QUERY: 'angular-query',\n  AXIOS: 'axios',\n  AXIOS_FUNCTIONS: 'axios-functions',\n  REACT_QUERY: 'react-query',\n  SOLID_START: 'solid-start',\n  SOLID_QUERY: 'solid-query',\n  SVELTE_QUERY: 'svelte-query',\n  VUE_QUERY: 'vue-query',\n  SWR: 'swr',\n  ZOD: 'zod',\n  HONO: 'hono',\n  FETCH: 'fetch',\n  MCP: 'mcp',\n} as const;\n\nexport type OutputClient = (typeof OutputClient)[keyof typeof OutputClient];\n\nexport const OutputHttpClient = {\n  AXIOS: 'axios',\n  FETCH: 'fetch',\n  ANGULAR: 'angular',\n} as const;\n\nexport type OutputHttpClient =\n  (typeof OutputHttpClient)[keyof typeof OutputHttpClient];\n\nexport const OutputMode = {\n  SINGLE: 'single',\n  SPLIT: 'split',\n  TAGS: 'tags',\n  TAGS_SPLIT: 'tags-split',\n} as const;\n\nexport type OutputMode = (typeof OutputMode)[keyof typeof OutputMode];\n\nexport type OutputDocsOptions = {\n  configPath?: string;\n} & Partial<TypeDocOptions>;\n\n// TODO: add support for other mock types (like cypress or playwright)\nexport const OutputMockType = {\n  MSW: 'msw',\n} as const;\n\nexport type OutputMockType =\n  (typeof OutputMockType)[keyof typeof OutputMockType];\n\nexport type GlobalMockOptions = {\n  // This is the type of the mock that will be generated\n  type: OutputMockType;\n  // This is the option to use the examples from the openapi specification where possible to generate mock data\n  useExamples?: boolean;\n  // This is used to generate mocks for all http responses defined in the OpenAPI specification\n  generateEachHttpStatus?: boolean;\n  // This is used to set the delay to your own custom value, or pass false to disable delay\n  delay?: false | number | (() => number);\n  // This is used to execute functions that are passed to the 'delay' argument\n  // at runtime rather than build time.\n  delayFunctionLazyExecute?: boolean;\n  // This is used to set the base url to your own custom value\n  baseUrl?: string;\n  // This is used to set the locale of the faker library\n  locale?: keyof typeof allLocales;\n  indexMockFiles?: boolean;\n};\n\nexport type OverrideMockOptions = Partial<GlobalMockOptions> & {\n  arrayMin?: number;\n  arrayMax?: number;\n  stringMin?: number;\n  stringMax?: number;\n  numberMin?: number;\n  numberMax?: number;\n  required?: boolean;\n  properties?: MockProperties;\n  format?: Record<string, unknown>;\n  fractionDigits?: number;\n};\n\nexport type MockOptions = Omit<OverrideMockOptions, 'properties'> & {\n  properties?: Record<string, unknown>;\n  operations?: Record<string, { properties: Record<string, unknown> }>;\n  tags?: Record<string, { properties: Record<string, unknown> }>;\n};\n\nexport type MockPropertiesObject = Record<string, unknown>;\nexport type MockPropertiesObjectFn = (\n  specs: OpenApiDocument,\n) => MockPropertiesObject;\n\nexport type MockProperties = MockPropertiesObject | MockPropertiesObjectFn;\n\nexport type MockDataObject = Record<string, unknown>;\n\nexport type MockDataObjectFn = (specs: OpenApiDocument) => MockDataObject;\n\nexport type MockDataArray = unknown[];\n\nexport type MockDataArrayFn = (specs: OpenApiDocument) => MockDataArray;\n\nexport type MockData =\n  | MockDataObject\n  | MockDataObjectFn\n  | MockDataArray\n  | MockDataArrayFn;\n\ntype OutputTransformerFn = (verb: GeneratorVerbOptions) => GeneratorVerbOptions;\n\ntype OutputTransformer = string | OutputTransformerFn;\n\nexport type MutatorObject = {\n  path: string;\n  name?: string;\n  default?: boolean;\n  alias?: Record<string, string>;\n  external?: string[];\n  extension?: string;\n};\n\nexport type Mutator = string | MutatorObject;\n\nexport type ParamsSerializerOptions = {\n  qs?: Record<string, any>;\n};\n\nexport const FormDataArrayHandling = {\n  SERIALIZE: 'serialize',\n  EXPLODE: 'explode',\n  SERIALIZE_WITH_BRACKETS: 'serialize-with-brackets',\n} as const;\n\nexport type FormDataArrayHandling =\n  (typeof FormDataArrayHandling)[keyof typeof FormDataArrayHandling];\n\nexport type NormalizedFormDataType<TMutator> =\n  | {\n      disabled: true;\n      mutator?: never;\n      arrayHandling: FormDataArrayHandling;\n    }\n  | {\n      disabled: false;\n      mutator?: TMutator;\n      arrayHandling: FormDataArrayHandling;\n    };\nexport type FormDataType<TMutator> =\n  | {\n      mutator: TMutator;\n      arrayHandling?: FormDataArrayHandling;\n    }\n  | {\n      mutator?: TMutator;\n      arrayHandling: FormDataArrayHandling;\n    };\n\nexport type OverrideOutput = {\n  title?: (title: string) => string;\n  transformer?: OutputTransformer;\n  mutator?: Mutator;\n  operations?: Record<string, OperationOptions>;\n  tags?: Record<string, OperationOptions>;\n  mock?: OverrideMockOptions;\n  contentType?: OverrideOutputContentType;\n  header?: boolean | ((info: OpenApiInfoObject) => string[] | string);\n  formData?: boolean | Mutator | FormDataType<Mutator>;\n  formUrlEncoded?: boolean | Mutator;\n  paramsSerializer?: Mutator;\n  paramsSerializerOptions?: ParamsSerializerOptions;\n  namingConvention?: {\n    enum?: NamingConvention;\n  };\n  components?: {\n    schemas?: {\n      suffix?: string;\n      itemSuffix?: string;\n    };\n    responses?: {\n      suffix?: string;\n    };\n    parameters?: {\n      suffix?: string;\n    };\n    requestBodies?: {\n      suffix?: string;\n    };\n  };\n  hono?: HonoOptions;\n  query?: QueryOptions;\n  swr?: SwrOptions;\n  angular?: AngularOptions;\n  zod?: ZodOptions;\n  operationName?: (\n    operation: OpenApiOperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  fetch?: FetchOptions;\n  requestOptions?: Record<string, any> | boolean;\n  useDates?: boolean;\n  useTypeOverInterfaces?: boolean;\n  useDeprecatedOperations?: boolean;\n  useBigInt?: boolean;\n  useNamedParameters?: boolean;\n  enumGenerationType?: EnumGeneration;\n  suppressReadonlyModifier?: boolean;\n  jsDoc?: JsDocOptions;\n  aliasCombinedTypes?: boolean;\n  /**\n   * When enabled, optional properties will be typed as `T | null` instead of just `T`.\n   * @default false\n   */\n  useNullForOptional?: boolean;\n};\n\nexport type JsDocOptions = {\n  filter?: (schema: Record<string, any>) => { key: string; value: string }[];\n};\n\nexport type NormalizedJsDocOptions = {\n  filter?: (schema: Record<string, any>) => { key: string; value: string }[];\n};\n\nexport type OverrideOutputContentType = {\n  include?: string[];\n  exclude?: string[];\n};\n\nexport type NormalizedHonoOptions = {\n  handlers?: string;\n  compositeRoute: string;\n  validator: boolean | 'hono';\n  validatorOutputPath: string;\n};\n\nexport type ZodDateTimeOptions = {\n  offset?: boolean;\n  local?: boolean;\n  precision?: number;\n};\n\nexport type ZodTimeOptions = {\n  precision?: -1 | 0 | 1 | 2 | 3;\n};\n\nexport type ZodOptions = {\n  strict?: {\n    param?: boolean;\n    query?: boolean;\n    header?: boolean;\n    body?: boolean;\n    response?: boolean;\n  };\n  generate?: {\n    param?: boolean;\n    query?: boolean;\n    header?: boolean;\n    body?: boolean;\n    response?: boolean;\n  };\n  coerce?: {\n    param?: boolean | ZodCoerceType[];\n    query?: boolean | ZodCoerceType[];\n    header?: boolean | ZodCoerceType[];\n    body?: boolean | ZodCoerceType[];\n    response?: boolean | ZodCoerceType[];\n  };\n  preprocess?: {\n    param?: Mutator;\n    query?: Mutator;\n    header?: Mutator;\n    body?: Mutator;\n    response?: Mutator;\n  };\n  dateTimeOptions?: ZodDateTimeOptions;\n  timeOptions?: ZodTimeOptions;\n  generateEachHttpStatus?: boolean;\n};\n\nexport type ZodCoerceType = 'string' | 'number' | 'boolean' | 'bigint' | 'date';\n\nexport type NormalizedZodOptions = {\n  strict: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n  generate: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n  coerce: {\n    param: boolean | ZodCoerceType[];\n    query: boolean | ZodCoerceType[];\n    header: boolean | ZodCoerceType[];\n    body: boolean | ZodCoerceType[];\n    response: boolean | ZodCoerceType[];\n  };\n  preprocess?: {\n    param?: NormalizedMutator;\n    query?: NormalizedMutator;\n    header?: NormalizedMutator;\n    body?: NormalizedMutator;\n    response?: NormalizedMutator;\n  };\n  generateEachHttpStatus: boolean;\n  dateTimeOptions: ZodDateTimeOptions;\n  timeOptions: ZodTimeOptions;\n};\n\nexport type InvalidateTarget =\n  | string\n  | {\n      query: string;\n      params: string[] | Record<string, string>;\n    };\n\nexport type MutationInvalidatesRule = {\n  onMutations: string[];\n  invalidates: InvalidateTarget[];\n};\n\nexport type MutationInvalidatesConfig = MutationInvalidatesRule[];\n\nexport type HonoOptions = {\n  handlers?: string;\n  compositeRoute?: string;\n  validator?: boolean | 'hono';\n  validatorOutputPath?: string;\n};\n\nexport type NormalizedQueryOptions = {\n  useQuery?: boolean;\n  useSuspenseQuery?: boolean;\n  useMutation?: boolean;\n  useInfinite?: boolean;\n  useSuspenseInfiniteQuery?: boolean;\n  useInfiniteQueryParam?: string;\n  usePrefetch?: boolean;\n  useInvalidate?: boolean;\n  options?: any;\n  queryKey?: NormalizedMutator;\n  queryOptions?: NormalizedMutator;\n  mutationOptions?: NormalizedMutator;\n  shouldExportMutatorHooks?: boolean;\n  shouldExportHttpClient?: boolean;\n  shouldExportQueryKey?: boolean;\n  shouldSplitQueryKey?: boolean;\n  useOperationIdAsQueryKey?: boolean;\n  signal?: boolean;\n  version?: 3 | 4 | 5;\n  mutationInvalidates?: MutationInvalidatesConfig;\n};\n\nexport type QueryOptions = {\n  useQuery?: boolean;\n  useSuspenseQuery?: boolean;\n  useMutation?: boolean;\n  useInfinite?: boolean;\n  useSuspenseInfiniteQuery?: boolean;\n  useInfiniteQueryParam?: string;\n  usePrefetch?: boolean;\n  useInvalidate?: boolean;\n  options?: any;\n  queryKey?: Mutator;\n  queryOptions?: Mutator;\n  mutationOptions?: Mutator;\n  shouldExportMutatorHooks?: boolean;\n  shouldExportHttpClient?: boolean;\n  shouldExportQueryKey?: boolean;\n  shouldSplitQueryKey?: boolean;\n  useOperationIdAsQueryKey?: boolean;\n  signal?: boolean;\n  version?: 3 | 4 | 5;\n  mutationInvalidates?: MutationInvalidatesConfig;\n};\n\nexport type AngularOptions = {\n  provideIn?: 'root' | 'any' | boolean;\n};\n\nexport type SwrOptions = {\n  useInfinite?: boolean;\n  useSWRMutationForGet?: boolean;\n  useSuspense?: boolean;\n  generateErrorTypes?: boolean;\n  swrOptions?: unknown;\n  swrMutationOptions?: unknown;\n  swrInfiniteOptions?: unknown;\n};\n\nexport type NormalizedFetchOptions = {\n  includeHttpResponseReturnType: boolean;\n  forceSuccessResponse: boolean;\n  jsonReviver?: Mutator;\n  runtimeValidation: boolean;\n};\n\nexport type FetchOptions = {\n  includeHttpResponseReturnType?: boolean;\n  forceSuccessResponse?: boolean;\n  jsonReviver?: Mutator;\n  runtimeValidation?: boolean;\n};\n\nexport type InputTransformerFn = (spec: OpenApiDocument) => OpenApiDocument;\n\ntype InputTransformer = string | InputTransformerFn;\n\nexport type OverrideInput = {\n  transformer?: InputTransformer;\n};\n\nexport type OperationOptions = {\n  transformer?: OutputTransformer;\n  mutator?: Mutator;\n  mock?: {\n    data?: MockData;\n    properties?: MockProperties;\n  };\n  query?: QueryOptions;\n  angular?: Required<AngularOptions>;\n  swr?: SwrOptions;\n  zod?: ZodOptions;\n  operationName?: (\n    operation: OpenApiOperationObject,\n    route: string,\n    verb: Verbs,\n  ) => string;\n  fetch?: FetchOptions;\n  formData?: boolean | Mutator | FormDataType<Mutator>;\n  formUrlEncoded?: boolean | Mutator;\n  paramsSerializer?: Mutator;\n  requestOptions?: object | boolean;\n};\n\nexport type Hook = 'afterAllFilesWrite';\n\nexport type HookFunction = (...args: any[]) => void | Promise<void>;\n\nexport interface HookOption {\n  command: string | HookFunction;\n  injectGeneratedDirsAndFiles?: boolean;\n}\n\nexport type HookCommand =\n  | string\n  | HookFunction\n  | HookOption\n  | (string | HookFunction | HookOption)[];\n\nexport type NormalizedHookCommand = HookCommand[];\n\nexport type HooksOptions<T = HookCommand | NormalizedHookCommand> = Partial<\n  Record<Hook, T>\n>;\n\nexport type NormalizedHookOptions = HooksOptions<NormalizedHookCommand>;\n\nexport type Verbs = 'post' | 'put' | 'get' | 'patch' | 'delete' | 'head';\n\nexport const Verbs = {\n  POST: 'post' as Verbs,\n  PUT: 'put' as Verbs,\n  GET: 'get' as Verbs,\n  PATCH: 'patch' as Verbs,\n  DELETE: 'delete' as Verbs,\n  HEAD: 'head' as Verbs,\n};\n\nexport type ImportOpenApi = {\n  spec: OpenApiDocument;\n  input: NormalizedInputOptions;\n  output: NormalizedOutputOptions;\n  target: string;\n  workspace: string;\n  projectName?: string;\n};\n\nexport interface ContextSpec {\n  projectName?: string;\n  target: string;\n  workspace: string;\n  spec: OpenApiDocument;\n  parents?: string[];\n  output: NormalizedOutputOptions;\n}\n\nexport interface GlobalOptions {\n  watch?: boolean | string | string[];\n  clean?: boolean | string[];\n  prettier?: boolean;\n  biome?: boolean;\n  mock?: boolean | GlobalMockOptions;\n  client?: OutputClient;\n  httpClient?: OutputHttpClient;\n  mode?: OutputMode;\n  tsconfig?: string | Tsconfig;\n  packageJson?: string;\n  input?: string;\n  output?: string;\n}\n\nexport interface Tsconfig {\n  baseUrl?: string;\n  compilerOptions?: {\n    esModuleInterop?: boolean;\n    allowSyntheticDefaultImports?: boolean;\n    exactOptionalPropertyTypes?: boolean;\n    paths?: Record<string, string[]>;\n    target?: TsConfigTarget;\n  };\n}\n\nexport type TsConfigTarget =\n  | 'es3'\n  | 'es5'\n  | 'es6'\n  | 'es2015'\n  | 'es2016'\n  | 'es2017'\n  | 'es2018'\n  | 'es2019'\n  | 'es2020'\n  | 'es2021'\n  | 'es2022'\n  | 'esnext'; // https://www.typescriptlang.org/tsconfig#target\n\nexport interface PackageJson {\n  dependencies?: Record<string, string>;\n  devDependencies?: Record<string, string>;\n  peerDependencies?: Record<string, string>;\n  catalog?: Record<string, string>;\n  catalogs?: Record<string, Record<string, string>>;\n}\n\nexport type GeneratorSchema = {\n  name: string;\n  model: string;\n  imports: GeneratorImport[];\n  dependencies?: string[];\n  schema?: OpenApiSchemaObject;\n};\n\nexport type GeneratorImport = {\n  name: string;\n  schemaName?: string;\n  isZodSchema?: boolean;\n  isConstant?: boolean;\n  alias?: string;\n  default?: boolean;\n  values?: boolean;\n  syntheticDefaultImport?: boolean;\n  namespaceImport?: boolean;\n  importPath?: string;\n};\n\nexport type GeneratorDependency = {\n  exports: GeneratorImport[];\n  dependency: string;\n};\n\nexport type GeneratorApiResponse = {\n  operations: GeneratorOperations;\n  schemas: GeneratorSchema[];\n};\n\nexport type GeneratorOperations = Record<string, GeneratorOperation>;\n\nexport type GeneratorTarget = {\n  imports: GeneratorImport[];\n  implementation: string;\n  implementationMock: string;\n  importsMock: GeneratorImport[];\n  mutators?: GeneratorMutator[];\n  clientMutators?: GeneratorMutator[];\n  formData?: GeneratorMutator[];\n  formUrlEncoded?: GeneratorMutator[];\n  paramsSerializer?: GeneratorMutator[];\n  fetchReviver?: GeneratorMutator[];\n};\n\nexport type GeneratorTargetFull = {\n  imports: GeneratorImport[];\n  implementation: string;\n  implementationMock: {\n    function: string;\n    handler: string;\n    handlerName: string;\n  };\n  importsMock: GeneratorImport[];\n  mutators?: GeneratorMutator[];\n  clientMutators?: GeneratorMutator[];\n  formData?: GeneratorMutator[];\n  formUrlEncoded?: GeneratorMutator[];\n  paramsSerializer?: GeneratorMutator[];\n  fetchReviver?: GeneratorMutator[];\n};\n\nexport type GeneratorOperation = {\n  imports: GeneratorImport[];\n  implementation: string;\n  implementationMock: {\n    function: string;\n    handler: string;\n    handlerName: string;\n  };\n  importsMock: GeneratorImport[];\n  tags: string[];\n  mutator?: GeneratorMutator;\n  clientMutators?: GeneratorMutator[];\n  formData?: GeneratorMutator;\n  formUrlEncoded?: GeneratorMutator;\n  paramsSerializer?: GeneratorMutator;\n  fetchReviver?: GeneratorMutator;\n  operationName: string;\n  types?: {\n    result: (title?: string) => string;\n  };\n};\n\nexport type GeneratorVerbOptions = {\n  verb: Verbs;\n  route: string;\n  pathRoute: string;\n  summary?: string;\n  doc: string;\n  tags: string[];\n  operationId: string;\n  operationName: string;\n  response: GetterResponse;\n  body: GetterBody;\n  headers?: GetterQueryParam;\n  queryParams?: GetterQueryParam;\n  params: GetterParams;\n  props: GetterProps;\n  mutator?: GeneratorMutator;\n  formData?: GeneratorMutator;\n  formUrlEncoded?: GeneratorMutator;\n  paramsSerializer?: GeneratorMutator;\n  fetchReviver?: GeneratorMutator;\n  override: NormalizedOverrideOutput;\n  deprecated?: boolean;\n  originalOperation: OpenApiOperationObject;\n};\n\nexport type GeneratorVerbsOptions = GeneratorVerbOptions[];\n\nexport type GeneratorOptions = {\n  route: string;\n  pathRoute: string;\n  override: NormalizedOverrideOutput;\n  context: ContextSpec;\n  mock?: GlobalMockOptions | ClientMockBuilder;\n  output: string;\n};\n\nexport type GeneratorClient = {\n  implementation: string;\n  imports: GeneratorImport[];\n  mutators?: GeneratorMutator[];\n};\n\nexport type GeneratorMutatorParsingInfo = {\n  numberOfParams: number;\n  returnNumberOfParams?: number;\n};\nexport type GeneratorMutator = {\n  name: string;\n  path: string;\n  default: boolean;\n  hasErrorType: boolean;\n  errorTypeName: string;\n  hasSecondArg: boolean;\n  hasThirdArg: boolean;\n  isHook: boolean;\n  bodyTypeName?: string;\n};\n\nexport type ClientBuilder = (\n  verbOptions: GeneratorVerbOptions,\n  options: GeneratorOptions,\n  outputClient: OutputClient | OutputClientFunc,\n  output?: NormalizedOutputOptions,\n) => GeneratorClient | Promise<GeneratorClient>;\n\nexport type ClientFileBuilder = {\n  path: string;\n  content: string;\n};\nexport type ClientExtraFilesBuilder = (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) => Promise<ClientFileBuilder[]>;\n\nexport type ClientHeaderBuilder = (params: {\n  title: string;\n  isRequestOptions: boolean;\n  isMutator: boolean;\n  noFunction?: boolean;\n  isGlobalMutator: boolean;\n  provideIn: boolean | 'root' | 'any';\n  hasAwaitedType: boolean;\n  output: NormalizedOutputOptions;\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  tag?: string;\n  clientImplementation: string;\n}) => string;\n\nexport type ClientFooterBuilder = (params: {\n  noFunction?: boolean | undefined;\n  operationNames: string[];\n  title?: string;\n  hasAwaitedType: boolean;\n  hasMutator: boolean;\n}) => string;\n\nexport type ClientTitleBuilder = (title: string) => string;\n\nexport type ClientDependenciesBuilder = (\n  hasGlobalMutator: boolean,\n  hasParamsSerializerOptions: boolean,\n  packageJson?: PackageJson,\n  httpClient?: OutputHttpClient,\n  hasTagsMutator?: boolean,\n  override?: NormalizedOverrideOutput,\n) => GeneratorDependency[];\n\nexport type ClientMockGeneratorImplementation = {\n  function: string;\n  handlerName: string;\n  handler: string;\n};\n\nexport type ClientMockGeneratorBuilder = {\n  imports: GeneratorImport[];\n  implementation: ClientMockGeneratorImplementation;\n};\n\nexport type ClientMockBuilder = (\n  verbOptions: GeneratorVerbOptions,\n  generatorOptions: GeneratorOptions,\n) => ClientMockGeneratorBuilder;\n\nexport interface ClientGeneratorsBuilder {\n  client: ClientBuilder;\n  header?: ClientHeaderBuilder;\n  dependencies?: ClientDependenciesBuilder;\n  footer?: ClientFooterBuilder;\n  title?: ClientTitleBuilder;\n  extraFiles?: ClientExtraFilesBuilder;\n}\n\nexport type GeneratorClients = Record<OutputClient, ClientGeneratorsBuilder>;\n\nexport type GetterResponse = {\n  imports: GeneratorImport[];\n  definition: {\n    success: string;\n    errors: string;\n  };\n  isBlob: boolean;\n  types: {\n    success: ResReqTypesValue[];\n    errors: ResReqTypesValue[];\n  };\n  contentTypes: string[];\n  schemas: GeneratorSchema[];\n\n  originalSchema?: OpenApiResponsesObject;\n};\n\nexport type GetterBody = {\n  originalSchema: OpenApiReferenceObject | OpenApiRequestBodyObject;\n  imports: GeneratorImport[];\n  definition: string;\n  implementation: string;\n  schemas: GeneratorSchema[];\n  formData?: string;\n  formUrlEncoded?: string;\n  contentType: string;\n  isOptional: boolean;\n};\n\nexport type GetterParameters = {\n  query: { parameter: OpenApiParameterObject; imports: GeneratorImport[] }[];\n  path: { parameter: OpenApiParameterObject; imports: GeneratorImport[] }[];\n  header: { parameter: OpenApiParameterObject; imports: GeneratorImport[] }[];\n};\n\nexport type GetterParam = {\n  name: string;\n  definition: string;\n  implementation: string;\n  default: boolean;\n  required: boolean;\n  imports: GeneratorImport[];\n};\n\nexport type GetterParams = GetterParam[];\nexport type GetterQueryParam = {\n  schema: GeneratorSchema;\n  deps: GeneratorSchema[];\n  isOptional: boolean;\n  originalSchema?: OpenApiSchemaObject;\n};\n\nexport type GetterPropType =\n  | 'param'\n  | 'body'\n  | 'queryParam'\n  | 'header'\n  | 'namedPathParams';\n\nexport const GetterPropType = {\n  PARAM: 'param',\n  NAMED_PATH_PARAMS: 'namedPathParams',\n  BODY: 'body',\n  QUERY_PARAM: 'queryParam',\n  HEADER: 'header',\n} as const;\n\ntype GetterPropBase = {\n  name: string;\n  definition: string;\n  implementation: string;\n  default: boolean;\n  required: boolean;\n};\n\nexport type GetterProp = GetterPropBase &\n  (\n    | { type: 'namedPathParams'; destructured: string; schema: GeneratorSchema }\n    | { type: Exclude<GetterPropType, 'namedPathParams'> }\n  );\n\nexport type GetterProps = GetterProp[];\n\nexport type SchemaType =\n  | 'integer'\n  | 'number'\n  | 'string'\n  | 'boolean'\n  | 'object'\n  | 'null'\n  | 'array'\n  | 'enum'\n  | 'unknown';\n\nexport const SchemaType = {\n  integer: 'integer',\n  number: 'number',\n  string: 'string',\n  boolean: 'boolean',\n  object: 'object',\n  null: 'null',\n  array: 'array',\n  enum: 'enum',\n  unknown: 'unknown',\n};\n\nexport type ScalarValue = {\n  value: string;\n  useTypeAlias?: boolean;\n  isEnum: boolean;\n  hasReadonlyProps: boolean;\n  type: SchemaType;\n  imports: GeneratorImport[];\n  schemas: GeneratorSchema[];\n  isRef: boolean;\n  dependencies: string[];\n  example?: any;\n  examples?: Record<string, any>;\n};\n\nexport type ResolverValue = ScalarValue & {\n  originalSchema: OpenApiSchemaObject;\n};\n\nexport type ResReqTypesValue = ScalarValue & {\n  formData?: string;\n  formUrlEncoded?: string;\n  isRef?: boolean;\n  hasReadonlyProps?: boolean;\n  key: string;\n  contentType: string;\n  originalSchema?: OpenApiSchemaObject;\n};\n\nexport type WriteSpecBuilder = {\n  operations: GeneratorOperations;\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  schemas: GeneratorSchema[];\n  title: GeneratorClientTitle;\n  header: GeneratorClientHeader;\n  footer: GeneratorClientFooter;\n  imports: GeneratorClientImports;\n  importsMock: GenerateMockImports;\n  extraFiles: ClientFileBuilder[];\n  info: OpenApiInfoObject;\n  target: string;\n  spec: OpenApiDocument;\n};\n\nexport type WriteModeProps = {\n  builder: WriteSpecBuilder;\n  output: NormalizedOutputOptions;\n  workspace: string;\n  projectName?: string;\n  header: string;\n  needSchema: boolean;\n};\n\nexport type GeneratorApiOperations = {\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  operations: GeneratorOperations;\n  schemas: GeneratorSchema[];\n};\n\nexport type GeneratorClientExtra = {\n  implementation: string;\n  implementationMock: string;\n};\n\nexport type GeneratorClientTitle = (data: {\n  outputClient?: OutputClient | OutputClientFunc;\n  title: string;\n  customTitleFunc?: (title: string) => string;\n  output: NormalizedOutputOptions;\n}) => GeneratorClientExtra;\n\nexport type GeneratorClientHeader = (data: {\n  outputClient?: OutputClient | OutputClientFunc;\n  isRequestOptions: boolean;\n  isMutator: boolean;\n  isGlobalMutator: boolean;\n  provideIn: boolean | 'root' | 'any';\n  hasAwaitedType: boolean;\n  titles: GeneratorClientExtra;\n  output: NormalizedOutputOptions;\n  verbOptions: Record<string, GeneratorVerbOptions>;\n  tag?: string;\n  clientImplementation: string;\n}) => GeneratorClientExtra;\n\nexport type GeneratorClientFooter = (data: {\n  outputClient: OutputClient | OutputClientFunc;\n  operationNames: string[];\n  hasMutator: boolean;\n  hasAwaitedType: boolean;\n  titles: GeneratorClientExtra;\n  output: NormalizedOutputOptions;\n}) => GeneratorClientExtra;\n\nexport type GeneratorClientImports = (data: {\n  client: OutputClient | OutputClientFunc;\n  implementation: string;\n  imports: {\n    exports: GeneratorImport[];\n    dependency: string;\n  }[];\n  projectName?: string;\n  hasSchemaDir: boolean;\n  isAllowSyntheticDefaultImports: boolean;\n  hasGlobalMutator: boolean;\n  hasTagsMutator: boolean;\n  hasParamsSerializerOptions: boolean;\n  packageJson?: PackageJson;\n  output: NormalizedOutputOptions;\n}) => string;\n\nexport type GenerateMockImports = (data: {\n  implementation: string;\n  imports: {\n    exports: GeneratorImport[];\n    dependency: string;\n  }[];\n  projectName?: string;\n  hasSchemaDir: boolean;\n  isAllowSyntheticDefaultImports: boolean;\n  options?: GlobalMockOptions;\n}) => string;\n\nexport type GeneratorApiBuilder = GeneratorApiOperations & {\n  title: GeneratorClientTitle;\n  header: GeneratorClientHeader;\n  footer: GeneratorClientFooter;\n  imports: GeneratorClientImports;\n  importsMock: GenerateMockImports;\n  extraFiles: ClientFileBuilder[];\n};\n\nexport class ErrorWithTag extends Error {\n  tag: string;\n  constructor(message: string, tag: string, options?: ErrorOptions) {\n    super(message, options);\n    this.tag = tag;\n  }\n}\n\nexport type OpenApiSchemaObjectType =\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'object'\n  | 'integer'\n  | 'null'\n  | 'array';\n\n// OpenAPI type aliases. Intended to make it easy to swap to OpenAPI v3.2 in the future\nexport type OpenApiDocument = OpenAPIV3_1.Document;\nexport type OpenApiSchemaObject = OpenAPIV3_1.SchemaObject;\nexport type OpenApiSchemasObject = Record<string, OpenApiSchemaObject>;\nexport type OpenApiReferenceObject = OpenAPIV3_1.ReferenceObject & {\n  // https://github.com/scalar/scalar/issues/7405\n  $ref?: string;\n};\nexport type OpenApiComponentsObject = OpenAPIV3_1.ComponentsObject;\nexport type OpenApiPathsObject = OpenAPIV3_1.PathsObject;\nexport type OpenApiPathItemObject = OpenAPIV3_1.PathItemObject;\nexport type OpenApiResponsesObject = OpenAPIV3_1.ResponsesObject;\nexport type OpenApiResponseObject = OpenAPIV3_1.ResponseObject;\nexport type OpenApiParameterObject = OpenAPIV3_1.ParameterObject;\nexport type OpenApiRequestBodyObject = OpenAPIV3_1.RequestBodyObject;\nexport type OpenApiInfoObject = OpenAPIV3_1.InfoObject;\nexport type OpenApiExampleObject = OpenAPIV3_1.ExampleObject;\nexport type OpenApiOperationObject = OpenAPIV3_1.OperationObject;\nexport type OpenApiMediaTypeObject = OpenAPIV3_1.MediaTypeObject;\nexport type OpenApiEncodingObject = OpenAPIV3_1.EncodingObject;\nexport type OpenApiServerObject = OpenAPIV3_1.ServerObject;\n","import { Verbs } from './types';\n\nexport const generalJSTypes = [\n  'number',\n  'string',\n  'null',\n  'unknown',\n  'undefined',\n  'object',\n  'blob',\n];\n\nexport const generalJSTypesWithArray = generalJSTypes.reduce<string[]>(\n  (acc, type) => {\n    acc.push(type, `Array<${type}>`, `${type}[]`);\n\n    return acc;\n  },\n  [],\n);\n\nexport const VERBS_WITH_BODY = [\n  Verbs.POST,\n  Verbs.PUT,\n  Verbs.PATCH,\n  Verbs.DELETE,\n];\n\nexport const URL_REGEX =\n  /^(?:http(s)?:\\/\\/)?[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&'\\(\\)\\*\\+,;=.]+$/;\n\nexport const TEMPLATE_TAG_REGEX = /\\${(.+?)}/g; // For replace of 'thing' ${thing}\n","export function getExtension(path: string) {\n  return path.toLowerCase().includes('.yaml') ||\n    path.toLowerCase().includes('.yml')\n    ? 'yaml'\n    : 'json';\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport { globby } from 'globby';\n\nimport { isDirectory } from './assertion';\n\nexport function getFileInfo(\n  target = '',\n  {\n    backupFilename = 'filename',\n    extension = '.ts',\n  }: { backupFilename?: string; extension?: string } = {},\n) {\n  const isDir = isDirectory(target);\n  const filePath = isDir\n    ? path.join(target, backupFilename + extension)\n    : target;\n  const pathWithoutExtension = filePath.replace(/\\.[^/.]+$/, '');\n  const dir = path.dirname(filePath);\n  const filename = path.basename(\n    filePath,\n    extension.startsWith('.') ? extension : `.${extension}`,\n  );\n\n  return {\n    path: filePath,\n    pathWithoutExtension,\n    extension,\n    isDirectory: isDir,\n    dirname: dir,\n    filename,\n  };\n}\n\nexport async function removeFilesAndEmptyFolders(\n  patterns: string[],\n  dir: string,\n) {\n  const files = await globby(patterns, {\n    cwd: dir,\n    absolute: true,\n  });\n\n  // Remove files\n  await Promise.all(files.map((file) => fs.promises.unlink(file)));\n\n  // Find and remove empty directories\n  const directories = await globby(['**/*'], {\n    cwd: dir,\n    absolute: true,\n    onlyDirectories: true,\n  });\n\n  // Sort directories by depth (deepest first) to ensure we can remove nested empty folders\n  const sortedDirectories = directories.toSorted((a, b) => {\n    const depthA = a.split('/').length;\n    const depthB = b.split('/').length;\n    return depthB - depthA;\n  });\n\n  // Remove empty directories\n  for (const directory of sortedDirectories) {\n    try {\n      const contents = await fs.promises.readdir(directory);\n      if (contents.length === 0) {\n        await fs.promises.rmdir(directory);\n      }\n    } catch {\n      // Directory might have been removed already or doesn't exist\n      // Continue with next directory\n    }\n  }\n}\n","import basepath from 'node:path';\n\nimport { isUrl } from './assertion';\nimport { getExtension } from './extension';\nimport { getFileInfo } from './file';\n\n// override path to support windows paths\n// https://github.com/anodynos/upath/blob/master/source/code/upath.coffee\ntype Path = typeof basepath;\nconst path = {} as Path;\n\nconst isFunction = (val: any) => typeof val == 'function';\n\nconst isString = (val: any) => {\n  if (typeof val === 'string') {\n    return true;\n  }\n\n  if (typeof val === 'object' && val !== null) {\n    return Object.toString.call(val) == '[object String]';\n  }\n\n  return false;\n};\n\nfor (const [propName, propValue] of Object.entries(basepath)) {\n  if (isFunction(propValue)) {\n    // @ts-ignore\n    path[propName] = ((propName) => {\n      return (...args: any[]) => {\n        args = args.map((p) => {\n          return isString(p) ? toUnix(p) : p;\n        });\n\n        // @ts-ignore\n        const result = basepath[propName](...args);\n        return isString(result) ? toUnix(result) : result;\n      };\n    })(propName);\n  } else {\n    // @ts-ignore\n    path[propName] = propValue;\n  }\n}\n\nconst { join, resolve, extname, dirname, basename, isAbsolute } = path;\nexport { basename, dirname, extname, isAbsolute, join, resolve };\n\n/**\n * Behaves exactly like `path.relative(from, to)`, but keeps the first meaningful \"./\"\n */\nexport function relativeSafe(from: string, to: string) {\n  const normalizedRelativePath = path.relative(from, to);\n  /**\n   * Prepend \"./\" to every path and then use normalizeSafe method to normalize it\n   * normalizeSafe doesn't remove meaningful leading \"./\"\n   */\n  const relativePath = normalizeSafe(`.${separator}${normalizedRelativePath}`);\n  return relativePath;\n}\n\nexport function getSchemaFileName(path: string) {\n  return path\n    .replace(`.${getExtension(path)}`, '')\n    .slice(path.lastIndexOf('/') + 1);\n}\n\nexport const separator = '/';\n\nconst toUnix = function (value: string) {\n  value = value.replaceAll('\\\\', '/');\n  value = value.replaceAll(/(?<!^)\\/+/g, '/'); // replace doubles except beginning for UNC path\n  return value;\n};\n\nexport function normalizeSafe(value: string) {\n  let result;\n  value = toUnix(value);\n  result = path.normalize(value);\n  if (\n    value.startsWith('./') &&\n    !result.startsWith('./') &&\n    !result.startsWith('..')\n  ) {\n    result = './' + result;\n  } else if (value.startsWith('//') && !result.startsWith('//')) {\n    result = value.startsWith('//./') ? '//.' + result : '/' + result;\n  }\n  return result;\n}\n\nexport function joinSafe(...values: string[]) {\n  let result = path.join(...values);\n\n  if (values.length > 0) {\n    const firstValue = toUnix(values[0]);\n    if (\n      firstValue.startsWith('./') &&\n      !result.startsWith('./') &&\n      !result.startsWith('..')\n    ) {\n      result = './' + result;\n    } else if (firstValue.startsWith('//') && !result.startsWith('//')) {\n      result = firstValue.startsWith('//./') ? '//.' + result : '/' + result;\n    }\n  }\n  return result;\n}\n","import {\n  type OpenApiReferenceObject,\n  type OpenApiSchemaObject,\n  SchemaType,\n  Verbs,\n} from '../types';\nimport { extname } from './path';\n\n/**\n * Discriminator helper for `ReferenceObject`\n *\n * @param property\n */\nexport function isReference(obj: object): obj is OpenApiReferenceObject {\n  return !isNull(obj) && Object.hasOwn(obj, '$ref');\n}\n\nexport function isDirectory(path: string) {\n  return !extname(path);\n}\n\nexport function isObject(x: any): x is Record<string, unknown> {\n  return Object.prototype.toString.call(x) === '[object Object]';\n}\n\nexport function isModule(x: any): x is Record<string, unknown> {\n  return Object.prototype.toString.call(x) === '[object Module]';\n}\n\nexport function isString(x: any): x is string {\n  return typeof x === 'string';\n}\n\nexport function isNumber(x: any): x is number {\n  return typeof x === 'number';\n}\n\nexport function isNumeric(x: any): x is number {\n  return /^-?\\d+$/.test(x);\n}\n\nexport function isBoolean(x: any): x is boolean {\n  return typeof x === 'boolean';\n}\n\nexport function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n\nexport function isUndefined(x: any): x is undefined {\n  return x === undefined;\n}\n\nexport function isNull(x: any): x is null {\n  return x === null;\n}\n\nexport function isSchema(x: unknown): x is OpenApiSchemaObject {\n  if (!isObject(x)) {\n    return false;\n  }\n\n  if (isString(x.type) && Object.values(SchemaType).includes(x.type)) {\n    return true;\n  }\n\n  const combine = x.allOf || x.anyOf || x.oneOf;\n  if (Array.isArray(combine)) {\n    return true;\n  }\n\n  if (isObject(x.properties)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isVerb(verb: string): verb is Verbs {\n  return Object.values(Verbs).includes(verb as Verbs);\n}\n\nexport function isUrl(str: string) {\n  let givenURL;\n  try {\n    givenURL = new URL(str);\n  } catch {\n    return false;\n  }\n  return givenURL.protocol === 'http:' || givenURL.protocol === 'https:';\n}\n","export async function asyncReduce<IterationItem, AccValue>(\n  array: IterationItem[],\n  reducer: (\n    accumulate: AccValue,\n    current: IterationItem,\n  ) => AccValue | Promise<AccValue>,\n  initValue: AccValue,\n): Promise<AccValue> {\n  let accumulate =\n    typeof initValue === 'object'\n      ? Object.create(initValue as unknown as object)\n      : initValue;\n\n  for (const item of array) {\n    accumulate = await reducer(accumulate, item);\n  }\n\n  return accumulate;\n}\n","import { NamingConvention } from '../types';\n\nconst unicodes = function (s: string, prefix: string) {\n  prefix = prefix || '';\n  return s\n    .replaceAll(/(^|-)/g, String.raw`$1\\u` + prefix)\n    .replaceAll(',', String.raw`\\u` + prefix);\n};\n\nconst symbols = unicodes('20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7', '00');\nconst lowers = 'a-z' + unicodes('DF-F6,F8-FF', '00');\nconst uppers = 'A-Z' + unicodes('C0-D6,D8-DE', '00');\nconst impropers = String.raw`A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\.?|Via`;\n\nconst regexps = {\n  capitalize: new RegExp('(^|[' + symbols + '])([' + lowers + '])', 'g'),\n  pascal: new RegExp('(^|[' + symbols + '])+([' + lowers + uppers + '])', 'g'),\n  fill: new RegExp('[' + symbols + ']+(.|$)', 'g'),\n  sentence: new RegExp(\n    String.raw`(^\\s*|[\\?\\!\\.]+\"?\\s+\"?|,\\s+\")([` + lowers + '])',\n    'g',\n  ),\n  improper: new RegExp(String.raw`\\b(` + impropers + String.raw`)\\b`, 'g'),\n  relax: new RegExp(\n    '([^' +\n      uppers +\n      '])([' +\n      uppers +\n      ']*)([' +\n      uppers +\n      '])(?=[^' +\n      uppers +\n      ']|$)',\n    'g',\n  ),\n  upper: new RegExp('^[^' + lowers + ']+$'),\n  hole: /[^\\s]\\s[^\\s]/,\n  apostrophe: /'/g,\n  room: new RegExp('[' + symbols + ']'),\n};\n\nconst deapostrophe = (s: string) => {\n  return s.replace(regexps.apostrophe, '');\n};\n\nconst up = String.prototype.toUpperCase;\nconst low = String.prototype.toLowerCase;\n\nconst fill = (s: string, fillWith: string, isDeapostrophe = false) => {\n  s = s.replace(regexps.fill, function (m, next) {\n    return next ? fillWith + next : '';\n  });\n\n  if (isDeapostrophe) {\n    s = deapostrophe(s);\n  }\n  return s;\n};\n\nconst decap = (s: string, char = 0) => {\n  return low.call(s.charAt(char)) + s.slice(char + 1);\n};\n\nconst relax = (\n  m: string,\n  before: string,\n  acronym: string | undefined,\n  caps: string,\n) => {\n  return before + ' ' + (acronym ? acronym + ' ' : '') + caps;\n};\n\nconst prep = (s: string, isFill = false, isPascal = false, isUpper = false) => {\n  s = s == undefined ? '' : s + ''; // force to string\n  if (!isUpper && regexps.upper.test(s)) {\n    s = low.call(s);\n  }\n  if (!isFill && !regexps.hole.test(s)) {\n    // eslint-disable-next-line no-var\n    var holey = fill(s, ' ');\n    if (regexps.hole.test(holey)) {\n      s = holey;\n    }\n  }\n  if (!isPascal && !regexps.room.test(s)) {\n    s = s.replace(regexps.relax, relax);\n  }\n  return s;\n};\n\nconst lower = (s: string, fillWith: string, isDeapostrophe: boolean) => {\n  return fill(low.call(prep(s, !!fillWith)), fillWith, isDeapostrophe);\n};\n\n// Caches the previously converted strings to improve performance\nconst pascalMemory: Record<string, string> = {};\n\nexport function pascal(s: string) {\n  if (pascalMemory[s]) {\n    return pascalMemory[s];\n  }\n\n  const isStartWithUnderscore = s?.startsWith('_');\n\n  if (regexps.upper.test(s)) {\n    s = low.call(s);\n  }\n\n  const pascalString = (s?.match(/[a-zA-Z0-9\\u00C0-\\u017F]+/g) || [])\n    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))\n    .join('');\n\n  const pascalWithUnderscore = isStartWithUnderscore\n    ? `_${pascalString}`\n    : pascalString;\n\n  pascalMemory[s] = pascalWithUnderscore;\n\n  return pascalWithUnderscore;\n}\n\nexport function camel(s: string) {\n  const isStartWithUnderscore = s?.startsWith('_');\n  const camelString = decap(pascal(s), isStartWithUnderscore ? 1 : 0);\n  return isStartWithUnderscore ? `_${camelString}` : camelString;\n}\n\nexport function snake(s: string) {\n  return lower(s, '_', true);\n}\n\nexport function kebab(s: string) {\n  return lower(s, '-', true);\n}\n\nexport function upper(s: string, fillWith: string, isDeapostrophe?: boolean) {\n  return fill(\n    up.call(prep(s, !!fillWith, false, true)),\n    fillWith,\n    isDeapostrophe,\n  );\n}\n\nexport function conventionName(name: string, convention: NamingConvention) {\n  let nameConventionTransform = camel;\n  switch (convention) {\n    case NamingConvention.PASCAL_CASE: {\n      nameConventionTransform = pascal;\n\n      break;\n    }\n    case NamingConvention.SNAKE_CASE: {\n      nameConventionTransform = snake;\n\n      break;\n    }\n    case NamingConvention.KEBAB_CASE: {\n      nameConventionTransform = kebab;\n\n      break;\n    }\n    // No default\n  }\n\n  return nameConventionTransform(name);\n}\n","import type { OpenApiSchemaObject } from '../types';\n\n/**\n * Determine if a content type is binary (vs text-based).\n */\nexport function isBinaryContentType(contentType: string): boolean {\n  if (contentType === 'application/octet-stream') return true;\n\n  if (contentType.startsWith('image/')) return true;\n  if (contentType.startsWith('audio/')) return true;\n  if (contentType.startsWith('video/')) return true;\n  if (contentType.startsWith('font/')) return true;\n\n  // text/* types are not binary\n  if (contentType.startsWith('text/')) return false;\n\n  // text-based suffixes (RFC 6838)\n  const textSuffixes = [\n    '+json',\n    '-json',\n    '+xml',\n    '-xml',\n    '+yaml',\n    '-yaml',\n    '+rss',\n    '-rss',\n    '+csv',\n    '-csv',\n  ];\n  if (textSuffixes.some((suffix) => contentType.includes(suffix))) {\n    return false;\n  }\n\n  // text-based whitelist - these are NOT binary\n  const textApplicationTypes = new Set([\n    'application/json',\n    'application/xml',\n    'application/yaml',\n    'application/x-www-form-urlencoded',\n    'application/javascript',\n    'application/ecmascript',\n    'application/graphql',\n  ]);\n\n  return !textApplicationTypes.has(contentType);\n}\n\n/**\n * Determine if a form-data field should be treated as a file (binary or text).\n *\n * Precedence (per OAS 3.1): encoding.contentType > schema.contentMediaType\n *\n * Returns:\n * - 'binary': binary file (Blob)\n * - 'text': text file (Blob | string)\n * - undefined: not a file, use standard string resolution\n */\nexport function getFormDataFieldFileType(\n  resolvedSchema: OpenApiSchemaObject,\n  partContentType: string | undefined,\n): 'binary' | 'text' | undefined {\n  // Only override string fields - objects/arrays with encoding are just serialized\n  if (resolvedSchema.type !== 'string') {\n    return undefined;\n  }\n\n  // contentEncoding (e.g., base64) means the value is an encoded string, not a file\n  if (resolvedSchema.contentEncoding) {\n    return undefined;\n  }\n\n  const effectiveContentType =\n    partContentType ?? resolvedSchema.contentMediaType;\n\n  if (effectiveContentType) {\n    return isBinaryContentType(effectiveContentType) ? 'binary' : 'text';\n  }\n\n  return undefined;\n}\n","import { compare, type CompareOperator } from 'compare-versions';\n\nexport function compareVersions(\n  firstVersion: string,\n  secondVersions: string,\n  operator: CompareOperator = '>=',\n) {\n  if (firstVersion === 'latest' || firstVersion === '*') {\n    return true;\n  }\n\n  // Handle workspace catalog references (pnpm/bun)\n  // catalog: or catalog:name format - assume latest version\n  if (firstVersion.startsWith('catalog:')) {\n    return true;\n  }\n\n  return compare(\n    firstVersion.replace(/(\\s(.*))/, ''),\n    secondVersions,\n    operator,\n  );\n}\n","import debug from 'debug';\n\nconst filter = process.env.ORVAL_DEBUG_FILTER;\nconst DEBUG = process.env.DEBUG;\n\ninterface DebuggerOptions {\n  onlyWhenFocused?: boolean | string;\n}\n\nexport function createDebugger(\n  ns: string,\n  options: DebuggerOptions = {},\n): debug.Debugger['log'] {\n  const log = debug(ns);\n  const { onlyWhenFocused } = options;\n  const focus = typeof onlyWhenFocused === 'string' ? onlyWhenFocused : ns;\n  return (msg: string, ...args: any[]) => {\n    if (filter && !msg.includes(filter)) {\n      return;\n    }\n    if (onlyWhenFocused && !DEBUG?.includes(focus)) {\n      return;\n    }\n    log(msg, ...args);\n  };\n}\n","import type { ContextSpec } from '../types';\n\nconst search = String.raw`\\*/`; // Find '*/'\nconst replacement = String.raw`*\\/`; // Replace With '*\\/'\n\nconst regex = new RegExp(search, 'g');\n\nexport function jsDoc(\n  schema: {\n    description?: string[] | string;\n    deprecated?: boolean;\n    summary?: string;\n    minLength?: number;\n    maxLength?: number;\n    minimum?: number;\n    maximum?: number;\n    exclusiveMinimum?: number;\n    exclusiveMaximum?: number;\n    minItems?: number;\n    maxItems?: number;\n    type?: string | string[];\n    pattern?: string;\n  },\n  tryOneLine = false,\n  context?: ContextSpec,\n): string {\n  if (context?.output?.override?.jsDoc) {\n    const { filter } = context.output.override.jsDoc;\n    if (filter) {\n      return keyValuePairsToJsDoc(filter(schema));\n    }\n  }\n  const {\n    description,\n    deprecated,\n    summary,\n    minLength,\n    maxLength,\n    minimum,\n    maximum,\n    exclusiveMinimum,\n    exclusiveMaximum,\n    minItems,\n    maxItems,\n    pattern,\n  } = schema;\n  const isNullable =\n    schema.type === 'null' ||\n    (Array.isArray(schema.type) && schema.type.includes('null'));\n  // Ensure there aren't any comment terminations in doc\n  const lines = (\n    Array.isArray(description)\n      ? description.filter((d) => !d.includes('eslint-disable'))\n      : [description || '']\n  ).map((line) => line.replaceAll(regex, replacement));\n\n  const count = [\n    description,\n    deprecated,\n    summary,\n    minLength?.toString(),\n    maxLength?.toString(),\n    minimum?.toString(),\n    maximum?.toString(),\n    exclusiveMinimum?.toString(),\n    exclusiveMaximum?.toString(),\n    minItems?.toString(),\n    maxItems?.toString(),\n    isNullable ? 'null' : '',\n    pattern,\n  ].reduce((acc, it) => (it ? acc + 1 : acc), 0);\n\n  if (!count) {\n    return '';\n  }\n\n  const oneLine = count === 1 && tryOneLine;\n  const eslintDisable = Array.isArray(description)\n    ? description\n        .find((d) => d.includes('eslint-disable'))\n        ?.replaceAll(regex, replacement)\n    : undefined;\n  let doc = `${eslintDisable ? `/* ${eslintDisable} */\\n` : ''}/**`;\n\n  if (description) {\n    if (!oneLine) {\n      doc += `\\n${tryOneLine ? '  ' : ''} *`;\n    }\n    doc += ` ${lines.join('\\n * ')}`;\n  }\n\n  function appendPrefix() {\n    if (!oneLine) {\n      doc += `\\n${tryOneLine ? '  ' : ''} *`;\n    }\n  }\n\n  function tryAppendStringDocLine(key: string, value?: string) {\n    if (value) {\n      appendPrefix();\n      doc += ` @${key} ${value.replaceAll(regex, replacement)}`;\n    }\n  }\n\n  function tryAppendBooleanDocLine(key: string, value?: boolean) {\n    if (value === true) {\n      appendPrefix();\n      doc += ` @${key}`;\n    }\n  }\n\n  function tryAppendNumberDocLine(key: string, value?: number) {\n    if (value !== undefined) {\n      appendPrefix();\n      doc += ` @${key} ${value}`;\n    }\n  }\n\n  tryAppendBooleanDocLine('deprecated', deprecated);\n  tryAppendStringDocLine('summary', summary?.replaceAll(regex, replacement));\n  tryAppendNumberDocLine('minLength', minLength);\n  tryAppendNumberDocLine('maxLength', maxLength);\n  tryAppendNumberDocLine('minimum', minimum);\n  tryAppendNumberDocLine('maximum', maximum);\n  tryAppendNumberDocLine('exclusiveMinimum', exclusiveMinimum);\n  tryAppendNumberDocLine('exclusiveMaximum', exclusiveMaximum);\n  tryAppendNumberDocLine('minItems', minItems);\n  tryAppendNumberDocLine('maxItems', maxItems);\n  tryAppendBooleanDocLine('nullable', isNullable);\n  tryAppendStringDocLine('pattern', pattern);\n\n  doc += oneLine ? ' ' : `\\n ${tryOneLine ? '  ' : ''}`;\n\n  doc += '*/\\n';\n\n  return doc;\n}\n\nexport function keyValuePairsToJsDoc(\n  keyValues: {\n    key: string;\n    value: string;\n  }[],\n) {\n  if (keyValues.length === 0) return '';\n  let doc = '/**\\n';\n  for (const { key, value } of keyValues) {\n    doc += ` * @${key} ${value}\\n`;\n  }\n  doc += ' */\\n';\n  return doc;\n}\n","import path from 'node:path';\nimport { pathToFileURL } from 'node:url';\n\nimport { isModule, isObject, isString } from './assertion';\n\nexport async function dynamicImport<T>(\n  toImport: T | string,\n  from = process.cwd(),\n  takeDefault = true,\n): Promise<T> {\n  if (!toImport) {\n    return toImport as T;\n  }\n\n  try {\n    if (isString(toImport)) {\n      const filePath = path.resolve(from, toImport);\n      // use pathToFileURL to solve issue #1332.\n      // https://github.com/nodejs/node/issues/31710\n      const fileUrl = pathToFileURL(filePath);\n      const isJson = path.extname(fileUrl.href) === '.json';\n      const data = isJson\n        ? await import(fileUrl.href, { with: { type: 'json' } })\n        : await import(fileUrl.href);\n      if (takeDefault && (isObject(data) || isModule(data)) && data.default) {\n        return (data as any).default as T;\n      }\n\n      return data as unknown as T;\n    }\n\n    return toImport as T;\n  } catch (error) {\n    throw new Error(`Oups... . Path: ${toImport} => ${error}`);\n  }\n}\n","import type { ClientMockBuilder, GlobalMockOptions } from '../types';\nimport { isFunction } from './assertion';\n\nexport function getMockFileExtensionByTypeName(\n  mock: GlobalMockOptions | ClientMockBuilder,\n) {\n  if (isFunction(mock)) {\n    return 'msw';\n  }\n  switch (mock.type) {\n    default: {\n      // case 'msw':\n      return 'msw';\n    }\n  }\n}\n","/**\n * Type safe way to get arbitrary property from an object.\n *\n * @param obj - The object from which to retrieve the property.\n * @param propertyName - The name of the property to retrieve.\n * @returns Object with `hasProperty: true` and `value` of the property if it exists; otherwise `hasProperty: false` and undefined.\n *\n * @remarks Until TypeScript adds type-narrowing for Object.hasOwn we have to use this workaround\n */\nexport function getPropertySafe<T extends object, K extends keyof T>(\n  obj: T,\n  propertyName: K | string,\n):\n  | { hasProperty: true; value: T[K] }\n  | { hasProperty: false; value: undefined } {\n  if (Object.hasOwn(obj, propertyName)) {\n    // safe to cast here because of the above check\n    return { hasProperty: true, value: obj[propertyName as K] };\n  }\n\n  return { hasProperty: false, value: undefined };\n}\n","import { VERBS_WITH_BODY } from '../constants';\nimport { Verbs } from '../types';\n\nexport function getIsBodyVerb(verb: Verbs) {\n  return VERBS_WITH_BODY.includes(verb);\n}\n","import readline from 'node:readline';\n\nimport chalk from 'chalk';\n\nexport const log = console.log;\n\nexport function startMessage({\n  name,\n  version,\n  description,\n}: {\n  name: string;\n  version: string;\n  description: string;\n}): string {\n  return ` ${chalk.cyan.bold(name)} ${chalk.green(`v${version}`)}${\n    description ? ` - ${description}` : ''\n  }`;\n}\n\nexport function logError(err: unknown, tag?: string) {\n  let message = '';\n\n  if (err instanceof Error) {\n    message = (err.message || err.stack) ?? 'Unknown error';\n    if (err.cause) {\n      const causeMsg =\n        err.cause instanceof Error\n          ? err.cause.message\n          : typeof err.cause === 'string'\n            ? err.cause\n            : JSON.stringify(err.cause, undefined, 2);\n      message += `\\n  Cause: ${causeMsg}`;\n    }\n  } else {\n    message = String(err);\n  }\n\n  log(\n    chalk.red(\n      ['', tag ? `${tag} -` : undefined, message].filter(Boolean).join(' '),\n    ),\n  );\n}\n\nexport function mismatchArgsMessage(mismatchArgs: string[]) {\n  log(\n    chalk.yellow(\n      `${mismatchArgs.join(', ')} ${\n        mismatchArgs.length === 1 ? 'is' : 'are'\n      } not defined in your configuration!`,\n    ),\n  );\n}\n\nexport function createSuccessMessage(backend?: string) {\n  log(\n    ` ${\n      backend ? `${chalk.green(backend)} - ` : ''\n    }Your OpenAPI spec has been converted into ready to use orval!`,\n  );\n}\n\nexport type LogType = 'error' | 'warn' | 'info';\nexport type LogLevel = LogType | 'silent';\nexport interface Logger {\n  info(msg: string, options?: LogOptions): void;\n  warn(msg: string, options?: LogOptions): void;\n  warnOnce(msg: string, options?: LogOptions): void;\n  error(msg: string, options?: LogOptions): void;\n  clearScreen(type: LogType): void;\n  hasWarned: boolean;\n}\n\nexport interface LogOptions {\n  clear?: boolean;\n  timestamp?: boolean;\n}\n\nexport const LogLevels: Record<LogLevel, number> = {\n  silent: 0,\n  error: 1,\n  warn: 2,\n  info: 3,\n};\n\nlet lastType: LogType | undefined;\nlet lastMsg: string | undefined;\nlet sameCount = 0;\n\nfunction clearScreen() {\n  const repeatCount = process.stdout.rows - 2;\n  const blank = repeatCount > 0 ? '\\n'.repeat(repeatCount) : '';\n  console.log(blank);\n  readline.cursorTo(process.stdout, 0, 0);\n  readline.clearScreenDown(process.stdout);\n}\n\nexport interface LoggerOptions {\n  prefix?: string;\n  allowClearScreen?: boolean;\n}\n\nexport function createLogger(\n  level: LogLevel = 'info',\n  options: LoggerOptions = {},\n): Logger {\n  const { prefix = '[vite]', allowClearScreen = true } = options;\n\n  const thresh = LogLevels[level];\n  const clear =\n    allowClearScreen && process.stdout.isTTY && !process.env.CI\n      ? clearScreen\n      : () => {};\n\n  function output(type: LogType, msg: string, options: LogOptions = {}) {\n    if (thresh >= LogLevels[type]) {\n      const method = type === 'info' ? 'log' : type;\n      const format = () => {\n        if (options.timestamp) {\n          const tag =\n            type === 'info'\n              ? chalk.cyan.bold(prefix)\n              : type === 'warn'\n                ? chalk.yellow.bold(prefix)\n                : chalk.red.bold(prefix);\n          return `${chalk.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`;\n        } else {\n          return msg;\n        }\n      };\n      if (type === lastType && msg === lastMsg) {\n        sameCount++;\n        clear();\n        console[method](format(), chalk.yellow(`(x${sameCount + 1})`));\n      } else {\n        sameCount = 0;\n        lastMsg = msg;\n        lastType = type;\n        if (options.clear) {\n          clear();\n        }\n        console[method](format());\n      }\n    }\n  }\n\n  const warnedMessages = new Set<string>();\n\n  const logger: Logger = {\n    hasWarned: false,\n    info(msg, opts) {\n      output('info', msg, opts);\n    },\n    warn(msg, opts) {\n      logger.hasWarned = true;\n      output('warn', msg, opts);\n    },\n    warnOnce(msg, opts) {\n      if (warnedMessages.has(msg)) return;\n      logger.hasWarned = true;\n      output('warn', msg, opts);\n      warnedMessages.add(msg);\n    },\n    error(msg, opts) {\n      logger.hasWarned = true;\n      output('error', msg, opts);\n    },\n    clearScreen(type) {\n      if (thresh >= LogLevels[type]) {\n        clear();\n      }\n    },\n  };\n\n  return logger;\n}\n","const isObject = (obj: unknown) => obj && typeof obj === 'object';\n\nexport function mergeDeep<\n  T extends Record<string, any>,\n  U extends Record<string, any>,\n>(source: T, target: U): T & U {\n  if (!isObject(target) || !isObject(source)) {\n    return source as T & U;\n  }\n\n  return Object.entries(target).reduce(\n    (acc, [key, value]) => {\n      const sourceValue = acc[key];\n\n      if (Array.isArray(sourceValue) && Array.isArray(value)) {\n        (acc[key] as any) = [...sourceValue, ...value];\n      } else if (isObject(sourceValue) && isObject(value)) {\n        (acc[key] as any) = mergeDeep(sourceValue, value);\n      } else {\n        (acc[key] as any) = value;\n      }\n\n      return acc;\n    },\n    Object.assign({}, source),\n  ) as T & U;\n}\n","export function count(str = '', key: string) {\n  if (!str) {\n    return 0;\n  }\n\n  return (str.match(new RegExp(key, 'g')) ?? []).length;\n}\n","export const sortByPriority = <T>(\n  arr: (T & { default?: boolean; required?: boolean })[],\n) =>\n  arr.sort((a, b) => {\n    if (a.default) {\n      return 1;\n    }\n\n    if (b.default) {\n      return -1;\n    }\n\n    if (a.required && b.required) {\n      return 0;\n    }\n\n    if (a.required) {\n      return -1;\n    }\n\n    if (b.required) {\n      return 1;\n    }\n    return 0;\n  });\n","import { keyword } from 'esutils';\n\nimport {\n  isBoolean,\n  isFunction,\n  isNull,\n  isNumber,\n  isString,\n  isUndefined,\n} from './assertion';\n\n/**\n * Converts data to a string representation suitable for code generation.\n * Handles strings, numbers, booleans, functions, arrays, and objects.\n *\n * @param data - The data to stringify. Can be a string, array, object, number, boolean, function, null, or undefined.\n * @returns A string representation of the data, or undefined if data is null or undefined.\n * @example\n * stringify('hello') // returns \"'hello'\"\n * stringify(42) // returns \"42\"\n * stringify([1, 2, 3]) // returns \"[1, 2, 3]\"\n * stringify({ a: 1, b: 'test' }) // returns \"{ a: 1, b: 'test', }\"\n */\nexport function stringify(\n  data?: string | any[] | Record<string, any>,\n): string | undefined {\n  if (isUndefined(data) || isNull(data)) {\n    return;\n  }\n\n  if (isString(data)) {\n    return `'${data.replaceAll(\"'\", String.raw`\\'`)}'`;\n  }\n\n  if (isNumber(data) || isBoolean(data) || isFunction(data)) {\n    return `${data}`;\n  }\n\n  if (Array.isArray(data)) {\n    return `[${data.map(stringify).join(', ')}]`;\n  }\n\n  return Object.entries(data).reduce((acc, [key, value], index, arr) => {\n    const strValue = stringify(value);\n    if (arr.length === 1) {\n      return `{ ${key}: ${strValue}, }`;\n    }\n\n    if (!index) {\n      return `{ ${key}: ${strValue}, `;\n    }\n\n    if (arr.length - 1 === index) {\n      return acc + `${key}: ${strValue}, }`;\n    }\n\n    return acc + `${key}: ${strValue}, `;\n  }, '');\n}\n\n/**\n * Sanitizes a string value by removing or replacing special characters and ensuring\n * it conforms to JavaScript identifier naming rules if needed.\n *\n * @param value - The string value to sanitize.\n * @param options - Configuration options for sanitization:\n *   - `whitespace` - Replacement string for whitespace characters, or `true` to keep them.\n *   - `underscore` - Replacement string for underscores, or `true` to keep them.\n *   - `dot` - Replacement string for dots, or `true` to keep them.\n *   - `dash` - Replacement string for dashes, or `true` to keep them.\n *   - `es5keyword` - If true, prefixes the value with underscore if it's an ES5 keyword.\n *   - `es5IdentifierName` - If true, ensures the value is a valid ES5 identifier name.\n *   - `special` - If true, preserves special characters that would otherwise be removed.\n * @returns The sanitized string value.\n * @example\n * sanitize('hello-world', { dash: '_' }) // returns \"hello_world\"\n * sanitize('class', { es5keyword: true }) // returns \"_class\"\n * sanitize('123abc', { es5IdentifierName: true }) // returns \"N123abc\"\n */\nexport function sanitize(\n  value: string,\n  options?: {\n    whitespace?: string | true;\n    underscore?: string | true;\n    dot?: string | true;\n    dash?: string | true;\n    es5keyword?: boolean;\n    es5IdentifierName?: boolean;\n    special?: boolean;\n  },\n) {\n  const {\n    whitespace = '',\n    underscore = '',\n    dot = '',\n    dash = '',\n    es5keyword = false,\n    es5IdentifierName = false,\n    special = false,\n  } = options ?? {};\n  let newValue = value;\n\n  if (!special) {\n    newValue = newValue.replaceAll(\n      /[!\"`'#%&,:;<>=@{}~\\$\\(\\)\\*\\+\\/\\\\\\?\\[\\]\\^\\|]/g,\n      '',\n    );\n  }\n\n  if (whitespace !== true) {\n    newValue = newValue.replaceAll(/[\\s]/g, whitespace);\n  }\n\n  if (underscore !== true) {\n    newValue = newValue.replaceAll(/['_']/g, underscore);\n  }\n\n  if (dot !== true) {\n    newValue = newValue.replaceAll(/[.]/g, dot);\n  }\n\n  if (dash !== true) {\n    newValue = newValue.replaceAll(/[-]/g, dash);\n  }\n\n  if (es5keyword) {\n    newValue = keyword.isKeywordES5(newValue, true) ? `_${newValue}` : newValue;\n  }\n\n  if (es5IdentifierName) {\n    if (/^[0-9]/.test(newValue)) {\n      newValue = `N${newValue}`;\n    } else {\n      newValue = keyword.isIdentifierNameES5(newValue)\n        ? newValue\n        : `_${newValue}`;\n    }\n  }\n\n  return newValue;\n}\n\n/**\n * Converts an array of objects to a comma-separated string representation.\n * Optionally extracts a nested property from each object using a dot-notation path.\n *\n * @param props - Array of objects to convert to string.\n * @param path - Optional dot-notation path to extract a property from each object (e.g., \"user.name\").\n * @returns A comma-separated string of values, with each value on a new line indented.\n * @example\n * toObjectString([{ name: 'John' }, { name: 'Jane' }], 'name')\n * // returns \"John,\\n    Jane,\"\n * toObjectString(['a', 'b', 'c'])\n * // returns \"a,\\n    b,\\n    c,\"\n */\nexport function toObjectString<T>(props: T[], path?: keyof T) {\n  if (props.length === 0) {\n    return '';\n  }\n\n  const arrayOfString =\n    typeof path === 'string'\n      ? props.map((prop) =>\n          path\n            .split('.')\n            .reduce(\n              (obj: any, key: string) =>\n                obj && typeof obj === 'object' ? obj[key] : undefined,\n              prop,\n            ),\n        )\n      : props;\n\n  return arrayOfString.join(',\\n    ') + ',';\n}\n\nconst NUMBERS = {\n  '0': 'zero',\n  '1': 'one',\n  '2': 'two',\n  '3': 'three',\n  '4': 'four',\n  '5': 'five',\n  '6': 'six',\n  '7': 'seven',\n  '8': 'eight',\n  '9': 'nine',\n};\n\n/**\n * Converts a number to its word representation by translating each digit to its word form.\n *\n * @param num - The number to convert to words.\n * @returns A string containing the word representation of each digit concatenated together.\n * @example\n * getNumberWord(123) // returns \"onetwothree\"\n * getNumberWord(42) // returns \"fourtwo\"\n */\nexport function getNumberWord(num: number) {\n  const arrayOfNumber = num.toString().split('') as (keyof typeof NUMBERS)[];\n  return arrayOfNumber.reduce((acc, n) => acc + NUMBERS[n], '');\n}\n\n/**\n * Escapes a specific character in a string by prefixing it with a backslash.\n *\n * @param str - The string to escape, or null.\n * @param char - The character to escape. Defaults to single quote (').\n * @returns The escaped string, or null if the input is null.\n * @example\n * escape(\"don't\") // returns \"don\\'t\"\n * escape('say \"hello\"', '\"') // returns 'say \\\\\"hello\\\\\"'\n */\nexport function escape(str: string | null, char = \"'\") {\n  return str?.replace(char, `\\\\${char}`);\n}\n\n/**\n * Escape all characters not included in SingleStringCharacters and\n * DoubleStringCharacters on\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\n *\n * Based on https://github.com/joliss/js-string-escape/blob/master/index.js\n *\n * @param input String to escape\n */\nexport function jsStringEscape(input: string) {\n  return input.replaceAll(/[\"'\\\\\\n\\r\\u2028\\u2029/*]/g, (character) => {\n    switch (character) {\n      case '\"':\n      case \"'\":\n      case '\\\\':\n      case '/':\n      case '*': {\n        return '\\\\' + character;\n      }\n      // Four possible LineTerminator characters need to be escaped:\n      case '\\n': {\n        return String.raw`\\n`;\n      }\n      case '\\r': {\n        return String.raw`\\r`;\n      }\n      case '\\u2028': {\n        return String.raw`\\u2028`;\n      }\n      case '\\u2029': {\n        return String.raw`\\u2029`;\n      }\n      default: {\n        return '';\n      }\n    }\n  });\n}\n\n/**\n * Deduplicates a TypeScript union type string.\n * Handles types like \"A | B | B\"  \"A | B\" and \"null | null\"  \"null\".\n * Only splits on top-level | (not inside {} () [] <> or string literals).\n */\nexport function dedupeUnionType(unionType: string): string {\n  const parts: string[] = [];\n  let current = '';\n  let depth = 0;\n  let quote = ''; // current open quote char, or '' if outside string\n  let escaped = false; // true if previous char was unescaped \\ inside string\n\n  for (const c of unionType) {\n    if (!escaped && (c === \"'\" || c === '\"')) {\n      if (!quote) quote = c;\n      else if (quote === c) quote = '';\n    }\n\n    if (!quote) {\n      if ('{([<'.includes(c)) depth++;\n      if ('})]>'.includes(c)) depth--;\n      if (c === '|' && depth === 0) {\n        parts.push(current.trim());\n        current = '';\n        continue;\n      }\n    }\n    current += c;\n    escaped = !!quote && !escaped && c === '\\\\';\n  }\n  if (current.trim()) parts.push(current.trim());\n\n  return [...new Set(parts)].join(' | ');\n}\n","import type { Tsconfig } from '../types';\n\nexport function isSyntheticDefaultImportsAllow(config?: Tsconfig) {\n  if (!config) {\n    return true;\n  }\n\n  return !!(\n    config.compilerOptions?.allowSyntheticDefaultImports ??\n    config.compilerOptions?.esModuleInterop\n  );\n}\n","import { keyword } from 'esutils';\n\nimport {\n  EnumGeneration,\n  NamingConvention,\n  type OpenApiSchemaObject,\n} from '../types';\nimport {\n  conventionName,\n  escape,\n  isNumeric,\n  isString,\n  jsStringEscape,\n  sanitize,\n} from '../utils';\n\nexport function getEnumNames(schemaObject: OpenApiSchemaObject | undefined) {\n  const names =\n    schemaObject?.['x-enumNames'] ??\n    schemaObject?.['x-enumnames'] ??\n    schemaObject?.['x-enum-varnames'];\n\n  if (!names) return;\n\n  return (names as string[]).map((name: string) => jsStringEscape(name));\n}\n\nexport function getEnumDescriptions(\n  schemaObject: OpenApiSchemaObject | undefined,\n) {\n  const descriptions =\n    schemaObject?.['x-enumDescriptions'] ??\n    schemaObject?.['x-enumdescriptions'] ??\n    schemaObject?.['x-enum-descriptions'];\n\n  if (!descriptions) return;\n\n  return (descriptions as string[]).map((description: string) =>\n    jsStringEscape(description),\n  );\n}\n\nexport function getEnum(\n  value: string,\n  enumName: string,\n  names: string[] | undefined,\n  enumGenerationType: EnumGeneration,\n  descriptions?: string[],\n  enumNamingConvention?: NamingConvention,\n) {\n  if (enumGenerationType === EnumGeneration.CONST)\n    return getTypeConstEnum(\n      value,\n      enumName,\n      names,\n      descriptions,\n      enumNamingConvention,\n    );\n  if (enumGenerationType === EnumGeneration.ENUM)\n    return getNativeEnum(value, enumName, names, enumNamingConvention);\n  if (enumGenerationType === EnumGeneration.UNION)\n    return getUnion(value, enumName);\n  throw new Error(`Invalid enumGenerationType: ${enumGenerationType}`);\n}\n\nconst getTypeConstEnum = (\n  value: string,\n  enumName: string,\n  names?: string[],\n  descriptions?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  let enumValue = `export type ${enumName} = typeof ${enumName}[keyof typeof ${enumName}]`;\n\n  if (value.endsWith(' | null')) {\n    value = value.replace(' | null', '');\n    enumValue += ' | null';\n  }\n\n  enumValue += ';\\n';\n\n  const implementation = getEnumImplementation(\n    value,\n    names,\n    descriptions,\n    enumNamingConvention,\n  );\n\n  enumValue += '\\n\\n';\n\n  enumValue += `export const ${enumName} = {\\n${implementation}} as const;\\n`;\n\n  return enumValue;\n};\n\nexport function getEnumImplementation(\n  value: string,\n  names?: string[],\n  descriptions?: string[],\n  enumNamingConvention?: NamingConvention,\n) {\n  // empty enum or null-only enum\n  if (value === '') return '';\n\n  return [...new Set(value.split(' | '))].reduce((acc, val, index) => {\n    const name = names?.[index];\n    const description = descriptions?.[index];\n    const comment = description ? `  /** ${description} */\\n` : '';\n\n    if (name) {\n      return (\n        acc +\n        comment +\n        `  ${keyword.isIdentifierNameES5(name) ? name : `'${name}'`}: ${val},\\n`\n      );\n    }\n\n    let key = val.startsWith(\"'\") ? val.slice(1, -1) : val;\n\n    const isNumber = isNumeric(key);\n\n    if (isNumber) {\n      key = toNumberKey(key);\n    }\n\n    if (key.length > 1) {\n      key = sanitize(key, {\n        whitespace: '_',\n        underscore: true,\n        dash: true,\n        special: true,\n      });\n    }\n\n    if (enumNamingConvention) {\n      key = conventionName(key, enumNamingConvention);\n    }\n\n    return (\n      acc +\n      comment +\n      `  ${keyword.isIdentifierNameES5(key) ? key : `'${key}'`}: ${val},\\n`\n    );\n  }, '');\n}\n\nconst getNativeEnum = (\n  value: string,\n  enumName: string,\n  names?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  const enumItems = getNativeEnumItems(value, names, enumNamingConvention);\n  const enumValue = `export enum ${enumName} {\\n${enumItems}\\n}`;\n\n  return enumValue;\n};\n\nconst getNativeEnumItems = (\n  value: string,\n  names?: string[],\n  enumNamingConvention?: NamingConvention,\n) => {\n  if (value === '') return '';\n\n  return [...new Set(value.split(' | '))].reduce((acc, val, index) => {\n    const name = names?.[index];\n    if (name) {\n      return (\n        acc +\n        `  ${keyword.isIdentifierNameES5(name) ? name : `'${name}'`}= ${val},\\n`\n      );\n    }\n\n    let key = val.startsWith(\"'\") ? val.slice(1, -1) : val;\n\n    const isNumber = isNumeric(key);\n\n    if (isNumber) {\n      key = toNumberKey(key);\n    }\n\n    if (key.length > 1) {\n      key = sanitize(key, {\n        whitespace: '_',\n        underscore: true,\n        dash: true,\n        special: true,\n      });\n    }\n\n    if (enumNamingConvention) {\n      key = conventionName(key, enumNamingConvention);\n    }\n\n    return (\n      acc +\n      `  ${keyword.isIdentifierNameES5(key) ? key : `'${key}'`}= ${val},\\n`\n    );\n  }, '');\n};\n\nconst toNumberKey = (value: string) => {\n  if (value.startsWith('-')) {\n    return `NUMBER_MINUS_${value.slice(1)}`;\n  }\n  if (value.startsWith('+')) {\n    return `NUMBER_PLUS_${value.slice(1)}`;\n  }\n  return `NUMBER_${value}`;\n};\n\nconst getUnion = (value: string, enumName: string) => {\n  return `export type ${enumName} = ${value};`;\n};\n\ntype CombinedEnumInput = {\n  value: string;\n  isRef: boolean;\n  schema: OpenApiSchemaObject | undefined;\n};\n\ntype CombinedEnumValue = {\n  value: string;\n  valueImports: string[];\n  hasNull: boolean;\n};\n\nexport function getEnumUnionFromSchema(\n  schema: OpenApiSchemaObject | undefined,\n) {\n  if (!schema?.enum) return '';\n  return schema.enum\n    .filter((val) => val !== null)\n    .map((val) => (isString(val) ? `'${escape(val)}'` : `${val}`))\n    .join(' | ');\n}\n\nconst stripNullUnion = (value: string) =>\n  value.replace(/\\s*\\|\\s*null/g, '').trim();\n\nconst isSpreadableEnumRef = (\n  schema: OpenApiSchemaObject | undefined,\n  refName: string,\n) => {\n  if (!schema?.enum || !refName) return false;\n  if (!getEnumUnionFromSchema(schema)) return false;\n  const type = schema.type;\n  if (type === 'boolean' || (Array.isArray(type) && type.includes('boolean'))) {\n    return false;\n  }\n  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(refName);\n};\n\nconst buildInlineEnum = (\n  schema: OpenApiSchemaObject | undefined,\n  enumValue?: string,\n) => {\n  const names = getEnumNames(schema);\n  const descriptions = getEnumDescriptions(schema);\n  const unionValue = enumValue ?? getEnumUnionFromSchema(schema);\n  return getEnumImplementation(unionValue, names, descriptions);\n};\n\nexport function getCombinedEnumValue(\n  inputs: CombinedEnumInput[],\n): CombinedEnumValue {\n  const valueImports: string[] = [];\n  const hasNull = inputs.some((input) => {\n    if (input.value.includes('| null')) return true;\n    const schema = input.schema;\n    if (!schema) return false;\n    if (schema.nullable === true) return true;\n    if (Array.isArray(schema.type) && schema.type.includes('null')) return true;\n    return schema.enum?.includes(null) ?? false;\n  });\n\n  const addValueImport = (name: string) => {\n    if (!valueImports.includes(name)) {\n      valueImports.push(name);\n    }\n  };\n\n  if (inputs.length === 1) {\n    const input = inputs[0];\n    if (input.isRef) {\n      const refName = stripNullUnion(input.value);\n      if (isSpreadableEnumRef(input.schema, refName)) {\n        addValueImport(refName);\n        return { value: refName, valueImports, hasNull };\n      }\n      return {\n        value: `{${buildInlineEnum(input.schema)}} as const`,\n        valueImports,\n        hasNull,\n      };\n    }\n\n    return {\n      value: `{${buildInlineEnum(input.schema, stripNullUnion(input.value))}} as const`,\n      valueImports,\n      hasNull,\n    };\n  }\n\n  const enums = inputs\n    .map((input) => {\n      if (input.isRef) {\n        const refName = stripNullUnion(input.value);\n        if (isSpreadableEnumRef(input.schema, refName)) {\n          addValueImport(refName);\n          return `...${refName},`;\n        }\n        return buildInlineEnum(input.schema);\n      }\n\n      return buildInlineEnum(input.schema, stripNullUnion(input.value));\n    })\n    .join('');\n\n  return { value: `{${enums}} as const`, valueImports, hasNull };\n}\n","import type { ContextSpec, NormalizedOverrideOutput } from '../types';\nimport { getFileInfo, isUrl, pascal, sanitize, upath } from '../utils';\n\ntype RefComponent = 'schemas' | 'responses' | 'parameters' | 'requestBodies';\n\nconst RefComponent = {\n  schemas: 'schemas' as RefComponent,\n  responses: 'responses' as RefComponent,\n  parameters: 'parameters' as RefComponent,\n  requestBodies: 'requestBodies' as RefComponent,\n};\n\nexport const RefComponentSuffix: Record<RefComponent, string> = {\n  schemas: '',\n  responses: 'Response',\n  parameters: 'Parameter',\n  requestBodies: 'Body',\n};\n\nconst regex = new RegExp('~1', 'g');\n\nconst resolveUrl = (from: string, to: string): string => {\n  const resolvedUrl = new URL(to, new URL(from, 'resolve://'));\n  if (resolvedUrl.protocol === 'resolve:') {\n    // `from` is a relative URL.\n    const { pathname, search, hash } = resolvedUrl;\n    return pathname + search + hash;\n  }\n  return resolvedUrl.toString();\n};\n\nexport interface RefInfo {\n  name: string;\n  originalName: string;\n  refPaths?: string[];\n}\n/**\n * Return the output type from the $ref\n *\n * @param $ref\n */\nexport function getRefInfo($ref: string, context: ContextSpec): RefInfo {\n  const [pathname, ref] = $ref.split('#');\n\n  const refPaths = ref\n    .slice(1)\n    .split('/')\n    .map((part) => decodeURIComponent(part.replaceAll(regex, '/')));\n\n  const getOverrideSuffix = (\n    override: NormalizedOverrideOutput,\n    paths: string[],\n  ) => {\n    const firstLevel = override[paths[0] as keyof NormalizedOverrideOutput];\n    if (!firstLevel) return '';\n\n    const secondLevel = (firstLevel as Record<string, { suffix?: string }>)[\n      paths[1]\n    ];\n    return secondLevel?.suffix ?? '';\n  };\n\n  const suffix = getOverrideSuffix(context.output.override, refPaths);\n\n  const originalName = ref\n    ? refPaths[refPaths.length - 1]\n    : upath.getSchemaFileName(pathname);\n\n  if (!pathname) {\n    return {\n      name: sanitize(pascal(originalName) + suffix, {\n        es5keyword: true,\n        es5IdentifierName: true,\n        underscore: true,\n        dash: true,\n      }),\n      originalName,\n      refPaths,\n    };\n  }\n\n  return {\n    name: sanitize(pascal(originalName) + suffix, {\n      es5keyword: true,\n      es5IdentifierName: true,\n      underscore: true,\n      dash: true,\n    }),\n    originalName,\n    refPaths,\n  };\n}\n","import { isDereferenced } from '@scalar/openapi-types/helpers';\nimport { prop } from 'remeda';\n\nimport { getRefInfo, type RefInfo } from '../getters/ref';\nimport type {\n  ContextSpec,\n  GeneratorImport,\n  OpenApiComponentsObject,\n  OpenApiExampleObject,\n  OpenApiReferenceObject,\n  OpenApiSchemaObject,\n} from '../types';\nimport { isReference } from '../utils';\n\nexport function resolveRef<\n  TSchema extends OpenApiComponentsObject = OpenApiComponentsObject,\n>(\n  schema: OpenApiComponentsObject,\n  context: ContextSpec,\n  imports: GeneratorImport[] = [],\n): {\n  schema: TSchema;\n  imports: GeneratorImport[];\n} {\n  // the schema is referring to another object\n  if ('schema' in schema && schema.schema?.$ref) {\n    const resolvedRef = resolveRef<TSchema>(schema.schema, context, imports);\n    if ('examples' in schema) {\n      schema.examples = resolveExampleRefs(schema.examples, context);\n    }\n    if ('examples' in resolvedRef.schema) {\n      resolvedRef.schema.examples = resolveExampleRefs(\n        resolvedRef.schema.examples,\n        context,\n      );\n    }\n    return {\n      schema: {\n        ...schema,\n        schema: resolvedRef.schema,\n      } as TSchema,\n      imports,\n    };\n  }\n\n  if (isDereferenced(schema)) {\n    if ('examples' in schema) {\n      schema.examples = resolveExampleRefs(schema.examples, context);\n    }\n    return { schema: schema as TSchema, imports };\n  }\n\n  const {\n    currentSchema,\n    refInfo: { name, originalName },\n  } = getSchema(schema, context);\n\n  if (!currentSchema) {\n    throw new Error(`Oops... . Ref not found: ${schema.$ref}`);\n  }\n\n  return resolveRef<TSchema>(currentSchema, { ...context }, [\n    ...imports,\n    { name, schemaName: originalName },\n  ]);\n}\n\nfunction getSchema<\n  TSchema extends OpenApiComponentsObject = OpenApiComponentsObject,\n>(\n  schema: OpenApiReferenceObject,\n  context: ContextSpec,\n): {\n  refInfo: RefInfo;\n  currentSchema: TSchema | undefined;\n} {\n  const refInfo = getRefInfo(schema.$ref, context);\n\n  const { refPaths } = refInfo;\n\n  let schemaByRefPaths = Array.isArray(refPaths)\n    ? (prop(\n        context.spec,\n        // @ts-expect-error: [ts2556] refPaths are not guaranteed to be valid keys of the spec\n        ...refPaths,\n      ) as OpenApiSchemaObject | OpenApiReferenceObject)\n    : undefined;\n\n  if (!schemaByRefPaths) {\n    schemaByRefPaths = context.spec;\n  }\n\n  if (isReference(schemaByRefPaths)) {\n    return getSchema(schemaByRefPaths, context);\n  }\n\n  let currentSchema = schemaByRefPaths ? schemaByRefPaths : context.spec;\n\n  // Handle OpenAPI 3.0 nullable property\n  if ('nullable' in schema) {\n    currentSchema = { ...currentSchema, nullable: schema.nullable };\n  }\n\n  // Handle OpenAPI 3.1 type array (e.g., type: [\"object\", \"null\"])\n  // This preserves nullable information when using direct $ref with types array\n  if ('type' in schema && Array.isArray(schema.type)) {\n    currentSchema = { ...currentSchema, type: schema.type };\n  }\n\n  return {\n    currentSchema,\n    refInfo,\n  };\n}\n\ntype Example = OpenApiExampleObject | OpenApiReferenceObject;\ntype Examples = Example[] | Record<string, Example> | undefined;\nexport function resolveExampleRefs(\n  examples: Examples,\n  context: ContextSpec,\n): Examples {\n  if (!examples) {\n    return undefined;\n  }\n  return Array.isArray(examples)\n    ? examples.map((example) => {\n        if (isReference(example)) {\n          const { schema } = resolveRef<OpenApiExampleObject>(example, context);\n          return schema.value;\n        }\n        return example;\n      })\n    : Object.entries(examples).reduce((acc, [key, example]) => {\n        let schema = example;\n        if (isReference(example)) {\n          schema = resolveRef<OpenApiExampleObject>(example, context).schema\n            .value;\n        }\n        return {\n          ...acc,\n          [key]: schema,\n        };\n      }, {});\n}\n","import { getScalar } from '../getters';\nimport type { FormDataContext } from '../getters/object';\nimport type {\n  ContextSpec,\n  OpenApiReferenceObject,\n  OpenApiSchemaObject,\n  ResolverValue,\n  SchemaType,\n} from '../types';\nimport { isReference } from '../utils';\nimport { resolveRef } from './ref';\n\ninterface ResolveValueOptions {\n  schema: OpenApiSchemaObject | OpenApiReferenceObject;\n  name?: string;\n  context: ContextSpec;\n  formDataContext?: FormDataContext;\n}\n\nexport function resolveValue({\n  schema,\n  name,\n  context,\n  formDataContext,\n}: ResolveValueOptions): ResolverValue {\n  if (isReference(schema)) {\n    const { schema: schemaObject, imports } = resolveRef<OpenApiSchemaObject>(\n      schema,\n      context,\n    );\n\n    const resolvedImport = imports[0];\n\n    let hasReadonlyProps = false;\n\n    // Avoid infinite loop - use resolvedImport.name for tracking since name may be undefined\n    const refName = resolvedImport.name;\n    if (!context.parents?.includes(refName)) {\n      const scalar = getScalar({\n        item: schemaObject,\n        name: refName,\n        context: {\n          ...context,\n          parents: [...(context.parents ?? []), refName],\n        },\n      });\n\n      hasReadonlyProps = scalar.hasReadonlyProps;\n    }\n\n    const nullable =\n      (Array.isArray(schemaObject.type) &&\n        schemaObject.type.includes('null')) ||\n      schemaObject.nullable === true\n        ? ' | null'\n        : '';\n\n    return {\n      value: resolvedImport.name + nullable,\n      imports: [\n        {\n          name: resolvedImport.name,\n          schemaName: resolvedImport.schemaName,\n        },\n      ],\n      type: (schemaObject.type as SchemaType | undefined) ?? 'object',\n      schemas: [],\n      isEnum: !!schemaObject.enum,\n      originalSchema: schemaObject,\n      hasReadonlyProps,\n      isRef: true,\n      dependencies: [resolvedImport.name],\n    };\n  }\n\n  const scalar = getScalar({\n    item: schema,\n    name,\n    context,\n    formDataContext,\n  });\n\n  return {\n    ...scalar,\n    originalSchema: schema,\n    isRef: false,\n  };\n}\n","import { getEnum, getEnumDescriptions, getEnumNames } from '../getters/enum';\nimport type { FormDataContext } from '../getters/object';\nimport type {\n  ContextSpec,\n  OpenApiReferenceObject,\n  OpenApiSchemaObject,\n  ResolverValue,\n  ScalarValue,\n} from '../types';\nimport { jsDoc } from '../utils';\nimport { resolveValue } from './value';\n\ninterface ResolveOptions {\n  schema: OpenApiSchemaObject | OpenApiReferenceObject;\n  propName?: string;\n  combined?: boolean;\n  context: ContextSpec;\n  formDataContext?: FormDataContext;\n}\n\ninterface CreateTypeAliasOptions {\n  resolvedValue: ResolverValue;\n  propName: string | undefined;\n  context: ContextSpec;\n}\n\n/**\n * Wraps inline object type in a type alias.\n * E.g. `{ foo: string }`  value becomes `FooBody`, schema gets `export type FooBody = { foo: string };`\n */\nexport function createTypeAliasIfNeeded({\n  resolvedValue,\n  propName,\n  context,\n}: CreateTypeAliasOptions): ScalarValue | undefined {\n  if (!propName) {\n    return undefined;\n  }\n\n  if (resolvedValue.isEnum || resolvedValue.type !== 'object') {\n    return undefined;\n  }\n\n  // aliasCombinedTypes (v7 compat): match '|' and '&' so 'string | number' creates named type\n  // v8 default: only match '{' so combined primitives are inlined\n  const aliasPattern = context.output.override.aliasCombinedTypes\n    ? '{|&|\\\\|'\n    : '{';\n  if (!new RegExp(aliasPattern).test(resolvedValue.value)) {\n    return undefined;\n  }\n\n  const { originalSchema } = resolvedValue;\n  const doc = jsDoc(originalSchema);\n  const isConstant = 'const' in originalSchema;\n  const constantIsString =\n    'type' in originalSchema &&\n    (originalSchema.type === 'string' ||\n      (Array.isArray(originalSchema.type) &&\n        originalSchema.type.includes('string')));\n\n  const model = isConstant\n    ? `${doc}export const ${propName} = ${constantIsString ? `'${originalSchema.const}'` : originalSchema.const} as const;\\n`\n    : `${doc}export type ${propName} = ${resolvedValue.value};\\n`;\n\n  return {\n    value: propName,\n    imports: [{ name: propName, isConstant }],\n    schemas: [\n      ...resolvedValue.schemas,\n      {\n        name: propName,\n        model,\n        imports: resolvedValue.imports,\n        dependencies: resolvedValue.dependencies,\n      },\n    ],\n    isEnum: false,\n    type: 'object',\n    isRef: resolvedValue.isRef,\n    hasReadonlyProps: resolvedValue.hasReadonlyProps,\n    dependencies: resolvedValue.dependencies,\n  };\n}\n\nfunction resolveObjectOriginal({\n  schema,\n  propName,\n  combined = false,\n  context,\n  formDataContext,\n}: ResolveOptions): ResolverValue {\n  const resolvedValue = resolveValue({\n    schema,\n    name: propName,\n    context,\n    formDataContext,\n  });\n\n  // Try to create a type alias for object types\n  const aliased = createTypeAliasIfNeeded({\n    resolvedValue,\n    propName,\n    context,\n  });\n  if (aliased) {\n    return {\n      ...aliased,\n      originalSchema: resolvedValue.originalSchema,\n    };\n  }\n\n  if (propName && resolvedValue.isEnum && !combined && !resolvedValue.isRef) {\n    const doc = jsDoc(resolvedValue.originalSchema ?? {});\n    const enumValue = getEnum(\n      resolvedValue.value,\n      propName,\n      getEnumNames(resolvedValue.originalSchema),\n      context.output.override.enumGenerationType,\n      getEnumDescriptions(resolvedValue.originalSchema),\n      context.output.override.namingConvention?.enum,\n    );\n\n    return {\n      value: propName,\n      imports: [{ name: propName }],\n      schemas: [\n        ...resolvedValue.schemas,\n        {\n          name: propName,\n          model: doc + enumValue,\n          imports: resolvedValue.imports,\n          dependencies: resolvedValue.dependencies,\n        },\n      ],\n      isEnum: false,\n      type: 'enum',\n      originalSchema: resolvedValue.originalSchema,\n      isRef: resolvedValue.isRef,\n      hasReadonlyProps: resolvedValue.hasReadonlyProps,\n      dependencies: [...resolvedValue.dependencies, propName],\n    };\n  }\n\n  return resolvedValue;\n}\n\nconst resolveObjectCacheMap = new Map<string, ResolverValue>();\n\nexport function resolveObject({\n  schema,\n  propName,\n  combined = false,\n  context,\n  formDataContext,\n}: ResolveOptions): ResolverValue {\n  const hashKey = JSON.stringify({\n    schema,\n    propName,\n    combined,\n    projectName: context.projectName ?? context.output.target,\n    formDataContext,\n  });\n\n  if (resolveObjectCacheMap.has(hashKey)) {\n    // .has(...) guarantees existence\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return resolveObjectCacheMap.get(hashKey)!;\n  }\n\n  const result = resolveObjectOriginal({\n    schema,\n    propName,\n    combined,\n    context,\n    formDataContext,\n  });\n\n  resolveObjectCacheMap.set(hashKey, result);\n\n  return result;\n}\n","import { resolveExampleRefs } from '../resolvers';\nimport { resolveObject } from '../resolvers/object';\nimport type {\n  ContextSpec,\n  OpenApiReferenceObject,\n  OpenApiSchemaObject,\n  ScalarValue,\n} from '../types';\nimport { compareVersions } from '../utils';\nimport type { FormDataContext } from './object';\n\ninterface GetArrayOptions {\n  schema: OpenApiSchemaObject;\n  name?: string;\n  context: ContextSpec;\n  formDataContext?: FormDataContext;\n}\n\n/**\n * Return the output type from an array\n *\n * @param item item with type === \"array\"\n */\nexport function getArray({\n  schema,\n  name,\n  context,\n  formDataContext,\n}: GetArrayOptions): ScalarValue {\n  const schema31 = schema as OpenApiSchemaObject;\n  const itemSuffix = context.output.override.components.schemas.itemSuffix;\n  if (schema31.prefixItems) {\n    const resolvedObjects = schema31.prefixItems.map((item, index) =>\n      resolveObject({\n        schema: item as OpenApiSchemaObject | OpenApiReferenceObject,\n        propName: name ? name + itemSuffix + index : undefined,\n        context,\n      }),\n    );\n    if (schema31.items) {\n      const additional = resolveObject({\n        schema: schema31.items as OpenApiSchemaObject | OpenApiReferenceObject,\n        propName: name ? name + itemSuffix + 'Additional' : undefined,\n        context,\n      });\n      resolvedObjects.push({\n        ...additional,\n        value: `...${additional.value}[]`,\n      });\n    }\n    return {\n      type: 'array',\n      isEnum: false,\n      isRef: false,\n      value: `[${resolvedObjects.map((o) => o.value).join(', ')}]`,\n      imports: resolvedObjects.flatMap((o) => o.imports),\n      schemas: resolvedObjects.flatMap((o) => o.schemas),\n      dependencies: resolvedObjects.flatMap((o) => o.dependencies),\n      hasReadonlyProps: resolvedObjects.some((o) => o.hasReadonlyProps),\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n    };\n  }\n  if (schema.items) {\n    const resolvedObject = resolveObject({\n      schema: schema.items,\n      propName: name ? name + itemSuffix : undefined,\n      context,\n      formDataContext,\n    });\n    return {\n      value: `${\n        schema.readOnly === true &&\n        !context.output.override.suppressReadonlyModifier\n          ? 'readonly '\n          : ''\n      }${\n        resolvedObject.value.includes('|')\n          ? `(${resolvedObject.value})[]`\n          : `${resolvedObject.value}[]`\n      }`,\n      imports: resolvedObject.imports,\n      schemas: resolvedObject.schemas,\n      dependencies: resolvedObject.dependencies,\n      isEnum: false,\n      type: 'array',\n      isRef: false,\n      hasReadonlyProps: resolvedObject.hasReadonlyProps,\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n    };\n  } else if (compareVersions(context.spec.openapi, '3.1', '>=')) {\n    return {\n      value: 'unknown[]',\n      imports: [],\n      schemas: [],\n      dependencies: [],\n      isEnum: false,\n      type: 'array',\n      isRef: false,\n      hasReadonlyProps: false,\n    };\n  } else {\n    throw new Error(\n      `All arrays must have an \\`items\\` key defined (name=${name}, schema=${JSON.stringify(schema)})`,\n    );\n  }\n}\n","import { keyword } from 'esutils';\nimport { uniqueBy } from 'remeda';\n\nimport { resolveObject } from '../resolvers/object';\nimport { resolveExampleRefs, resolveRef } from '../resolvers/ref';\nimport {\n  type ContextSpec,\n  FormDataArrayHandling,\n  type GeneratorImport,\n  type OpenApiEncodingObject,\n  type OpenApiMediaTypeObject,\n  type OpenApiReferenceObject,\n  type OpenApiRequestBodyObject,\n  type OpenApiResponseObject,\n  type OpenApiSchemaObject,\n  type ResReqTypesValue,\n} from '../types';\nimport { camel } from '../utils';\nimport { isReference } from '../utils/assertion';\nimport { pascal } from '../utils/case';\nimport {\n  getFormDataFieldFileType,\n  isBinaryContentType,\n} from '../utils/content-type';\nimport { getNumberWord } from '../utils/string';\nimport type { FormDataContext } from './object';\n\nconst formDataContentTypes = new Set(['multipart/form-data']);\n\nconst formUrlEncodedContentTypes = new Set([\n  'application/x-www-form-urlencoded',\n]);\n\ninterface GetResReqContentTypesOptions {\n  mediaType: OpenApiMediaTypeObject;\n  propName?: string;\n  context: ContextSpec;\n  isFormData?: boolean;\n  contentType: string;\n}\n\nfunction getResReqContentTypes({\n  mediaType,\n  propName,\n  context,\n  isFormData,\n  contentType,\n}: GetResReqContentTypesOptions) {\n  if (!mediaType.schema) {\n    return;\n  }\n\n  // For form-data, pass context that tracks encoding for file type detection\n  const formDataContext: FormDataContext | undefined = isFormData\n    ? { atPart: false, encoding: mediaType.encoding ?? {} }\n    : undefined;\n\n  const resolvedObject = resolveObject({\n    schema: mediaType.schema,\n    propName,\n    context,\n    formDataContext,\n  });\n\n  // Media key has highest precedence: binary media key  Blob (overrides schema)\n  if (!isFormData && isBinaryContentType(contentType)) {\n    return {\n      ...resolvedObject,\n      value: 'Blob',\n    };\n  }\n\n  return resolvedObject;\n}\n\nexport function getResReqTypes(\n  responsesOrRequests: [\n    string,\n    OpenApiReferenceObject | OpenApiResponseObject | OpenApiRequestBodyObject,\n  ][],\n  name: string,\n  context: ContextSpec,\n  defaultType = 'unknown',\n  uniqueKey: (\n    item: ResReqTypesValue,\n    index: number,\n    data: ResReqTypesValue[],\n  ) => unknown = (item) => item.value,\n): ResReqTypesValue[] {\n  const typesArray = responsesOrRequests\n    .filter(([_, res]) => Boolean(res))\n    .map(([key, res]) => {\n      if (isReference(res)) {\n        const {\n          schema: bodySchema,\n          imports: [{ name, schemaName }],\n        } = resolveRef<OpenApiRequestBodyObject | OpenApiResponseObject>(\n          res,\n          context,\n        );\n\n        const [contentType, mediaType] =\n          Object.entries(bodySchema.content ?? {})[0] ?? [];\n\n        const isFormData = formDataContentTypes.has(contentType);\n        const isFormUrlEncoded = formUrlEncodedContentTypes.has(contentType);\n\n        if ((!isFormData && !isFormUrlEncoded) || !mediaType.schema) {\n          return [\n            {\n              value: name,\n              imports: [{ name, schemaName }],\n              schemas: [],\n              type: 'unknown',\n              isEnum: false,\n              isRef: true,\n              hasReadonlyProps: false,\n              originalSchema: mediaType?.schema,\n              example: mediaType?.example,\n              examples: resolveExampleRefs(mediaType?.examples, context),\n              key,\n              contentType,\n            },\n          ] as ResReqTypesValue[];\n        }\n\n        const formData = isFormData\n          ? getSchemaFormDataAndUrlEncoded({\n              name,\n              schemaObject: mediaType.schema,\n              context,\n              isRequestBodyOptional:\n                // Even though required is false by default, we only consider required to be false if specified. (See pull 1277)\n                'required' in bodySchema && bodySchema.required === false,\n              isRef: true,\n              encoding: mediaType.encoding,\n            })\n          : undefined;\n\n        const formUrlEncoded = isFormUrlEncoded\n          ? getSchemaFormDataAndUrlEncoded({\n              name,\n              schemaObject: mediaType.schema,\n              context,\n              isRequestBodyOptional:\n                'required' in bodySchema && bodySchema.required === false,\n              isUrlEncoded: true,\n              isRef: true,\n              encoding: mediaType.encoding,\n            })\n          : undefined;\n\n        const additionalImports = getFormDataAdditionalImports({\n          schemaObject: mediaType.schema,\n          context,\n        });\n\n        return [\n          {\n            value: name,\n            imports: [{ name, schemaName }, ...additionalImports],\n            schemas: [],\n            type: 'unknown',\n            isEnum: false,\n            hasReadonlyProps: false,\n            formData,\n            formUrlEncoded,\n            isRef: true,\n            originalSchema: mediaType.schema,\n            example: mediaType.example,\n            examples: resolveExampleRefs(mediaType.examples, context),\n            key,\n            contentType,\n          },\n        ] as ResReqTypesValue[];\n      }\n\n      if (res.content) {\n        const contents = Object.entries(res.content).map(\n          ([contentType, mediaType], index, arr) => {\n            let propName = key ? pascal(name) + pascal(key) : undefined;\n\n            if (propName && arr.length > 1) {\n              propName = propName + pascal(getNumberWord(index + 1));\n            }\n\n            // When schema is a $ref, use schema name for consistent param naming\n            let effectivePropName = propName;\n            if (mediaType.schema && isReference(mediaType.schema)) {\n              const { imports } = resolveRef<OpenApiSchemaObject>(\n                mediaType.schema,\n                context,\n              );\n              if (imports[0]?.name) {\n                effectivePropName = imports[0].name;\n              }\n            }\n\n            const isFormData = formDataContentTypes.has(contentType);\n\n            const resolvedValue = getResReqContentTypes({\n              mediaType,\n              propName: effectivePropName,\n              context,\n              isFormData,\n              contentType,\n            });\n\n            if (!resolvedValue) {\n              // openapi spec 3.1 allows describing binary responses with only a content type\n              if (isBinaryContentType(contentType)) {\n                return {\n                  value: 'Blob',\n                  imports: [],\n                  schemas: [],\n                  type: 'Blob',\n                  isEnum: false,\n                  key,\n                  isRef: false,\n                  hasReadonlyProps: false,\n                  contentType,\n                };\n              }\n\n              return;\n            }\n\n            const isFormUrlEncoded =\n              formUrlEncodedContentTypes.has(contentType);\n\n            if ((!isFormData && !isFormUrlEncoded) || !effectivePropName) {\n              return {\n                ...resolvedValue,\n                imports: resolvedValue.imports,\n                contentType,\n                example: mediaType.example,\n                examples: resolveExampleRefs(mediaType.examples, context),\n              };\n            }\n\n            const formData = isFormData\n              ? getSchemaFormDataAndUrlEncoded({\n                  name: effectivePropName,\n                  schemaObject: mediaType.schema!,\n                  context,\n                  isRequestBodyOptional:\n                    'required' in res && res.required === false,\n                  isRef: true,\n                  encoding: mediaType.encoding,\n                })\n              : undefined;\n\n            const formUrlEncoded = isFormUrlEncoded\n              ? getSchemaFormDataAndUrlEncoded({\n                  name: effectivePropName,\n                  schemaObject: mediaType.schema!,\n                  context,\n                  isUrlEncoded: true,\n                  isRequestBodyOptional:\n                    'required' in res && res.required === false,\n                  isRef: true,\n                  encoding: mediaType.encoding,\n                })\n              : undefined;\n\n            const additionalImports = getFormDataAdditionalImports({\n              schemaObject: mediaType.schema!,\n              context,\n            });\n            return {\n              ...resolvedValue,\n              imports: [...resolvedValue.imports, ...additionalImports],\n              formData,\n              formUrlEncoded,\n              contentType,\n              example: mediaType.example,\n              examples: resolveExampleRefs(mediaType.examples, context),\n            };\n          },\n        );\n\n        return contents\n          .filter(Boolean)\n          .map((x) => ({ ...x, key })) as ResReqTypesValue[];\n      }\n      const swaggerSchema =\n        'schema' in res\n          ? (\n              res as {\n                schema?: OpenApiSchemaObject | OpenApiReferenceObject;\n              }\n            ).schema\n          : undefined;\n\n      if (swaggerSchema) {\n        const propName = key ? pascal(name) + pascal(key) : undefined;\n        const resolvedValue = resolveObject({\n          schema: swaggerSchema,\n          propName,\n          context,\n        });\n\n        return [\n          {\n            ...resolvedValue,\n            contentType: 'application/json',\n            key,\n          },\n        ] as ResReqTypesValue[];\n      }\n\n      return [\n        {\n          value: defaultType,\n          imports: [],\n          schemas: [],\n          type: defaultType,\n          isEnum: false,\n          key,\n          isRef: false,\n          hasReadonlyProps: false,\n          contentType: 'application/json',\n        },\n      ] as ResReqTypesValue[];\n    });\n\n  return uniqueBy(typesArray.flat(), uniqueKey);\n}\n\n/**\n * Response type categories for HTTP client response parsing.\n * Maps to Angular HttpClient's responseType, Axios responseType, and Fetch response methods.\n */\nexport type ResponseTypeCategory = 'json' | 'text' | 'blob' | 'arraybuffer';\n\n/**\n * Determine the response type category for a given content type.\n * Used to set the correct responseType option in HTTP clients.\n *\n * @param contentType - The MIME content type (e.g., 'application/json', 'text/plain')\n * @returns The response type category to use for parsing\n */\nexport function getResponseTypeCategory(\n  contentType: string,\n): ResponseTypeCategory {\n  // Binary types  blob\n  if (isBinaryContentType(contentType)) {\n    return 'blob';\n  }\n\n  // JSON types\n  if (\n    contentType === 'application/json' ||\n    contentType.includes('+json') ||\n    contentType.includes('-json')\n  ) {\n    return 'json';\n  }\n\n  // Everything else is text (text/*, application/xml, etc.)\n  return 'text';\n}\n\n/**\n * Get the default content type from a list of content types.\n * Priority: application/json > any JSON-like type > first in list\n *\n * @param contentTypes - Array of content types from OpenAPI spec\n * @returns The default content type to use\n */\nexport function getDefaultContentType(contentTypes: string[]): string {\n  if (contentTypes.length === 0) {\n    return 'application/json';\n  }\n\n  // Prefer application/json\n  if (contentTypes.includes('application/json')) {\n    return 'application/json';\n  }\n\n  // Prefer any JSON-like type\n  const jsonType = contentTypes.find(\n    (ct) => ct.includes('+json') || ct.includes('-json'),\n  );\n  if (jsonType) {\n    return jsonType;\n  }\n\n  // Default to first\n  return contentTypes[0];\n}\n\ninterface GetFormDataAdditionalImportsOptions {\n  schemaObject: OpenApiSchemaObject | OpenApiReferenceObject;\n  context: ContextSpec;\n}\n\nfunction getFormDataAdditionalImports({\n  schemaObject,\n  context,\n}: GetFormDataAdditionalImportsOptions): GeneratorImport[] {\n  const { schema } = resolveRef<OpenApiSchemaObject>(schemaObject, context);\n\n  if (schema.type !== 'object') {\n    return [];\n  }\n\n  const combinedSchemas = schema.oneOf || schema.anyOf;\n\n  if (!combinedSchemas) {\n    return [];\n  }\n\n  return combinedSchemas\n    .map(\n      (schema) => resolveRef<OpenApiSchemaObject>(schema, context).imports[0],\n    )\n    .filter(Boolean);\n}\n\ninterface GetSchemaFormDataAndUrlEncodedOptions {\n  name: string;\n  schemaObject: OpenApiSchemaObject | OpenApiReferenceObject;\n  context: ContextSpec;\n  isRequestBodyOptional: boolean;\n  isUrlEncoded?: boolean;\n  isRef?: boolean;\n  encoding?: Record<string, OpenApiEncodingObject>;\n}\n\nfunction getSchemaFormDataAndUrlEncoded({\n  name,\n  schemaObject,\n  context,\n  isRequestBodyOptional,\n  isUrlEncoded,\n  isRef,\n  encoding,\n}: GetSchemaFormDataAndUrlEncodedOptions): string {\n  const { schema, imports } = resolveRef<OpenApiSchemaObject>(\n    schemaObject,\n    context,\n  );\n  const propName = camel(\n    !isRef && isReference(schemaObject) ? imports[0].name : name,\n  );\n  const additionalImports: GeneratorImport[] = [];\n\n  const variableName = isUrlEncoded ? 'formUrlEncoded' : 'formData';\n  let form = isUrlEncoded\n    ? `const ${variableName} = new URLSearchParams();\\n`\n    : `const ${variableName} = new FormData();\\n`;\n\n  const combinedSchemas = schema.oneOf || schema.anyOf || schema.allOf;\n  if (\n    schema.type === 'object' ||\n    (schema.type === undefined && combinedSchemas)\n  ) {\n    if (combinedSchemas) {\n      const shouldCast = !!schema.oneOf || !!schema.anyOf;\n\n      const combinedSchemasFormData = combinedSchemas!\n        .map((schema) => {\n          const { schema: combinedSchema, imports } =\n            resolveRef<OpenApiSchemaObject>(schema, context);\n\n          let newPropName = propName;\n          let newPropDefinition = '';\n\n          // If the schema is a union type (oneOf, anyOf) and includes a reference (has imports),\n          // we need to cast the property to the specific type to avoid TypeScript errors.\n          if (shouldCast && imports[0]) {\n            additionalImports.push(imports[0]);\n            newPropName = `${propName}${pascal(imports[0].name)}`;\n            newPropDefinition = `const ${newPropName} = (${propName} as ${imports[0].name}${isRequestBodyOptional ? ' | undefined' : ''});\\n`;\n          }\n\n          return (\n            newPropDefinition +\n            resolveSchemaPropertiesToFormData({\n              schema: combinedSchema,\n              variableName,\n              propName: newPropName,\n              context,\n              isRequestBodyOptional,\n              encoding,\n            })\n          );\n        })\n        .filter(Boolean)\n        .join('\\n');\n\n      form += combinedSchemasFormData;\n    }\n\n    if (schema.properties) {\n      const formDataValues = resolveSchemaPropertiesToFormData({\n        schema,\n        variableName,\n        propName,\n        context,\n        isRequestBodyOptional,\n        encoding,\n      });\n\n      form += formDataValues;\n    }\n\n    return form;\n  }\n\n  if (schema.type === 'array') {\n    let valueStr = 'value';\n    if (schema.items) {\n      const { schema: itemSchema } = resolveRef<OpenApiSchemaObject>(\n        schema.items,\n        context,\n      );\n      if (itemSchema.type === 'object' || itemSchema.type === 'array') {\n        valueStr = 'JSON.stringify(value)';\n      } else if (\n        itemSchema.type === 'number' ||\n        itemSchema.type === 'integer' ||\n        itemSchema.type === 'boolean'\n      ) {\n        valueStr = 'value.toString()';\n      }\n    }\n\n    return `${form}${propName}.forEach(value => ${variableName}.append('data', ${valueStr}))\\n`;\n  }\n\n  if (\n    schema.type === 'number' ||\n    schema.type === 'integer' ||\n    schema.type === 'boolean'\n  ) {\n    return `${form}${variableName}.append('data', ${propName}.toString())\\n`;\n  }\n\n  return `${form}${variableName}.append('data', ${propName})\\n`;\n}\n\ninterface ResolveSchemaPropertiesToFormDataOptions {\n  schema: OpenApiSchemaObject;\n  variableName: string;\n  propName: string;\n  context: ContextSpec;\n  isRequestBodyOptional: boolean;\n  keyPrefix?: string;\n  depth?: number;\n  encoding?: Record<string, OpenApiEncodingObject>;\n}\n\nfunction resolveSchemaPropertiesToFormData({\n  schema,\n  variableName,\n  propName,\n  context,\n  isRequestBodyOptional,\n  keyPrefix = '',\n  depth = 0,\n  encoding,\n}: ResolveSchemaPropertiesToFormDataOptions): string {\n  const formDataValues = Object.entries(schema.properties ?? {}).reduce(\n    (acc, [key, value]) => {\n      const { schema: property } = resolveRef<OpenApiSchemaObject>(\n        value,\n        context,\n      );\n\n      // Skip readOnly properties for formData\n      if (property.readOnly) {\n        return acc;\n      }\n\n      let formDataValue = '';\n\n      // Get encoding.contentType for this field (only at top level, depth === 0)\n      const fieldEncoding = depth === 0 ? encoding?.[key] : undefined;\n      const partContentType = fieldEncoding?.contentType;\n\n      const formattedKeyPrefix = isRequestBodyOptional\n        ? keyword.isIdentifierNameES5(key)\n          ? '?'\n          : '?.'\n        : '';\n      const formattedKey = keyword.isIdentifierNameES5(key)\n        ? `.${key}`\n        : `['${key}']`;\n\n      const valueKey = `${propName}${formattedKeyPrefix}${formattedKey}`;\n      const nonOptionalValueKey = `${propName}${formattedKey}`;\n\n      // Use shared file type detection (same logic as type generation)\n      const fileType = getFormDataFieldFileType(property, partContentType);\n      const effectiveContentType = partContentType ?? property.contentMediaType;\n\n      if (fileType === 'binary' || property.format === 'binary') {\n        // Binary: append directly (value is Blob)\n        formDataValue = `${variableName}.append(\\`${keyPrefix}${key}\\`, ${nonOptionalValueKey});\\n`;\n      } else if (fileType === 'text') {\n        // Text file: value is Blob | string, check at runtime\n        formDataValue = `${variableName}.append(\\`${keyPrefix}${key}\\`, ${nonOptionalValueKey} instanceof Blob ? ${nonOptionalValueKey} : new Blob([${nonOptionalValueKey}], { type: '${effectiveContentType}' }));\\n`;\n      } else if (property.type === 'object') {\n        formDataValue =\n          context.output.override.formData.arrayHandling ===\n          FormDataArrayHandling.EXPLODE\n            ? resolveSchemaPropertiesToFormData({\n                schema: property,\n                variableName,\n                propName: nonOptionalValueKey,\n                context,\n                isRequestBodyOptional,\n                keyPrefix: `${keyPrefix}${key}.`,\n                depth: depth + 1,\n                encoding,\n              })\n            : partContentType\n              ? `${variableName}.append(\\`${keyPrefix}${key}\\`, new Blob([JSON.stringify(${nonOptionalValueKey})], { type: '${partContentType}' }));\\n`\n              : `${variableName}.append(\\`${keyPrefix}${key}\\`, JSON.stringify(${nonOptionalValueKey}));\\n`;\n      } else if (property.type === 'array') {\n        let valueStr = 'value';\n        let hasNonPrimitiveChild = false;\n        if (property.items) {\n          const { schema: itemSchema } = resolveRef<OpenApiSchemaObject>(\n            property.items,\n            context,\n          );\n          if (itemSchema.type === 'object' || itemSchema.type === 'array') {\n            if (\n              context.output.override.formData.arrayHandling ===\n              FormDataArrayHandling.EXPLODE\n            ) {\n              hasNonPrimitiveChild = true;\n              const resolvedValue = resolveSchemaPropertiesToFormData({\n                schema: itemSchema,\n                variableName,\n                propName: 'value',\n                context,\n                isRequestBodyOptional,\n                keyPrefix: `${keyPrefix}${key}[\\${index${depth > 0 ? depth : ''}}].`,\n                depth: depth + 1,\n              });\n              formDataValue = `${valueKey}.forEach((value, index${depth > 0 ? depth : ''}) => {\n    ${resolvedValue}});\\n`;\n            } else {\n              valueStr = 'JSON.stringify(value)';\n            }\n          } else if (\n            itemSchema.type === 'number' ||\n            itemSchema.type?.includes('number') ||\n            itemSchema.type === 'integer' ||\n            itemSchema.type?.includes('integer') ||\n            itemSchema.type === 'boolean' ||\n            itemSchema.type?.includes('boolean')\n          ) {\n            valueStr = 'value.toString()';\n          }\n        }\n        if (\n          context.output.override.formData.arrayHandling ===\n          FormDataArrayHandling.EXPLODE\n        ) {\n          if (!hasNonPrimitiveChild) {\n            formDataValue = `${valueKey}.forEach((value, index${depth > 0 ? depth : ''}) => ${variableName}.append(\\`${keyPrefix}${key}[\\${index${depth > 0 ? depth : ''}}]\\`, ${valueStr}));\\n`;\n          }\n        } else {\n          formDataValue = `${valueKey}.forEach(value => ${variableName}.append(\\`${keyPrefix}${key}${context.output.override.formData.arrayHandling === FormDataArrayHandling.SERIALIZE_WITH_BRACKETS ? '[]' : ''}\\`, ${valueStr}));\\n`;\n        }\n      } else if (\n        property.type === 'number' ||\n        property.type?.includes('number') ||\n        property.type === 'integer' ||\n        property.type?.includes('integer') ||\n        property.type === 'boolean' ||\n        property.type?.includes('boolean')\n      ) {\n        formDataValue = `${variableName}.append(\\`${keyPrefix}${key}\\`, ${nonOptionalValueKey}.toString())\\n`;\n      } else {\n        formDataValue = `${variableName}.append(\\`${keyPrefix}${key}\\`, ${nonOptionalValueKey});\\n`;\n      }\n\n      let existSubSchemaNullable = false;\n      if (property.allOf || property.anyOf || property.oneOf) {\n        const combine = property.allOf || property.anyOf || property.oneOf;\n        const subSchemas = combine?.map((c) =>\n          resolveObject({ schema: c, combined: true, context: context }),\n        );\n        if (\n          subSchemas?.some((subSchema) => {\n            return ['number', 'integer', 'boolean'].includes(subSchema.type);\n          })\n        ) {\n          formDataValue = `${variableName}.append(\\`${key}\\`, ${nonOptionalValueKey}.toString())\\n`;\n        }\n\n        if (\n          subSchemas?.some((subSchema) => {\n            return subSchema.type === 'null';\n          })\n        ) {\n          existSubSchemaNullable = true;\n        }\n      }\n\n      const isRequired =\n        schema.required?.includes(key) && !isRequestBodyOptional;\n\n      if (\n        property.nullable ||\n        property.type?.includes('null') ||\n        existSubSchemaNullable\n      ) {\n        if (isRequired) {\n          return acc + `if(${valueKey} !== null) {\\n ${formDataValue} }\\n`;\n        }\n\n        return (\n          acc +\n          `if(${valueKey} !== undefined && ${nonOptionalValueKey} !== null) {\\n ${formDataValue} }\\n`\n        );\n      }\n\n      if (isRequired) {\n        return acc + formDataValue;\n      }\n\n      return acc + `if(${valueKey} !== undefined) {\\n ${formDataValue} }\\n`;\n    },\n    '',\n  );\n\n  return formDataValues;\n}\n","import { generalJSTypesWithArray } from '../constants';\nimport { resolveRef } from '../resolvers';\nimport type {\n  ContextSpec,\n  GetterBody,\n  OpenApiReferenceObject,\n  OpenApiRequestBodyObject,\n  OverrideOutputContentType,\n} from '../types';\nimport { camel, isReference, sanitize } from '../utils';\nimport { getResReqTypes } from './res-req-types';\n\ninterface GetBodyOptions {\n  requestBody: OpenApiReferenceObject | OpenApiRequestBodyObject;\n  operationName: string;\n  context: ContextSpec;\n  contentType?: OverrideOutputContentType;\n}\n\nexport function getBody({\n  requestBody,\n  operationName,\n  context,\n  contentType,\n}: GetBodyOptions): GetterBody {\n  const allBodyTypes = getResReqTypes(\n    [[context.output.override.components.requestBodies.suffix, requestBody]],\n    operationName,\n    context,\n  );\n\n  const filteredBodyTypes = contentType\n    ? allBodyTypes.filter((type) => {\n        let include = true;\n        let exclude = false;\n\n        if (contentType.include) {\n          include = contentType.include.includes(type.contentType);\n        }\n\n        if (contentType.exclude) {\n          exclude = contentType.exclude.includes(type.contentType);\n        }\n\n        return include && !exclude;\n      })\n    : allBodyTypes;\n\n  const imports = filteredBodyTypes.flatMap(({ imports }) => imports);\n  const schemas = filteredBodyTypes.flatMap(({ schemas }) => schemas);\n\n  const definition = filteredBodyTypes.map(({ value }) => value).join(' | ');\n  const hasReadonlyProps = filteredBodyTypes.some((x) => x.hasReadonlyProps);\n  const nonReadonlyDefinition =\n    hasReadonlyProps && definition ? `NonReadonly<${definition}>` : definition;\n\n  let implementation =\n    generalJSTypesWithArray.includes(definition.toLowerCase()) ||\n    filteredBodyTypes.length > 1\n      ? camel(operationName) +\n        context.output.override.components.requestBodies.suffix\n      : camel(definition);\n\n  let isOptional = false;\n  if (implementation) {\n    implementation = sanitize(implementation, {\n      underscore: '_',\n      whitespace: '_',\n      dash: true,\n      es5keyword: true,\n      es5IdentifierName: true,\n    });\n    if (isReference(requestBody)) {\n      const { schema: bodySchema } = resolveRef<OpenApiRequestBodyObject>(\n        requestBody,\n        context,\n      );\n      if (bodySchema.required !== undefined) {\n        isOptional = !bodySchema.required;\n      }\n    } else if (requestBody.required !== undefined) {\n      isOptional = !requestBody.required;\n    }\n  }\n\n  return {\n    originalSchema: requestBody,\n    definition: nonReadonlyDefinition,\n    implementation,\n    imports,\n    schemas,\n    isOptional,\n    ...(filteredBodyTypes.length === 1\n      ? {\n          formData: filteredBodyTypes[0].formData,\n          formUrlEncoded: filteredBodyTypes[0].formUrlEncoded,\n          contentType: filteredBodyTypes[0].contentType,\n        }\n      : {\n          formData: '',\n          formUrlEncoded: '',\n          contentType: '',\n        }),\n  };\n}\n","import type { ContextSpec, GeneratorImport, ResolverValue } from '../types';\n\ninterface GetAliasedImportsOptions {\n  name?: string;\n  resolvedValue: ResolverValue;\n  context: ContextSpec;\n}\n\nexport function getAliasedImports({\n  name,\n  resolvedValue,\n  context,\n}: GetAliasedImportsOptions): GeneratorImport[] {\n  return context.output.schemas && resolvedValue.isRef\n    ? resolvedValue.imports.map((imp) => {\n        if (\n          !needCreateImportAlias({\n            name,\n            imp,\n          })\n        ) {\n          return imp;\n        }\n\n        return {\n          ...imp,\n          alias: `__${imp.name}`,\n        };\n      })\n    : resolvedValue.imports;\n}\n\ninterface NeedCreateImportAliasOptions {\n  name?: string;\n  imp: GeneratorImport;\n}\n\nexport function needCreateImportAlias({\n  imp,\n  name,\n}: NeedCreateImportAliasOptions): boolean {\n  return !imp.alias && imp.name === name;\n}\n\ninterface GetImportAliasForRefOrValueOptions {\n  resolvedValue: ResolverValue;\n  imports: GeneratorImport[];\n  context: ContextSpec;\n}\n\nexport function getImportAliasForRefOrValue({\n  context,\n  imports,\n  resolvedValue,\n}: GetImportAliasForRefOrValueOptions): string {\n  if (!context.output.schemas || !resolvedValue.isRef) {\n    return resolvedValue.value;\n  }\n  const importWithSameName = imports.find(\n    (imp) => imp.name === resolvedValue.value,\n  );\n  return importWithSameName?.alias ?? resolvedValue.value;\n}\n","import { keyword } from 'esutils';\n\nexport function getKey(key: string) {\n  return keyword.isIdentifierNameES5(key) ? key : `'${key}'`;\n}\n","import { resolveExampleRefs, resolveValue } from '../resolvers';\nimport { resolveObject } from '../resolvers/object';\nimport {\n  type ContextSpec,\n  type OpenApiReferenceObject,\n  type OpenApiSchemaObject,\n  PropertySortOrder,\n  type ScalarValue,\n  SchemaType,\n} from '../types';\nimport { escape, isBoolean, isReference, jsDoc, pascal } from '../utils';\nimport { combineSchemas } from './combine';\nimport { getAliasedImports, getImportAliasForRefOrValue } from './imports';\nimport { getKey } from './keys';\nimport { getRefInfo } from './ref';\n\n/**\n * Extract enum values from propertyNames schema (OpenAPI 3.1)\n * Returns undefined if propertyNames doesn't have an enum\n */\nfunction getPropertyNamesEnum(item: OpenApiSchemaObject): string[] | undefined {\n  if (\n    'propertyNames' in item &&\n    item.propertyNames &&\n    'enum' in item.propertyNames &&\n    Array.isArray(item.propertyNames.enum)\n  ) {\n    return item.propertyNames.enum.filter(\n      (val): val is string => typeof val === 'string',\n    );\n  }\n  return undefined;\n}\n\n/**\n * Generate index signature key type based on propertyNames enum\n * Returns union type string like \"'foo' | 'bar'\" or 'string' if no enum\n */\nfunction getIndexSignatureKey(item: OpenApiSchemaObject): string {\n  const enumValues = getPropertyNamesEnum(item);\n  if (enumValues && enumValues.length > 0) {\n    return enumValues.map((val) => `'${val}'`).join(' | ');\n  }\n  return 'string';\n}\n\nfunction getPropertyNamesRecordType(\n  item: OpenApiSchemaObject,\n  valueType: string,\n): string | undefined {\n  const enumValues = getPropertyNamesEnum(item);\n  if (!enumValues || enumValues.length === 0) {\n    return undefined;\n  }\n\n  const keyType = enumValues.map((val) => `'${val}'`).join(' | ');\n  return `Partial<Record<${keyType}, ${valueType}>>`;\n}\n\n/**\n * Context for multipart/form-data type generation.\n * Discriminated union with two states:\n *\n * 1. `{ atPart: false, encoding }` - At form-data root, before property iteration\n *    - May traverse through allOf/anyOf/oneOf to reach properties\n *    - Carries encoding map so getObject can look up `encoding[key]`\n *\n * 2. `{ atPart: true, partContentType }` - At a multipart part (top-level property)\n *    - `partContentType` = Encoding Object's `contentType` for this part\n *    - Used by getScalar for file type detection (precedence over contentMediaType)\n *    - Arrays pass this through to items; combiners inside arrays also get context\n *\n * `undefined` means not in form-data context (or nested inside plain object field = JSON)\n */\nexport type FormDataContext =\n  | { atPart: false; encoding: Record<string, { contentType?: string }> }\n  | { atPart: true; partContentType?: string };\n\ninterface GetObjectOptions {\n  item: OpenApiSchemaObject;\n  name?: string;\n  context: ContextSpec;\n  nullable: string;\n  /**\n   * Multipart/form-data context for file type handling.\n   * @see FormDataContext\n   */\n  formDataContext?: FormDataContext;\n}\n\n/**\n * Return the output type from an object\n *\n * @param item item with type === \"object\"\n */\nexport function getObject({\n  item,\n  name,\n  context,\n  nullable,\n  formDataContext,\n}: GetObjectOptions): ScalarValue {\n  if (isReference(item)) {\n    const { name } = getRefInfo(item.$ref, context);\n    return {\n      value: name + nullable,\n      imports: [{ name }],\n      schemas: [],\n      isEnum: false,\n      type: 'object',\n      isRef: true,\n      hasReadonlyProps: item.readOnly ?? false,\n      dependencies: [name],\n      example: item.example,\n      examples: resolveExampleRefs(item.examples, context),\n    };\n  }\n\n  if (item.allOf || item.oneOf || item.anyOf) {\n    const separator = item.allOf ? 'allOf' : item.oneOf ? 'oneOf' : 'anyOf';\n\n    return combineSchemas({\n      schema: item,\n      name,\n      separator,\n      context,\n      nullable,\n      formDataContext,\n    });\n  }\n\n  if (Array.isArray(item.type)) {\n    return combineSchemas({\n      schema: {\n        anyOf: item.type.map((type) => ({\n          ...item,\n          type,\n        })),\n      },\n      name,\n      separator: 'anyOf',\n      context,\n      nullable,\n    });\n  }\n\n  if (item.properties && Object.entries(item.properties).length > 0) {\n    const entries = Object.entries(item.properties);\n    if (context.output.propertySortOrder === PropertySortOrder.ALPHABETICAL) {\n      entries.sort((a, b) => {\n        return a[0].localeCompare(b[0]);\n      });\n    }\n    return entries.reduce(\n      (\n        acc,\n        [key, schema]: [string, OpenApiReferenceObject | OpenApiSchemaObject],\n        index,\n        arr,\n      ) => {\n        const isRequired = (\n          Array.isArray(item.required) ? item.required : []\n        ).includes(key);\n\n        let propName = '';\n\n        if (name) {\n          const isKeyStartWithUnderscore = key.startsWith('_');\n\n          propName += pascal(\n            `${isKeyStartWithUnderscore ? '_' : ''}${name}_${key}`,\n          );\n        }\n\n        const allSpecSchemas = context.spec.components?.schemas ?? {};\n\n        const isNameAlreadyTaken = Object.keys(allSpecSchemas).some(\n          (schemaName) => pascal(schemaName) === propName,\n        );\n\n        if (isNameAlreadyTaken) {\n          propName = propName + 'Property';\n        }\n\n        // Transition multipart context: atPart: false  atPart: true\n        // Look up encoding[key].contentType and pass to property resolution\n        const propertyFormDataContext: FormDataContext | undefined =\n          formDataContext && !formDataContext.atPart\n            ? {\n                atPart: true,\n                partContentType: formDataContext.encoding[key]?.contentType,\n              }\n            : undefined;\n\n        const resolvedValue = resolveObject({\n          schema,\n          propName,\n          context,\n          formDataContext: propertyFormDataContext,\n        });\n\n        const isReadOnly = item.readOnly || schema.readOnly;\n        if (!index) {\n          acc.value += '{';\n        }\n\n        const doc = jsDoc(schema, true, context);\n\n        acc.hasReadonlyProps ||= isReadOnly || false;\n\n        const constValue = 'const' in schema ? schema.const : undefined;\n        const hasConst = constValue !== undefined;\n        let constLiteral: string | undefined;\n\n        if (!hasConst) {\n          constLiteral = undefined;\n        } else if (typeof constValue === 'string') {\n          constLiteral = `'${escape(constValue)}'`;\n        } else {\n          constLiteral = JSON.stringify(constValue);\n        }\n\n        const needsValueImport =\n          hasConst && (resolvedValue.isEnum || resolvedValue.type === 'enum');\n\n        const aliasedImports: GeneratorImport[] = needsValueImport\n          ? resolvedValue.imports.map((imp) => ({ ...imp, isConstant: true }))\n          : hasConst\n            ? []\n            : getAliasedImports({ name, context, resolvedValue });\n\n        if (aliasedImports.length > 0) {\n          acc.imports.push(...aliasedImports);\n        }\n\n        const alias = getImportAliasForRefOrValue({\n          context,\n          resolvedValue,\n          imports: aliasedImports,\n        });\n\n        const propValue = needsValueImport ? alias : (constLiteral ?? alias);\n\n        const finalPropValue = isRequired\n          ? propValue\n          : context.output.override.useNullForOptional === true\n            ? `${propValue} | null`\n            : propValue;\n\n        acc.value += `\\n  ${doc ? `${doc}  ` : ''}${\n          isReadOnly && !context.output.override.suppressReadonlyModifier\n            ? 'readonly '\n            : ''\n        }${getKey(key)}${isRequired ? '' : '?'}: ${finalPropValue};`;\n        acc.schemas.push(...resolvedValue.schemas);\n        acc.dependencies.push(...resolvedValue.dependencies);\n\n        if (arr.length - 1 === index) {\n          if (item.additionalProperties) {\n            if (isBoolean(item.additionalProperties)) {\n              const recordType = getPropertyNamesRecordType(item, 'unknown');\n              if (recordType) {\n                acc.value += '\\n}';\n                acc.value += ` & ${recordType}`;\n                acc.useTypeAlias = true;\n              } else {\n                const keyType = getIndexSignatureKey(item);\n                acc.value += `\\n  [key: ${keyType}]: unknown;\\n }`;\n              }\n            } else {\n              const resolvedValue = resolveValue({\n                schema: item.additionalProperties,\n                name,\n                context,\n              });\n              const recordType = getPropertyNamesRecordType(\n                item,\n                resolvedValue.value,\n              );\n              if (recordType) {\n                acc.value += '\\n}';\n                acc.value += ` & ${recordType}`;\n                acc.useTypeAlias = true;\n              } else {\n                const keyType = getIndexSignatureKey(item);\n                acc.value += `\\n  [key: ${keyType}]: ${resolvedValue.value};\\n}`;\n              }\n              acc.dependencies.push(...resolvedValue.dependencies);\n            }\n          } else {\n            acc.value += '\\n}';\n          }\n\n          acc.value += nullable;\n        }\n\n        return acc;\n      },\n      {\n        imports: [],\n        schemas: [],\n        value: '',\n        isEnum: false,\n        type: 'object' as SchemaType,\n        isRef: false,\n        schema: {},\n        hasReadonlyProps: false,\n        useTypeAlias: false,\n        dependencies: [],\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      } as ScalarValue,\n    );\n  }\n\n  if (item.additionalProperties) {\n    if (isBoolean(item.additionalProperties)) {\n      const recordType = getPropertyNamesRecordType(item, 'unknown');\n      if (recordType) {\n        return {\n          value: recordType + nullable,\n          imports: [],\n          schemas: [],\n          isEnum: false,\n          type: 'object',\n          isRef: false,\n          hasReadonlyProps: item.readOnly || false,\n          useTypeAlias: true,\n          dependencies: [],\n        };\n      }\n      const keyType = getIndexSignatureKey(item);\n      return {\n        value: `{ [key: ${keyType}]: unknown }` + nullable,\n        imports: [],\n        schemas: [],\n        isEnum: false,\n        type: 'object',\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        useTypeAlias: false,\n        dependencies: [],\n      };\n    }\n    const resolvedValue = resolveValue({\n      schema: item.additionalProperties,\n      name,\n      context,\n    });\n    const recordType = getPropertyNamesRecordType(item, resolvedValue.value);\n    if (recordType) {\n      return {\n        value: recordType + nullable,\n        imports: resolvedValue.imports ?? [],\n        schemas: resolvedValue.schemas ?? [],\n        isEnum: false,\n        type: 'object',\n        isRef: false,\n        hasReadonlyProps: resolvedValue.hasReadonlyProps,\n        useTypeAlias: true,\n        dependencies: resolvedValue.dependencies,\n      };\n    }\n    const keyType = getIndexSignatureKey(item);\n    return {\n      value: `{[key: ${keyType}]: ${resolvedValue.value}}` + nullable,\n      imports: resolvedValue.imports ?? [],\n      schemas: resolvedValue.schemas ?? [],\n      isEnum: false,\n      type: 'object',\n      isRef: false,\n      hasReadonlyProps: resolvedValue.hasReadonlyProps,\n      useTypeAlias: false,\n      dependencies: resolvedValue.dependencies,\n    };\n  }\n\n  const itemWithConst = item;\n  if (itemWithConst.const) {\n    return {\n      value: `'${itemWithConst.const}'`,\n      imports: [],\n      schemas: [],\n      isEnum: false,\n      type: 'string',\n      isRef: false,\n      hasReadonlyProps: item.readOnly || false,\n      dependencies: [],\n    };\n  }\n\n  const keyType =\n    item.type === 'object' ? getIndexSignatureKey(item) : 'string';\n  const recordType = getPropertyNamesRecordType(item, 'unknown');\n  if (item.type === 'object' && recordType) {\n    return {\n      value: recordType + nullable,\n      imports: [],\n      schemas: [],\n      isEnum: false,\n      type: 'object',\n      isRef: false,\n      hasReadonlyProps: item.readOnly || false,\n      useTypeAlias: true,\n      dependencies: [],\n    };\n  }\n  return {\n    value:\n      (item.type === 'object' ? `{ [key: ${keyType}]: unknown }` : 'unknown') +\n      nullable,\n    imports: [],\n    schemas: [],\n    isEnum: false,\n    type: 'object',\n    isRef: false,\n    hasReadonlyProps: item.readOnly || false,\n    useTypeAlias: false,\n    dependencies: [],\n  };\n}\n","import { isArray } from 'remeda';\n\nimport { resolveExampleRefs } from '../resolvers';\nimport type { ContextSpec, OpenApiSchemaObject, ScalarValue } from '../types';\nimport { escape, isString } from '../utils';\nimport { getFormDataFieldFileType } from '../utils/content-type';\nimport { getArray } from './array';\nimport { combineSchemas } from './combine';\nimport type { FormDataContext } from './object';\nimport { getObject } from './object';\n\ninterface GetScalarOptions {\n  item: OpenApiSchemaObject;\n  name?: string;\n  context: ContextSpec;\n  formDataContext?: FormDataContext;\n}\n\n/**\n * Return the typescript equivalent of open-api data type\n *\n * @param item\n * @ref https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.1.md#data-types\n */\nexport function getScalar({\n  item,\n  name,\n  context,\n  formDataContext,\n}: GetScalarOptions): ScalarValue {\n  const nullable =\n    (isArray(item.type) && item.type.includes('null')) || item.nullable === true\n      ? ' | null'\n      : '';\n\n  const enumItems = item.enum?.filter((enumItem) => enumItem !== null);\n\n  let itemType = item.type;\n  if (!itemType && item.items) {\n    item.type = 'array';\n    itemType = 'array';\n  }\n  if (isArray(item.type) && item.type.includes('null')) {\n    const typesWithoutNull = item.type.filter((x) => x !== 'null');\n    itemType =\n      typesWithoutNull.length === 1 ? typesWithoutNull[0] : typesWithoutNull;\n  }\n\n  switch (itemType) {\n    case 'number':\n    case 'integer': {\n      let value =\n        context.output.override.useBigInt &&\n        (item.format === 'int64' || item.format === 'uint64')\n          ? 'bigint'\n          : 'number';\n      let isEnum = false;\n\n      if (enumItems) {\n        value = enumItems\n          .map((enumItem: number | null) => `${enumItem}`)\n          .join(' | ');\n        isEnum = true;\n      }\n\n      value += nullable;\n\n      const itemWithConst = item;\n      if (itemWithConst.const !== undefined) {\n        value = itemWithConst.const;\n      }\n\n      return {\n        value,\n        isEnum,\n        type: 'number',\n        schemas: [],\n        imports: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        dependencies: [],\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      };\n    }\n\n    case 'boolean': {\n      let value = 'boolean' + nullable;\n\n      const itemWithConst = item;\n      if (itemWithConst.const !== undefined) {\n        value = itemWithConst.const;\n      }\n\n      return {\n        value: value,\n        type: 'boolean',\n        isEnum: false,\n        schemas: [],\n        imports: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        dependencies: [],\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      };\n    }\n\n    case 'array': {\n      const { value, ...rest } = getArray({\n        schema: item,\n        name,\n        context,\n        formDataContext,\n      });\n      return {\n        value: value + nullable,\n        ...rest,\n        dependencies: rest.dependencies ?? [],\n      };\n    }\n\n    case 'string': {\n      let value = 'string';\n      let isEnum = false;\n\n      if (enumItems) {\n        value = enumItems\n          .map((enumItem: string | null) =>\n            isString(enumItem) ? `'${escape(enumItem)}'` : `${enumItem}`,\n          )\n          .filter(Boolean)\n          .join(` | `);\n\n        isEnum = true;\n      }\n\n      if (item.format === 'binary') {\n        value = 'Blob';\n      } else if (formDataContext?.atPart) {\n        const fileType = getFormDataFieldFileType(\n          item,\n          formDataContext.partContentType,\n        );\n        if (fileType) {\n          value = fileType === 'binary' ? 'Blob' : 'Blob | string';\n        }\n      }\n\n      if (\n        context.output.override.useDates &&\n        (item.format === 'date' || item.format === 'date-time')\n      ) {\n        value = 'Date';\n      }\n\n      value += nullable;\n\n      const itemWithConst = item;\n      if (itemWithConst.const) {\n        value = `'${itemWithConst.const}'`;\n      }\n\n      return {\n        value: value,\n        isEnum,\n        type: 'string',\n        imports: [],\n        schemas: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        dependencies: [],\n        example: item.example,\n        examples: resolveExampleRefs(item.examples, context),\n      };\n    }\n\n    case 'null': {\n      return {\n        value: 'null',\n        isEnum: false,\n        type: 'null',\n        imports: [],\n        schemas: [],\n        isRef: false,\n        hasReadonlyProps: item.readOnly || false,\n        dependencies: [],\n      };\n    }\n\n    case 'object':\n    default: {\n      if (isArray(itemType)) {\n        return combineSchemas({\n          schema: {\n            anyOf: itemType.map((type) => ({\n              ...item,\n              type,\n            })),\n          },\n          name,\n          separator: 'anyOf',\n          context,\n          nullable,\n        });\n      }\n\n      if (enumItems) {\n        const value = enumItems\n          .map((enumItem: unknown) =>\n            isString(enumItem) ? `'${escape(enumItem)}'` : `${enumItem}`,\n          )\n          .filter(Boolean)\n          .join(` | `);\n\n        return {\n          value: value + nullable,\n          isEnum: true,\n          type: 'string',\n          imports: [],\n          schemas: [],\n          isRef: false,\n          hasReadonlyProps: item.readOnly || false,\n          dependencies: [],\n          example: item.example,\n          examples: resolveExampleRefs(item.examples, context),\n        };\n      }\n\n      // Determine if we should pass form-data context:\n      // - atPart: false  always pass (navigating to properties)\n      // - atPart: true + combiner  pass (combiner members are still the same part)\n      // - atPart: true + plain object  don't pass (nested properties are JSON)\n      const hasCombiners = item.allOf || item.anyOf || item.oneOf;\n      const shouldPassContext =\n        formDataContext?.atPart === false ||\n        (formDataContext?.atPart && hasCombiners);\n\n      const { value, ...rest } = getObject({\n        item,\n        name,\n        context,\n        nullable,\n        formDataContext: shouldPassContext ? formDataContext : undefined,\n      });\n      return { value: value, ...rest };\n    }\n  }\n}\n","import { unique } from 'remeda';\n\nimport { resolveExampleRefs, resolveObject } from '../resolvers';\nimport {\n  type ContextSpec,\n  EnumGeneration,\n  type GeneratorImport,\n  type GeneratorSchema,\n  type OpenApiSchemaObject,\n  type ScalarValue,\n  SchemaType,\n} from '../types';\nimport { dedupeUnionType, getNumberWord, isSchema, pascal } from '../utils';\nimport { getCombinedEnumValue } from './enum';\nimport { getAliasedImports, getImportAliasForRefOrValue } from './imports';\nimport type { FormDataContext } from './object';\nimport { getScalar } from './scalar';\n\ntype CombinedData = {\n  imports: GeneratorImport[];\n  schemas: GeneratorSchema[];\n  originalSchema: (OpenApiSchemaObject | undefined)[];\n  values: string[];\n  isRef: boolean[];\n  isEnum: boolean[];\n  types: string[];\n  hasReadonlyProps: boolean;\n  dependencies: string[];\n  /**\n   * List of all properties in all subschemas\n   * - used to add missing properties in subschemas to avoid TS error described in @see https://github.com/orval-labs/orval/issues/935\n   */\n  allProperties: string[];\n  requiredProperties: string[];\n};\n\ntype Separator = 'allOf' | 'anyOf' | 'oneOf';\n\ninterface CombineValuesOptions {\n  resolvedData: CombinedData;\n  resolvedValue?: ScalarValue;\n  separator: Separator;\n  context: ContextSpec;\n}\n\nfunction combineValues({\n  resolvedData,\n  resolvedValue,\n  separator,\n  context,\n}: CombineValuesOptions) {\n  const isAllEnums = resolvedData.isEnum.every(Boolean);\n\n  if (isAllEnums) {\n    return `${resolvedData.values.join(` | `)}${\n      resolvedValue ? ` | ${resolvedValue.value}` : ''\n    }`;\n  }\n\n  if (separator === 'allOf') {\n    // Wrap values containing unions in parens to preserve precedence\n    // e.g. allOf: [A, oneOf: [B, C]] should be A & (B | C), not A & B | C\n    let resolvedDataValue = resolvedData.values\n      .map((v) => (v.includes(' | ') ? `(${v})` : v))\n      .join(` & `);\n    if (resolvedData.originalSchema.length > 0 && resolvedValue) {\n      const discriminatedPropertySchemas = resolvedData.originalSchema.filter(\n        (s) =>\n          s?.discriminator &&\n          resolvedValue.value.includes(` ${s.discriminator.propertyName}:`),\n      ) as OpenApiSchemaObject[];\n      if (discriminatedPropertySchemas.length > 0) {\n        resolvedDataValue = `Omit<${resolvedDataValue}, '${discriminatedPropertySchemas.map((s) => s.discriminator?.propertyName).join(\"' | '\")}'>`;\n      }\n    }\n    // Also wrap resolvedValue if it contains union (sibling pattern: allOf + oneOf at same level)\n    const resolvedValueStr = resolvedValue?.value.includes(' | ')\n      ? `(${resolvedValue.value})`\n      : resolvedValue?.value;\n    const joined = `${resolvedDataValue}${\n      resolvedValue ? ` & ${resolvedValueStr}` : ''\n    }`;\n\n    // Parent object may have set required properties that only exist in child\n    // objects. Make sure the resulting object has these properties as required,\n    // but there is no need to override properties that are already required\n    const overrideRequiredProperties = resolvedData.requiredProperties.filter(\n      (prop) =>\n        !resolvedData.originalSchema.some(\n          (schema) =>\n            schema?.properties?.[prop] && schema.required?.includes(prop),\n        ),\n    );\n    if (overrideRequiredProperties.length > 0) {\n      return `${joined} & Required<Pick<${joined}, '${overrideRequiredProperties.join(\"' | '\")}'>>`;\n    }\n    return joined;\n  }\n\n  let values = resolvedData.values;\n  const hasObjectSubschemas = resolvedData.allProperties.length;\n  if (hasObjectSubschemas && context.output.unionAddMissingProperties) {\n    values = []; // the list of values will be rebuilt to add missing properties (if exist) in subschemas\n    for (let i = 0; i < resolvedData.values.length; i += 1) {\n      const subSchema = resolvedData.originalSchema[i];\n      if (subSchema?.type !== 'object') {\n        values.push(resolvedData.values[i]);\n        continue;\n      }\n\n      const missingProperties = unique(\n        resolvedData.allProperties.filter(\n          (p) => !Object.keys(subSchema.properties!).includes(p),\n        ),\n      );\n      values.push(\n        `${resolvedData.values[i]}${\n          missingProperties.length > 0\n            ? ` & {${missingProperties.map((p) => `${p}?: never`).join('; ')}}`\n            : ''\n        }`,\n      );\n    }\n  }\n\n  if (resolvedValue) {\n    return `(${values.join(` & ${resolvedValue.value}) | (`)} & ${\n      resolvedValue.value\n    })`;\n  }\n\n  return values.join(' | ');\n}\n\nexport function combineSchemas({\n  name,\n  schema,\n  separator,\n  context,\n  nullable,\n  formDataContext,\n}: {\n  name?: string;\n  schema: OpenApiSchemaObject;\n  separator: Separator;\n  context: ContextSpec;\n  nullable: string;\n  formDataContext?: FormDataContext;\n}): ScalarValue {\n  const items = schema[separator] ?? [];\n\n  const resolvedData: CombinedData[] = items.reduce<CombinedData>(\n    (acc, subSchema) => {\n      // aliasCombinedTypes (v7 compat): create intermediate types like ResponseAnyOf\n      // v8 default: propName stays undefined so combined types are inlined directly\n      let propName: string | undefined;\n      if (context.output.override.aliasCombinedTypes) {\n        propName = name ? name + pascal(separator) : undefined;\n        if (propName && acc.schemas.length > 0) {\n          propName = propName + pascal(getNumberWord(acc.schemas.length + 1));\n        }\n      }\n\n      if (separator === 'allOf' && isSchema(subSchema) && subSchema.required) {\n        acc.requiredProperties.push(...subSchema.required);\n      }\n\n      const resolvedValue = resolveObject({\n        schema: subSchema,\n        propName,\n        combined: true,\n        context,\n        formDataContext,\n      });\n\n      const aliasedImports = getAliasedImports({\n        context,\n        name,\n        resolvedValue,\n      });\n\n      const value = getImportAliasForRefOrValue({\n        context,\n        resolvedValue,\n        imports: aliasedImports,\n      });\n\n      acc.values.push(value);\n      acc.imports.push(...aliasedImports);\n      acc.schemas.push(...resolvedValue.schemas);\n      acc.dependencies.push(...resolvedValue.dependencies);\n      acc.isEnum.push(resolvedValue.isEnum);\n      acc.types.push(resolvedValue.type);\n      acc.isRef.push(resolvedValue.isRef);\n      acc.originalSchema.push(resolvedValue.originalSchema);\n      acc.hasReadonlyProps ||= resolvedValue.hasReadonlyProps;\n\n      if (\n        resolvedValue.type === 'object' &&\n        resolvedValue.originalSchema.properties\n      ) {\n        acc.allProperties.push(\n          ...Object.keys(resolvedValue.originalSchema.properties),\n        );\n      }\n\n      return acc;\n    },\n    {\n      values: [],\n      imports: [],\n      schemas: [],\n      isEnum: [], // check if only enums\n      isRef: [],\n      types: [],\n      dependencies: [],\n      originalSchema: [],\n      allProperties: [],\n      hasReadonlyProps: false,\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n      requiredProperties: separator === 'allOf' ? (schema.required ?? []) : [],\n    } as CombinedData,\n  );\n\n  const isAllEnums = resolvedData.isEnum.every(Boolean);\n  const isAvailableToGenerateCombinedEnum =\n    isAllEnums &&\n    name &&\n    items.length > 1 &&\n    context.output.override.enumGenerationType !== EnumGeneration.UNION;\n\n  // Only generate a combined const when enum values exist at runtime.\n  if (isAvailableToGenerateCombinedEnum) {\n    const {\n      value: combinedEnumValue,\n      valueImports,\n      hasNull,\n    } = getCombinedEnumValue(\n      resolvedData.values.map((value, index) => ({\n        value,\n        isRef: resolvedData.isRef[index],\n        schema: resolvedData.originalSchema[index],\n      })),\n    );\n    const newEnum = `export const ${pascal(name)} = ${combinedEnumValue}`;\n    const valueImportSet = new Set(valueImports);\n    const enumNullSuffix =\n      hasNull && !nullable.includes('null') ? ' | null' : '';\n    const typeSuffix = `${nullable}${enumNullSuffix}`;\n\n    return {\n      value: `typeof ${pascal(name)}[keyof typeof ${pascal(name)}]${typeSuffix}`,\n      imports: [\n        {\n          name: pascal(name),\n        },\n      ],\n      schemas: [\n        ...resolvedData.schemas,\n        {\n          imports: resolvedData.imports\n            .filter((toImport) =>\n              valueImportSet.has(toImport.alias ?? toImport.name),\n            )\n            .map<GeneratorImport>((toImport) => ({\n              ...toImport,\n              values: true,\n            })),\n          model: newEnum,\n          name: name,\n        },\n      ],\n      isEnum: false,\n      type: 'object' as SchemaType,\n      isRef: false,\n      hasReadonlyProps: resolvedData.hasReadonlyProps,\n      dependencies: resolvedData.dependencies,\n      example: schema.example,\n      examples: resolveExampleRefs(schema.examples, context),\n    };\n  }\n\n  let resolvedValue: ScalarValue | undefined;\n\n  if (schema.properties) {\n    resolvedValue = getScalar({\n      item: Object.fromEntries(\n        Object.entries(schema).filter(([key]) => key !== separator),\n      ),\n      name,\n      context,\n    });\n  } else if (separator === 'allOf' && (schema.oneOf || schema.anyOf)) {\n    // Handle sibling pattern: allOf + oneOf/anyOf at same level\n    // e.g. { allOf: [A], oneOf: [B, C] } should produce A & (B | C)\n    const siblingCombiner = schema.oneOf ? 'oneOf' : 'anyOf';\n    resolvedValue = combineSchemas({\n      schema: { [siblingCombiner]: schema[siblingCombiner] },\n      name,\n      separator: siblingCombiner,\n      context,\n      nullable: '',\n    });\n  }\n\n  const value = combineValues({\n    resolvedData,\n    separator,\n    resolvedValue,\n    context,\n  });\n\n  return {\n    value: dedupeUnionType(value + nullable),\n    imports: resolvedValue\n      ? [...resolvedData.imports, ...resolvedValue.imports]\n      : resolvedData.imports,\n    schemas: resolvedValue\n      ? [...resolvedData.schemas, ...resolvedValue.schemas]\n      : resolvedData.schemas,\n    dependencies: resolvedValue\n      ? [...resolvedData.dependencies, ...resolvedValue.dependencies]\n      : resolvedData.dependencies,\n    isEnum: false,\n    type: 'object' as SchemaType,\n    isRef: false,\n    hasReadonlyProps:\n      resolvedData?.hasReadonlyProps ||\n      resolvedValue?.hasReadonlyProps ||\n      false,\n    example: schema.example,\n    examples: resolveExampleRefs(schema.examples, context),\n  };\n}\n","import type { ContextSpec, OpenApiSchemasObject } from '../types';\nimport { pascal } from '../utils';\nimport { getRefInfo } from './ref';\n\nexport function resolveDiscriminators(\n  schemas: OpenApiSchemasObject,\n  context: ContextSpec,\n): OpenApiSchemasObject {\n  const transformedSchemas = schemas;\n  for (const schema of Object.values(transformedSchemas)) {\n    if (typeof schema === 'boolean') {\n      continue; // skip boolean schemas as we can't do anything meaningful with them\n    }\n\n    if (schema.discriminator?.mapping) {\n      const { mapping, propertyName } = schema.discriminator;\n\n      for (const [mappingKey, mappingValue] of Object.entries(mapping)) {\n        let subTypeSchema;\n\n        try {\n          const { originalName } = getRefInfo(mappingValue, context);\n          // name from getRefInfo may contain a suffix, which we don't want\n          const name = pascal(originalName);\n          subTypeSchema =\n            transformedSchemas[name] ?? transformedSchemas[originalName];\n        } catch {\n          subTypeSchema = transformedSchemas[mappingValue];\n        }\n\n        if (typeof subTypeSchema === 'boolean' || propertyName === undefined) {\n          continue;\n        }\n\n        const property = subTypeSchema.properties?.[propertyName];\n        if (typeof property === 'boolean' || property === undefined) {\n          continue;\n        }\n\n        subTypeSchema.properties = {\n          ...subTypeSchema.properties,\n          [propertyName]: {\n            type: 'string',\n            enum: [\n              ...(property?.enum?.filter((value) => value !== mappingKey) ??\n                []),\n              mappingKey,\n            ],\n          },\n        };\n        subTypeSchema.required = [\n          ...(subTypeSchema.required ?? []),\n          propertyName,\n        ];\n      }\n    }\n  }\n\n  return transformedSchemas;\n}\n","import { type OpenApiOperationObject, Verbs } from '../types';\nimport { isString, pascal, sanitize } from '../utils';\n\nexport function getOperationId(\n  operation: OpenApiOperationObject,\n  route: string,\n  verb: Verbs,\n): string {\n  if (isString(operation.operationId)) {\n    return operation.operationId;\n  }\n\n  return pascal(\n    [\n      verb,\n      ...route.split('/').map((p) =>\n        sanitize(p, {\n          dash: true,\n          underscore: '-',\n          dot: '-',\n          whitespace: '-',\n        }),\n      ),\n    ].join('-'),\n  );\n}\n","import { resolveRef } from '../resolvers/ref';\nimport type {\n  ContextSpec,\n  GetterParameters,\n  OpenApiParameterObject,\n  OpenApiReferenceObject,\n} from '../types';\nimport { isReference } from '../utils';\n\ninterface GetParametersOptions {\n  parameters: (OpenApiReferenceObject | OpenApiParameterObject)[];\n  context: ContextSpec;\n}\n\nexport function getParameters({\n  parameters,\n  context,\n}: GetParametersOptions): GetterParameters {\n  return parameters.reduce<GetterParameters>(\n    (acc, p) => {\n      if (isReference(p)) {\n        const { schema: parameter, imports } =\n          resolveRef<OpenApiParameterObject>(p, context);\n\n        if (\n          parameter.in === 'path' ||\n          parameter.in === 'query' ||\n          parameter.in === 'header'\n        ) {\n          acc[parameter.in].push({ parameter, imports });\n        }\n      } else {\n        if (p.in === 'query' || p.in === 'path' || p.in === 'header') {\n          acc[p.in].push({ parameter: p, imports: [] });\n        }\n      }\n\n      return acc;\n    },\n    {\n      path: [],\n      query: [],\n      header: [],\n    },\n  );\n}\n","import { resolveValue } from '../resolvers';\nimport type {\n  ContextSpec,\n  GetterParameters,\n  GetterParams,\n  NormalizedOutputOptions,\n} from '../types';\nimport { camel, sanitize, stringify } from '../utils';\n\n/**\n * Return every params in a path\n *\n * @example\n * ```\n * getParamsInPath(\"/pet/{category}/{name}/\");\n * // => [\"category\", \"name\"]\n * ```\n * @param path\n */\nexport function getParamsInPath(path: string) {\n  let n;\n  const output = [];\n  const templatePathRegex = /\\{(.*?)\\}/g;\n  while ((n = templatePathRegex.exec(path)) !== null) {\n    output.push(n[1]);\n  }\n\n  return output;\n}\n\ninterface GetParamsOptions {\n  route: string;\n  pathParams?: GetterParameters['query'];\n  operationId: string;\n  context: ContextSpec;\n  output: NormalizedOutputOptions;\n}\n\nexport function getParams({\n  route,\n  pathParams = [],\n  operationId,\n  context,\n  output,\n}: GetParamsOptions): GetterParams {\n  const params = getParamsInPath(route);\n  return params.map((p) => {\n    const pathParam = pathParams.find(\n      ({ parameter }) =>\n        sanitize(camel(parameter.name), {\n          es5keyword: true,\n          underscore: true,\n          dash: true,\n        }) === p,\n    );\n\n    if (!pathParam) {\n      throw new Error(\n        `The path params ${p} can't be found in parameters (${operationId})`,\n      );\n    }\n\n    const {\n      name: nameWithoutSanitize,\n      required = false,\n      schema,\n    } = pathParam.parameter;\n\n    const name = sanitize(camel(nameWithoutSanitize), { es5keyword: true });\n\n    if (!schema) {\n      return {\n        name,\n        definition: `${name}${required ? '' : '?'}: unknown`,\n        implementation: `${name}${required ? '' : '?'}: unknown`,\n        default: false,\n        required,\n        imports: [],\n      };\n    }\n\n    const resolvedValue = resolveValue({\n      schema,\n      context,\n    });\n\n    let paramType = resolvedValue.value;\n    if (output.allParamsOptional) {\n      paramType = `${paramType} | undefined | null`; // TODO: maybe check that `paramType` isn't already undefined or null\n    }\n\n    const definition = `${name}${\n      !required || resolvedValue.originalSchema!.default ? '?' : ''\n    }: ${paramType}`;\n\n    const implementation = `${name}${\n      !required && !resolvedValue.originalSchema!.default ? '?' : ''\n    }${\n      resolvedValue.originalSchema!.default\n        ? `: ${paramType} = ${stringify(resolvedValue.originalSchema!.default)}`\n        : `: ${paramType}` // FIXME: in Vue if we have `version: MaybeRef<number | undefined | null> = 1` and we don't pass version, the unref(version) will be `undefined` and not `1`, so we need to handle default value somewhere in implementation and not in the definition\n    }`;\n\n    return {\n      name,\n      definition,\n      implementation,\n      default: resolvedValue.originalSchema!.default,\n      required,\n      imports: resolvedValue.imports,\n      originalSchema: resolvedValue.originalSchema,\n    };\n  });\n}\n","import {\n  type ContextSpec,\n  type GetterBody,\n  type GetterParams,\n  type GetterProps,\n  GetterPropType,\n  type GetterQueryParam,\n  OutputClient,\n} from '../types';\nimport { isUndefined, pascal, sortByPriority } from '../utils';\n\ninterface GetPropsOptions {\n  body: GetterBody;\n  queryParams?: GetterQueryParam;\n  params: GetterParams;\n  operationName: string;\n  headers?: GetterQueryParam;\n  context: ContextSpec;\n}\n\nexport function getProps({\n  body,\n  queryParams,\n  params,\n  operationName,\n  headers,\n  context,\n}: GetPropsOptions): GetterProps {\n  const bodyProp = {\n    name: body.implementation,\n    definition: `${body.implementation}${body.isOptional && !context.output.optionsParamRequired ? '?' : ''}: ${body.definition}`,\n    implementation: `${body.implementation}${body.isOptional && !context.output.optionsParamRequired ? '?' : ''}: ${body.definition}`,\n    default: false,\n    required: !body.isOptional || context.output.optionsParamRequired,\n    type: GetterPropType.BODY,\n  };\n\n  const queryParamsProp = {\n    name: 'params',\n    definition: getQueryParamDefinition(queryParams, context),\n    implementation: getQueryParamDefinition(queryParams, context),\n    default: false,\n    required: isUndefined(queryParams?.isOptional)\n      ? !context.output.allParamsOptional || context.output.optionsParamRequired\n      : (!queryParams?.isOptional && !context.output.allParamsOptional) ||\n        context.output.optionsParamRequired,\n    type: GetterPropType.QUERY_PARAM,\n  };\n\n  const headersProp = {\n    name: 'headers',\n    definition: `headers${headers?.isOptional && !context.output.optionsParamRequired ? '?' : ''}: ${\n      headers?.schema.name\n    }`,\n    implementation: `headers${headers?.isOptional && !context.output.optionsParamRequired ? '?' : ''}: ${\n      headers?.schema.name\n    }`,\n    default: false,\n    required: isUndefined(headers?.isOptional)\n      ? false\n      : !headers?.isOptional || context.output.optionsParamRequired,\n    type: GetterPropType.HEADER,\n  };\n\n  let paramGetterProps: GetterProps;\n  if (context.output.override.useNamedParameters && params.length > 0) {\n    const parameterTypeName = `${pascal(operationName)}PathParameters`;\n\n    const name = 'pathParams';\n\n    // needs a special model\n    const namedParametersTypeDefinition = `export type ${parameterTypeName} = {\\n ${params\n      .map((property) => property.definition)\n      .join(',\\n    ')},\\n }`;\n\n    const isOptional =\n      context.output.optionsParamRequired ||\n      params.every((param) => param.default);\n\n    const implementation = `{ ${params\n      .map((property) =>\n        property.default\n          ? `${property.name} = ${property.default}` // if we use property.implementation, we will get `{ version: number = 1 }: ListPetsPathParameters = {}` which isn't valid\n          : property.name,\n      )\n      .join(', ')} }: ${parameterTypeName}${isOptional ? ' = {}' : ''}`;\n\n    const destructured = `{ ${params\n      .map((property) => property.name)\n      .join(', ')} }`;\n\n    paramGetterProps = [\n      {\n        type: GetterPropType.NAMED_PATH_PARAMS,\n        name,\n        definition: `${name}: ${parameterTypeName}`,\n        implementation,\n        default: false,\n        destructured,\n        required: true,\n        schema: {\n          name: parameterTypeName,\n          model: namedParametersTypeDefinition,\n          imports: params.flatMap((property) => property.imports),\n        },\n      },\n    ];\n  } else {\n    paramGetterProps = params.map((param) => ({\n      ...param,\n      type: GetterPropType.PARAM,\n    }));\n  }\n\n  const props = [\n    ...paramGetterProps,\n    ...(body.definition ? [bodyProp] : []),\n    ...(queryParams ? [queryParamsProp] : []),\n    ...(headers ? [headersProp] : []),\n  ];\n\n  const sortedProps = sortByPriority(props);\n\n  return sortedProps;\n}\n\nfunction getQueryParamDefinition(\n  queryParams: GetterQueryParam | undefined,\n  context: ContextSpec,\n): string {\n  let paramType = queryParams?.schema.name;\n  if (OutputClient.ANGULAR === context.output.client) {\n    paramType = `DeepNonNullable<${paramType}>`;\n  }\n  return `params${(queryParams?.isOptional || context.output.allParamsOptional) && !context.output.optionsParamRequired ? '?' : ''}: ${paramType}`;\n}\n","import { resolveValue } from '../resolvers';\nimport type {\n  ContextSpec,\n  GeneratorImport,\n  GeneratorSchema,\n  GetterParameters,\n  GetterQueryParam,\n  OpenApiParameterObject,\n  OpenApiSchemaObject,\n} from '../types';\nimport { jsDoc, pascal, sanitize } from '../utils';\nimport { getEnum, getEnumDescriptions, getEnumNames } from './enum';\nimport { getKey } from './keys';\n\ntype QueryParamsType = {\n  definition: string;\n  imports: GeneratorImport[];\n  schemas: GeneratorSchema[];\n  originalSchema: OpenApiSchemaObject;\n};\n\nfunction getQueryParamsTypes(\n  queryParams: GetterParameters['query'],\n  operationName: string,\n  context: ContextSpec,\n): QueryParamsType[] {\n  return queryParams.map(({ parameter, imports: parameterImports }) => {\n    const {\n      name,\n      required,\n      schema: schemaParam,\n      content,\n    } = parameter as {\n      name: string;\n      required: boolean;\n      schema: OpenApiSchemaObject;\n      content: OpenApiParameterObject['content'];\n    };\n\n    const queryName = sanitize(`${pascal(operationName)}${pascal(name)}`, {\n      underscore: '_',\n      whitespace: '_',\n      dash: true,\n      es5keyword: true,\n      es5IdentifierName: true,\n    });\n\n    const schema = (schemaParam || content['application/json'].schema)!;\n\n    const resolvedValue = resolveValue({\n      schema,\n      context,\n      name: queryName,\n    });\n\n    const key = getKey(name);\n    const doc = jsDoc(\n      {\n        description: parameter.description,\n        ...schema,\n      },\n      void 0,\n      context,\n    );\n\n    if (parameterImports.length > 0) {\n      return {\n        definition: `${doc}${key}${!required || schema.default ? '?' : ''}: ${\n          parameterImports[0].name\n        };`,\n        imports: parameterImports,\n        schemas: [],\n        originalSchema: resolvedValue.originalSchema,\n      };\n    }\n\n    if (resolvedValue.isEnum && !resolvedValue.isRef) {\n      const enumName = queryName;\n      const enumValue = getEnum(\n        resolvedValue.value,\n        enumName,\n        getEnumNames(resolvedValue.originalSchema),\n        context.output.override.enumGenerationType,\n        getEnumDescriptions(resolvedValue.originalSchema),\n        context.output.override.namingConvention?.enum,\n      );\n\n      return {\n        definition: `${doc}${key}${\n          !required || schema.default ? '?' : ''\n        }: ${enumName};`,\n        imports: [{ name: enumName }],\n        schemas: [\n          ...resolvedValue.schemas,\n          { name: enumName, model: enumValue, imports: resolvedValue.imports },\n        ],\n        originalSchema: resolvedValue.originalSchema,\n      };\n    }\n\n    const definition = `${doc}${key}${\n      !required || schema.default ? '?' : ''\n    }: ${resolvedValue.value};`;\n\n    return {\n      definition,\n      imports: resolvedValue.imports,\n      schemas: resolvedValue.schemas,\n      originalSchema: resolvedValue.originalSchema,\n    };\n  });\n}\n\ninterface GetQueryParamsOptions {\n  queryParams: GetterParameters['query'];\n  operationName: string;\n  context: ContextSpec;\n  suffix?: string;\n}\n\nexport function getQueryParams({\n  queryParams,\n  operationName,\n  context,\n  suffix = 'params',\n}: GetQueryParamsOptions): GetterQueryParam | undefined {\n  if (queryParams.length === 0) {\n    return;\n  }\n  const types = getQueryParamsTypes(queryParams, operationName, context);\n  const imports = types.flatMap(({ imports }) => imports);\n  const schemas = types.flatMap(({ schemas }) => schemas);\n  const name = `${pascal(operationName)}${pascal(suffix)}`;\n\n  const type = types.map(({ definition }) => definition).join('\\n');\n  const allOptional = queryParams.every(({ parameter }) => !parameter.required);\n\n  const schema = {\n    name,\n    model: `export type ${name} = {\\n${type}\\n};\\n`,\n    imports,\n  };\n\n  return {\n    schema,\n    deps: schemas,\n    isOptional: allOptional,\n  };\n}\n","import type {\n  ContextSpec,\n  GetterResponse,\n  OpenApiResponsesObject,\n  OverrideOutputContentType,\n  ResReqTypesValue,\n} from '../types';\nimport { dedupeUnionType } from '../utils';\nimport { getResReqTypes } from './res-req-types';\n\ninterface GetResponseOptions {\n  responses: OpenApiResponsesObject;\n  operationName: string;\n  context: ContextSpec;\n  contentType?: OverrideOutputContentType;\n}\n\nexport function getResponse({\n  responses,\n  operationName,\n  context,\n  contentType,\n}: GetResponseOptions): GetterResponse {\n  if (!responses) {\n    return {\n      imports: [],\n      definition: {\n        success: '',\n        errors: '',\n      },\n      isBlob: false,\n      types: { success: [], errors: [] },\n      schemas: [],\n      contentTypes: [],\n    };\n  }\n\n  const types = getResReqTypes(\n    Object.entries(responses),\n    operationName,\n    context,\n    'void',\n    (type) => `${type.key}-${type.value}`,\n  );\n\n  const filteredTypes = contentType\n    ? types.filter((type) => {\n        let include = true;\n        let exclude = false;\n\n        if (contentType.include) {\n          include = contentType.include.includes(type.contentType);\n        }\n\n        if (contentType.exclude) {\n          exclude = contentType.exclude.includes(type.contentType);\n        }\n\n        return include && !exclude;\n      })\n    : types;\n\n  const imports = filteredTypes.flatMap(({ imports }) => imports);\n  const schemas = filteredTypes.flatMap(({ schemas }) => schemas);\n\n  const contentTypes = [\n    ...new Set(filteredTypes.map(({ contentType }) => contentType)),\n  ];\n\n  const groupedByStatus = filteredTypes.reduce<{\n    success: ResReqTypesValue[];\n    errors: ResReqTypesValue[];\n  }>(\n    (acc, type) => {\n      if (type.key.startsWith('2')) {\n        acc.success.push(type);\n      } else {\n        acc.errors.push(type);\n      }\n      return acc;\n    },\n    { success: [], errors: [] },\n  );\n\n  const success = dedupeUnionType(\n    groupedByStatus.success\n      .map(({ value, formData }) => (formData ? 'Blob' : value))\n      .join(' | '),\n  );\n  const errors = dedupeUnionType(\n    groupedByStatus.errors.map(({ value }) => value).join(' | '),\n  );\n\n  const defaultType = filteredTypes.find(({ key }) => key === 'default')?.value;\n\n  return {\n    imports,\n    definition: {\n      success: success || (defaultType ?? 'unknown'),\n      errors: errors || (defaultType ?? 'unknown'),\n    },\n    isBlob: success === 'Blob',\n    types: groupedByStatus,\n    contentTypes,\n    schemas,\n    originalSchema: responses,\n  };\n}\n","import { TEMPLATE_TAG_REGEX } from '../constants';\nimport type {\n  BaseUrlFromConstant,\n  BaseUrlFromSpec,\n  OpenApiServerObject,\n} from '../types';\nimport { camel, sanitize } from '../utils';\n\nconst TEMPLATE_TAG_IN_PATH_REGEX = /\\/([\\w]+)(?:\\$\\{)/g; // all dynamic parts of path\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = /([^{]*){?([\\w*_-]*)}?(.*)/.exec(path);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(camel(matches[2]), {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  return hasParam(path)\n    ? `${prev}\\${${param}}${next}`\n    : `${prev}${param}${next}`;\n};\n\nexport function getRoute(route: string) {\n  const splittedRoute = route.split('/');\n\n  return splittedRoute.reduce((acc, path, i) => {\n    if (!path && !i) {\n      return acc;\n    }\n\n    if (!path.includes('{')) {\n      return `${acc}/${path}`;\n    }\n\n    return `${acc}/${getRoutePath(path)}`;\n  }, '');\n}\n\nexport function getFullRoute(\n  route: string,\n  servers: OpenApiServerObject[] | undefined,\n  baseUrl: string | BaseUrlFromConstant | BaseUrlFromSpec | undefined,\n): string {\n  const getBaseUrl = (): string => {\n    if (!baseUrl) return '';\n    if (typeof baseUrl === 'string') return baseUrl;\n    if (baseUrl.getBaseUrlFromSpecification) {\n      if (!servers) {\n        throw new Error(\n          \"Orval is configured to use baseUrl from the specifications 'servers' field, but there exist no servers in the specification.\",\n        );\n      }\n      const server = servers.at(\n        Math.min(baseUrl.index ?? 0, servers.length - 1),\n      );\n      if (!server) return '';\n      if (!server.variables) return server.url;\n\n      let url = server.url;\n      const variables = baseUrl.variables;\n      for (const variableKey of Object.keys(server.variables)) {\n        const variable = server.variables[variableKey];\n        if (variables?.[variableKey]) {\n          if (\n            variable.enum &&\n            !variable.enum.some((e) => e == variables[variableKey])\n          ) {\n            throw new Error(\n              `Invalid variable value '${variables[variableKey]}' for variable '${variableKey}' when resolving ${server.url}. Valid values are: ${variable.enum.join(', ')}.`,\n            );\n          }\n          url = url.replaceAll(`{${variableKey}}`, variables[variableKey]);\n        } else {\n          url = url.replaceAll(`{${variableKey}}`, String(variable.default));\n        }\n      }\n      return url;\n    }\n    return baseUrl.baseUrl;\n  };\n\n  let fullRoute = route;\n  const base = getBaseUrl();\n  if (base) {\n    if (base.endsWith('/') && route.startsWith('/')) {\n      fullRoute = route.slice(1);\n    }\n    fullRoute = `${base}${fullRoute}`;\n  }\n  return fullRoute;\n}\n\n// Creates a mixed use array with path variables and string from template string route\nexport function getRouteAsArray(route: string): string {\n  return route\n    .replaceAll(TEMPLATE_TAG_IN_PATH_REGEX, '/$1/${')\n    .split('/')\n    .filter((i) => i !== '')\n    .map((i) =>\n      // @note - array is mixed with string and var\n      i.includes('${') ? i.replace(TEMPLATE_TAG_REGEX, '$1') : `'${i}'`,\n    )\n    .join(',')\n    .replace(',,', '');\n}\n","import { entries, isEmptyish } from 'remeda';\n\nimport { getResReqTypes } from '../getters';\nimport type {\n  ContextSpec,\n  GeneratorSchema,\n  OpenApiComponentsObject,\n} from '../types';\nimport { jsDoc, pascal, sanitize } from '../utils';\n\nexport function generateComponentDefinition(\n  responses:\n    | OpenApiComponentsObject['responses']\n    | OpenApiComponentsObject['requestBodies'] = {},\n  context: ContextSpec,\n  suffix: string,\n): GeneratorSchema[] {\n  if (isEmptyish(responses)) {\n    return [];\n  }\n\n  const generatorSchemas: GeneratorSchema[] = [];\n  for (const [name, response] of entries(responses)) {\n    const allResponseTypes = getResReqTypes(\n      [[suffix, response]],\n      name,\n      context,\n      'void',\n    );\n\n    const imports = allResponseTypes.flatMap(({ imports }) => imports);\n    const schemas = allResponseTypes.flatMap(({ schemas }) => schemas);\n\n    const type = allResponseTypes.map(({ value }) => value).join(' | ');\n\n    const modelName = sanitize(`${pascal(name)}${suffix}`, {\n      underscore: '_',\n      whitespace: '_',\n      dash: true,\n      es5keyword: true,\n      es5IdentifierName: true,\n    });\n    const doc = jsDoc(response);\n    const model = `${doc}export type ${modelName} = ${type || 'unknown'};\\n`;\n\n    generatorSchemas.push(...schemas);\n\n    if (modelName !== type) {\n      generatorSchemas.push({\n        name: modelName,\n        model,\n        imports,\n      });\n    }\n  }\n\n  return generatorSchemas;\n}\n","import { groupBy, unique, uniqueWith } from 'remeda';\n\nimport {\n  type GeneratorImport,\n  type GeneratorMutator,\n  type GeneratorVerbOptions,\n  GetterPropType,\n  NamingConvention,\n} from '../types';\nimport { conventionName } from '../utils';\n\ninterface GenerateImportsOptions {\n  imports: GeneratorImport[];\n  target: string;\n  namingConvention?: NamingConvention;\n}\n\nexport function generateImports({\n  imports,\n  namingConvention = NamingConvention.CAMEL_CASE,\n}: GenerateImportsOptions) {\n  if (imports.length === 0) {\n    return '';\n  }\n\n  const normalized = uniqueWith(\n    imports,\n    (a, b) => a.name === b.name && a.default === b.default,\n  ).map((imp) => ({\n    ...imp,\n    importPath:\n      imp.importPath ?? `./${conventionName(imp.name, namingConvention)}`,\n  }));\n\n  const grouped = groupBy(normalized, (imp) =>\n    !imp.default &&\n    !imp.namespaceImport &&\n    !imp.syntheticDefaultImport &&\n    !imp.values &&\n    !imp.isConstant\n      ? `aggregate|${imp.importPath}`\n      : `single|${imp.importPath}|${imp.name}|${imp.alias ?? ''}|${String(\n          imp.default,\n        )}|${String(imp.namespaceImport)}|${String(imp.syntheticDefaultImport)}|${String(\n          imp.values,\n        )}|${String(imp.isConstant)}`,\n  );\n\n  return Object.entries(grouped)\n    .toSorted(([a], [b]) => a.localeCompare(b))\n    .map(([, group]) => {\n      const sample = group[0];\n      const canAggregate =\n        !sample.default &&\n        !sample.namespaceImport &&\n        !sample.syntheticDefaultImport &&\n        !sample.values &&\n        !sample.isConstant;\n\n      if (canAggregate) {\n        const names = [\n          ...new Set(\n            group.map(\n              ({ name, alias }) => `${name}${alias ? ` as ${alias}` : ''}`,\n            ),\n          ),\n        ]\n          .toSorted()\n          .join(', ');\n\n        return `import type { ${names} } from '${sample.importPath}';`;\n      }\n\n      const { name, values, alias, isConstant, importPath } = sample;\n      return `import ${!values && !isConstant ? 'type ' : ''}{ ${name}${\n        alias ? ` as ${alias}` : ''\n      } } from '${importPath}';`;\n    })\n    .join('\\n');\n}\n\ninterface GenerateMutatorImportsOptions {\n  mutators: GeneratorMutator[];\n  implementation?: string;\n  oneMore?: boolean;\n}\n\nexport function generateMutatorImports({\n  mutators,\n  implementation,\n  oneMore,\n}: GenerateMutatorImportsOptions) {\n  const imports = uniqueWith(\n    mutators,\n    (a, b) => a.name === b.name && a.default === b.default,\n  ).reduce((acc, mutator) => {\n    const path = `${oneMore ? '../' : ''}${mutator.path}`;\n    const importDefault = mutator.default\n      ? mutator.name\n      : `{ ${mutator.name} }`;\n\n    acc += `import ${importDefault} from '${path}';`;\n    acc += '\\n';\n\n    if (implementation && (mutator.hasErrorType || mutator.bodyTypeName)) {\n      let errorImportName = '';\n      const targetErrorImportName = mutator.default\n        ? `ErrorType as ${mutator.errorTypeName}`\n        : mutator.errorTypeName;\n      if (\n        mutator.hasErrorType &&\n        implementation.includes(mutator.errorTypeName) &&\n        !acc.includes(`{ ${targetErrorImportName} `)\n      ) {\n        errorImportName = targetErrorImportName;\n      }\n\n      let bodyImportName = '';\n      const targetBodyImportName = mutator.default\n        ? `BodyType as ${mutator.bodyTypeName}`\n        : mutator.bodyTypeName;\n      if (\n        mutator.bodyTypeName &&\n        implementation.includes(mutator.bodyTypeName) &&\n        !acc.includes(` ${targetBodyImportName} }`)\n      ) {\n        bodyImportName = targetBodyImportName!;\n      }\n\n      if (bodyImportName || errorImportName) {\n        acc += `import type { ${errorImportName}${\n          errorImportName && bodyImportName ? ' , ' : ''\n        }${bodyImportName} } from '${path}';`;\n        acc += '\\n';\n      }\n    }\n\n    return acc;\n  }, '');\n\n  return imports;\n}\n\ninterface GenerateDependencyOptions {\n  key: string;\n  deps: GeneratorImport[];\n  dependency: string;\n  projectName?: string;\n  isAllowSyntheticDefaultImports: boolean;\n  onlyTypes: boolean;\n}\n\nfunction generateDependency({\n  deps,\n  isAllowSyntheticDefaultImports,\n  dependency,\n  projectName,\n  key,\n  onlyTypes,\n}: GenerateDependencyOptions) {\n  // find default import if dependency either is not a synthetic import or synthetic imports are allowed\n  const defaultDep = deps.find(\n    (e) =>\n      e.default &&\n      (isAllowSyntheticDefaultImports || !e.syntheticDefaultImport),\n  );\n\n  // if default dependency could not be created, check for namespace import or a synthetic import that is not allowed\n  const namespaceImportDep = defaultDep\n    ? undefined\n    : deps.find(\n        (e) =>\n          !!e.namespaceImport ||\n          (!isAllowSyntheticDefaultImports && e.syntheticDefaultImport),\n      );\n\n  // find all named imports\n  const depsString = unique(\n    deps\n      .filter(\n        (e) => !e.default && !e.syntheticDefaultImport && !e.namespaceImport,\n      )\n      .map(({ name, alias }) => (alias ? `${name} as ${alias}` : name)),\n  )\n    .toSorted()\n    .join(',\\n  ');\n\n  let importString = '';\n\n  // generate namespace import string\n  const namespaceImportString = namespaceImportDep\n    ? `import * as ${namespaceImportDep.name} from '${dependency}';`\n    : '';\n\n  if (namespaceImportString) {\n    if (deps.length === 1) {\n      // only namespace import, return it directly\n      return namespaceImportString;\n    }\n    importString += `${namespaceImportString}\\n`;\n  }\n\n  importString += `import ${onlyTypes ? 'type ' : ''}${\n    defaultDep ? `${defaultDep.name}${depsString ? ',' : ''}` : ''\n  }${depsString ? `{\\n  ${depsString}\\n}` : ''} from '${dependency}${\n    key !== 'default' && projectName ? `/${projectName}` : ''\n  }';`;\n\n  return importString;\n}\n\ninterface AddDependencyOptions {\n  implementation: string;\n  exports: GeneratorImport[];\n  dependency: string;\n  projectName?: string;\n  hasSchemaDir: boolean;\n  isAllowSyntheticDefaultImports: boolean;\n}\n\nexport function addDependency({\n  implementation,\n  exports,\n  dependency,\n  projectName,\n  hasSchemaDir,\n  isAllowSyntheticDefaultImports,\n}: AddDependencyOptions) {\n  const toAdds = exports.filter((e) => {\n    const searchWords = [e.alias, e.name].filter((p) => p?.length).join('|');\n    const pattern = new RegExp(String.raw`\\b(${searchWords})\\b`, 'g');\n\n    return implementation.match(pattern);\n  });\n\n  if (toAdds.length === 0) {\n    return;\n  }\n\n  const groupedBySpecKey = toAdds.reduce<\n    Record<string, { types: GeneratorImport[]; values: GeneratorImport[] }>\n  >((acc, dep) => {\n    const key = 'default';\n\n    if (\n      dep.values &&\n      (isAllowSyntheticDefaultImports || !dep.syntheticDefaultImport)\n    ) {\n      acc[key] = {\n        ...acc[key],\n        values: [...(acc[key]?.values ?? []), dep],\n      };\n\n      return acc;\n    }\n\n    acc[key] = {\n      ...acc[key],\n      types: [...(acc[key]?.types ?? []), dep],\n    };\n\n    return acc;\n  }, {});\n\n  return (\n    Object.entries(groupedBySpecKey)\n      .map(([key, { values, types }]) => {\n        let dep = '';\n\n        if (values) {\n          dep += generateDependency({\n            deps: values,\n            isAllowSyntheticDefaultImports,\n            dependency,\n            projectName,\n            key,\n            onlyTypes: false,\n          });\n        }\n\n        if (types) {\n          let uniqueTypes = types;\n          if (values) {\n            uniqueTypes = types.filter(\n              (t) => !values.some((v) => v.name === t.name),\n            );\n            dep += '\\n';\n          }\n          dep += generateDependency({\n            deps: uniqueTypes,\n            isAllowSyntheticDefaultImports,\n            dependency,\n            projectName,\n            key,\n            onlyTypes: true,\n          });\n        }\n\n        return dep;\n      })\n      .join('\\n') + '\\n'\n  );\n}\n\nfunction getLibName(code: string) {\n  const splitString = code.split(' from ');\n  return splitString[splitString.length - 1].split(';')[0].trim();\n}\n\nexport function generateDependencyImports(\n  implementation: string,\n  imports: {\n    exports: GeneratorImport[];\n    dependency: string;\n  }[],\n  projectName: string | undefined,\n  hasSchemaDir: boolean,\n  isAllowSyntheticDefaultImports: boolean,\n): string {\n  const dependencies = imports\n    .map((dep) =>\n      addDependency({\n        ...dep,\n        implementation,\n        projectName,\n        hasSchemaDir,\n        isAllowSyntheticDefaultImports,\n      }),\n    )\n    .filter(Boolean)\n    .sort((a, b) => {\n      const aLib = getLibName(a!);\n      const bLib = getLibName(b!);\n\n      if (aLib === bLib) {\n        return 0;\n      }\n\n      if (aLib.startsWith(\"'.\") && !bLib.startsWith(\"'.\")) {\n        return 1;\n      }\n      return aLib < bLib ? -1 : 1;\n    })\n    .join('\\n');\n\n  return dependencies ? dependencies + '\\n' : '';\n}\n\nexport function generateVerbImports({\n  response,\n  body,\n  queryParams,\n  props,\n  headers,\n  params,\n}: GeneratorVerbOptions): GeneratorImport[] {\n  return [\n    ...response.imports,\n    ...body.imports,\n    ...props.flatMap((prop) =>\n      prop.type === GetterPropType.NAMED_PATH_PARAMS\n        ? [{ name: prop.schema.name }]\n        : [],\n    ),\n    ...(queryParams ? [{ name: queryParams.schema.name }] : []),\n    ...(headers ? [{ name: headers.schema.name }] : []),\n    ...params.flatMap<GeneratorImport>(({ imports }) => imports),\n  ];\n}\n","import type { GeneratorSchema } from '../types';\n\nexport function generateModelInline(acc: string, model: string): string {\n  return acc + `${model}\\n`;\n}\n\nexport function generateModelsInline(\n  obj: Record<string, GeneratorSchema[]>,\n): string {\n  const schemas = Object.values(obj).flat();\n\n  return schemas.reduce<string>(\n    (acc, { model }) => generateModelInline(acc, model),\n    '',\n  );\n}\n","import path from 'node:path';\n\nimport { type ecmaVersion, Parser, type Program } from 'acorn';\nimport { build, type BuildOptions } from 'esbuild';\nimport { isArray } from 'remeda';\n\nimport type {\n  GeneratorMutatorParsingInfo,\n  Tsconfig,\n  TsConfigTarget,\n} from '../types';\n\nexport async function getMutatorInfo(\n  filePath: string,\n  options?: {\n    root?: string;\n    namedExport?: string;\n    alias?: Record<string, string>;\n    external?: string[];\n    tsconfig?: Tsconfig;\n  },\n): Promise<GeneratorMutatorParsingInfo | undefined> {\n  const {\n    root = process.cwd(),\n    namedExport = 'default',\n    alias,\n    external,\n    tsconfig,\n  } = options ?? {};\n\n  const code = await bundleFile(\n    root,\n    path.resolve(filePath),\n    alias,\n    external,\n    tsconfig?.compilerOptions,\n  );\n\n  return parseFile(\n    code,\n    namedExport,\n    getEcmaVersion(tsconfig?.compilerOptions?.target),\n  );\n}\n\nasync function bundleFile(\n  root: string,\n  fileName: string,\n  alias?: Record<string, string>,\n  external?: string[],\n  compilerOptions?: Tsconfig['compilerOptions'],\n): Promise<string> {\n  const result = await build({\n    absWorkingDir: root,\n    entryPoints: [fileName],\n    write: false,\n    platform: 'node',\n    bundle: true,\n    format: 'esm',\n    metafile: false,\n    target: compilerOptions?.target ?? 'es6',\n    minify: false,\n    minifyIdentifiers: false,\n    minifySyntax: false,\n    minifyWhitespace: false,\n    treeShaking: false,\n    keepNames: false,\n    alias,\n    external: external || ['*'],\n  } satisfies BuildOptions);\n  const { text } = result.outputFiles[0];\n\n  return text;\n}\n\nfunction parseFile(\n  file: string,\n  name: string,\n  ecmaVersion: ecmaVersion = 6,\n): GeneratorMutatorParsingInfo | undefined {\n  try {\n    const ast = Parser.parse(file, { ecmaVersion, sourceType: 'module' });\n\n    const foundSpecifier = ast.body\n      .filter((x) => x.type === 'ExportNamedDeclaration')\n      .flatMap((x) => x.specifiers)\n      .find(\n        (x) =>\n          x.exported.type === 'Identifier' &&\n          x.exported.name === name &&\n          x.local.type === 'Identifier',\n      );\n\n    if (foundSpecifier && 'name' in foundSpecifier.local) {\n      const exportedFuncName = foundSpecifier.local.name;\n\n      return parseFunction(ast, exportedFuncName);\n    }\n  } catch {\n    return;\n  }\n}\n\nfunction parseFunction(\n  ast: Program,\n  funcName: string,\n): GeneratorMutatorParsingInfo | undefined {\n  const node = ast.body.find((childNode) => {\n    if (childNode.type === 'VariableDeclaration') {\n      return childNode.declarations.find(\n        (d) => d.id.type === 'Identifier' && d.id.name === funcName,\n      );\n    }\n    if (\n      childNode.type === 'FunctionDeclaration' &&\n      childNode.id.name === funcName\n    ) {\n      return childNode;\n    }\n  });\n\n  if (!node) {\n    return;\n  }\n\n  if (node.type === 'FunctionDeclaration') {\n    const returnStatement = node.body.body.find(\n      (b) => b.type === 'ReturnStatement',\n    );\n\n    // If the function directly returns an arrow function\n    if (returnStatement?.argument && 'params' in returnStatement.argument) {\n      return {\n        numberOfParams: node.params.length,\n        returnNumberOfParams: returnStatement.argument.params.length,\n      };\n      // If the function returns a CallExpression (e.g., return useCallback(...))\n    } else if (returnStatement?.argument?.type === 'CallExpression') {\n      const arrowFn = returnStatement.argument.arguments.at(0);\n      if (arrowFn?.type === 'ArrowFunctionExpression') {\n        return {\n          numberOfParams: node.params.length,\n          returnNumberOfParams: arrowFn.params.length,\n        };\n      }\n    }\n    return {\n      numberOfParams: node.params.length,\n    };\n  }\n\n  const declaration =\n    'declarations' in node\n      ? node.declarations.find(\n          (d) => d.id.type === 'Identifier' && d.id.name === funcName,\n        )\n      : undefined;\n\n  if (declaration?.init) {\n    if ('name' in declaration.init) {\n      return parseFunction(ast, declaration.init.name);\n    }\n\n    if (\n      'body' in declaration.init &&\n      'params' in declaration.init &&\n      declaration.init.body.type === 'ArrowFunctionExpression'\n    ) {\n      return {\n        numberOfParams: declaration.init.params.length,\n        returnNumberOfParams: declaration.init.body.params.length,\n      };\n    }\n\n    const returnStatement =\n      'body' in declaration.init &&\n      'body' in declaration.init.body &&\n      isArray(declaration.init.body.body)\n        ? declaration.init.body.body.find((b) => b.type === 'ReturnStatement')\n        : undefined;\n\n    if ('params' in declaration.init) {\n      if (returnStatement?.argument && 'params' in returnStatement.argument) {\n        return {\n          numberOfParams: declaration.init.params.length,\n          returnNumberOfParams: returnStatement.argument.params.length,\n        };\n      } else if (\n        returnStatement?.argument?.type === 'CallExpression' &&\n        returnStatement.argument.arguments[0]?.type ===\n          'ArrowFunctionExpression'\n      ) {\n        const arrowFn = returnStatement.argument.arguments[0];\n        return {\n          numberOfParams: declaration.init.params.length,\n          returnNumberOfParams: arrowFn.params.length,\n        };\n      }\n\n      return {\n        numberOfParams: declaration.init.params.length,\n      };\n    }\n  }\n}\n\nfunction getEcmaVersion(target?: TsConfigTarget): ecmaVersion | undefined {\n  if (!target) {\n    return;\n  }\n\n  if (target.toLowerCase() === 'esnext') {\n    return 'latest';\n  }\n\n  try {\n    return Number(target.toLowerCase().replace('es', '')) as ecmaVersion;\n  } catch {\n    return;\n  }\n}\n","import path from 'node:path';\n\nimport chalk from 'chalk';\nimport fs from 'fs-extra';\n\nimport type { GeneratorMutator, NormalizedMutator, Tsconfig } from '../types';\nimport { getFileInfo, pascal, upath } from '../utils';\nimport { getMutatorInfo } from './mutator-info';\n\nexport const BODY_TYPE_NAME = 'BodyType';\n\nconst getImport = (output: string, mutator: NormalizedMutator) => {\n  const outputFileInfo = getFileInfo(output);\n  const mutatorFileInfo = getFileInfo(mutator.path);\n  const { pathWithoutExtension } = getFileInfo(\n    upath.relativeSafe(outputFileInfo.dirname, mutatorFileInfo.path),\n  );\n\n  return `${pathWithoutExtension}${mutator.extension ?? ''}`;\n};\n\ninterface GenerateMutatorOptions {\n  output?: string;\n  mutator?: NormalizedMutator;\n  name: string;\n  workspace: string;\n  tsconfig?: Tsconfig;\n}\n\nexport async function generateMutator({\n  output,\n  mutator,\n  name,\n  workspace,\n  tsconfig,\n}: GenerateMutatorOptions): Promise<GeneratorMutator | undefined> {\n  if (!mutator || !output) {\n    return;\n  }\n  const isDefault = mutator.default;\n  const importName = mutator.name ?? `${name}Mutator`;\n  const importPath = mutator.path;\n  const mutatorInfoName = isDefault ? 'default' : mutator.name;\n\n  if (mutatorInfoName === undefined) {\n    throw new Error(\n      chalk.red(`Mutator ${importPath} must have a named or default export.`),\n    );\n  }\n\n  let rawFile = await fs.readFile(importPath, 'utf8');\n  rawFile = removeComments(rawFile);\n\n  const hasErrorType =\n    rawFile.includes('export type ErrorType') ||\n    rawFile.includes('export interface ErrorType');\n\n  const hasBodyType =\n    rawFile.includes(`export type ${BODY_TYPE_NAME}`) ||\n    rawFile.includes(`export interface ${BODY_TYPE_NAME}`);\n\n  const errorTypeName = mutator.default\n    ? `${pascal(name)}ErrorType`\n    : 'ErrorType';\n\n  const bodyTypeName = mutator.default\n    ? `${pascal(name)}${BODY_TYPE_NAME}`\n    : BODY_TYPE_NAME;\n\n  const mutatorInfo = await getMutatorInfo(importPath, {\n    root: path.resolve(workspace),\n    namedExport: mutatorInfoName,\n    alias: mutator.alias,\n    external: mutator.external,\n    tsconfig,\n  });\n\n  if (!mutatorInfo) {\n    throw new Error(\n      chalk.red(\n        `Your mutator file doesn't have the ${mutatorInfoName} exported function`,\n      ),\n    );\n  }\n\n  const importStatementPath = getImport(output, mutator);\n\n  const isHook = mutator.name\n    ? mutator.name.startsWith('use') && !mutatorInfo.numberOfParams\n    : !mutatorInfo.numberOfParams;\n\n  return {\n    name: mutator.name || !isHook ? importName : `use${pascal(importName)}`,\n    path: importStatementPath,\n    default: isDefault,\n    hasErrorType,\n    errorTypeName,\n    hasSecondArg: isHook\n      ? (mutatorInfo.returnNumberOfParams ?? 0) > 1\n      : mutatorInfo.numberOfParams > 1,\n    hasThirdArg: mutatorInfo.numberOfParams > 2,\n    isHook,\n    ...(hasBodyType ? { bodyTypeName } : {}),\n  };\n}\n\nfunction removeComments(file: string) {\n  // Regular expression to match single-line and multi-line comments\n  const commentRegex = /\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\//g;\n\n  // Remove comments from the rawFile string\n  const cleanedFile = file.replaceAll(commentRegex, '');\n\n  return cleanedFile;\n}\n","import {\n  type GeneratorMutator,\n  type GeneratorSchema,\n  type GetterBody,\n  type GetterQueryParam,\n  type GetterResponse,\n  type ParamsSerializerOptions,\n  Verbs,\n} from '../types';\nimport { getIsBodyVerb, isObject, stringify } from '../utils';\n\ninterface GenerateFormDataAndUrlEncodedFunctionOptions {\n  body: GetterBody;\n  formData?: GeneratorMutator;\n  formUrlEncoded?: GeneratorMutator;\n  isFormData: boolean;\n  isFormUrlEncoded: boolean;\n}\n\nexport function generateBodyOptions(\n  body: GetterBody,\n  isFormData: boolean,\n  isFormUrlEncoded: boolean,\n) {\n  if (isFormData && body.formData) {\n    return '\\n      formData,';\n  }\n\n  if (isFormUrlEncoded && body.formUrlEncoded) {\n    return '\\n      formUrlEncoded,';\n  }\n\n  if (body.implementation) {\n    return `\\n      ${body.implementation},`;\n  }\n\n  return '';\n}\n\ninterface GenerateAxiosOptions {\n  response: GetterResponse;\n  isExactOptionalPropertyTypes: boolean;\n  queryParams?: GeneratorSchema;\n  headers?: GeneratorSchema;\n  requestOptions?: object | boolean;\n  hasSignal: boolean;\n  hasSignalParam?: boolean;\n  isVue: boolean;\n  isAngular: boolean;\n  paramsSerializer?: GeneratorMutator;\n  paramsSerializerOptions?: ParamsSerializerOptions;\n}\n\nexport function generateAxiosOptions({\n  response,\n  isExactOptionalPropertyTypes,\n  queryParams,\n  headers,\n  requestOptions,\n  hasSignal,\n  hasSignalParam = false,\n  isVue,\n  isAngular,\n  paramsSerializer,\n  paramsSerializerOptions,\n}: GenerateAxiosOptions) {\n  const isRequestOptions = requestOptions !== false;\n  // Use querySignal if API has a param named \"signal\" to avoid conflict\n  const signalVar = hasSignalParam ? 'querySignal' : 'signal';\n  const signalProp = hasSignalParam ? `signal: ${signalVar}` : 'signal';\n\n  if (\n    !queryParams &&\n    !headers &&\n    !response.isBlob &&\n    response.definition.success !== 'string'\n  ) {\n    if (isRequestOptions) {\n      return 'options';\n    }\n    if (hasSignal) {\n      return isExactOptionalPropertyTypes\n        ? `...(${signalVar} ? { ${signalProp} } : {})`\n        : signalProp;\n    }\n    return '';\n  }\n\n  let value = '';\n\n  if (!isRequestOptions) {\n    if (queryParams) {\n      value += '\\n        params,';\n    }\n\n    if (headers) {\n      value += '\\n        headers,';\n    }\n\n    if (hasSignal) {\n      value += isExactOptionalPropertyTypes\n        ? `\\n        ...(${signalVar} ? { ${signalProp} } : {}),`\n        : `\\n        ${signalProp},`;\n    }\n  }\n\n  if (\n    !isObject(requestOptions) ||\n    !requestOptions.hasOwnProperty('responseType')\n  ) {\n    if (response.isBlob) {\n      value += `\\n        responseType: 'blob',`;\n    } else if (response.contentTypes.at(0) === 'text/plain') {\n      value += `\\n        responseType: 'text',`;\n    }\n  }\n\n  if (isObject(requestOptions)) {\n    value += `\\n ${stringify(requestOptions)?.slice(1, -1)}`;\n  }\n\n  if (isRequestOptions) {\n    value += '\\n    ...options,';\n\n    if (queryParams) {\n      if (isVue) {\n        value += '\\n        params: {...unref(params), ...options?.params},';\n      } else if (isAngular && paramsSerializer) {\n        value += `\\n        params: ${paramsSerializer.name}({...params, ...options?.params}),`;\n      } else {\n        value += '\\n        params: {...params, ...options?.params},';\n      }\n    }\n\n    if (headers) {\n      value += '\\n        headers: {...headers, ...options?.headers},';\n    }\n  }\n\n  if (\n    !isAngular &&\n    queryParams &&\n    (paramsSerializer || paramsSerializerOptions?.qs)\n  ) {\n    value += paramsSerializer\n      ? `\\n        paramsSerializer: ${paramsSerializer.name},`\n      : `\\n        paramsSerializer: (params) => qs.stringify(params, ${JSON.stringify(\n          paramsSerializerOptions!.qs,\n        )}),`;\n  }\n\n  return value;\n}\n\ninterface GenerateOptionsOptions {\n  route: string;\n  body: GetterBody;\n  headers?: GetterQueryParam;\n  queryParams?: GetterQueryParam;\n  response: GetterResponse;\n  verb: Verbs;\n  requestOptions?: object | boolean;\n  isFormData: boolean;\n  isFormUrlEncoded: boolean;\n  isAngular?: boolean;\n  isExactOptionalPropertyTypes: boolean;\n  hasSignal: boolean;\n  hasSignalParam?: boolean;\n  isVue?: boolean;\n  paramsSerializer?: GeneratorMutator;\n  paramsSerializerOptions?: ParamsSerializerOptions;\n}\n\nexport function generateOptions({\n  route,\n  body,\n  headers,\n  queryParams,\n  response,\n  verb,\n  requestOptions,\n  isFormData,\n  isFormUrlEncoded,\n  isAngular,\n  isExactOptionalPropertyTypes,\n  hasSignal,\n  hasSignalParam,\n  isVue,\n  paramsSerializer,\n  paramsSerializerOptions,\n}: GenerateOptionsOptions) {\n  const bodyOptions = getIsBodyVerb(verb)\n    ? generateBodyOptions(body, isFormData, isFormUrlEncoded)\n    : '';\n\n  const axiosOptions = generateAxiosOptions({\n    response,\n    queryParams: queryParams?.schema,\n    headers: headers?.schema,\n    requestOptions,\n    isExactOptionalPropertyTypes,\n    hasSignal,\n    hasSignalParam,\n    isVue: isVue ?? false,\n    isAngular: isAngular ?? false,\n    paramsSerializer,\n    paramsSerializerOptions,\n  });\n\n  const options = axiosOptions ? `{${axiosOptions}}` : '';\n\n  if (verb === Verbs.DELETE) {\n    if (!bodyOptions) {\n      return `\\n      \\`${route}\\`,${\n        axiosOptions === 'options' ? axiosOptions : options\n      }\\n    `;\n    }\n\n    return `\\n      \\`${route}\\`,{${\n      isAngular ? 'body' : 'data'\n    }:${bodyOptions} ${\n      axiosOptions === 'options' ? `...${axiosOptions}` : axiosOptions\n    }}\\n    `;\n  }\n\n  return `\\n      \\`${route}\\`,${\n    getIsBodyVerb(verb) ? bodyOptions || 'undefined,' : ''\n  }${axiosOptions === 'options' ? axiosOptions : options}\\n    `;\n}\n\nexport function generateBodyMutatorConfig(\n  body: GetterBody,\n  isFormData: boolean,\n  isFormUrlEncoded: boolean,\n) {\n  if (isFormData && body.formData) {\n    return ',\\n       data: formData';\n  }\n\n  if (isFormUrlEncoded && body.formUrlEncoded) {\n    return ',\\n       data: formUrlEncoded';\n  }\n\n  if (body.implementation) {\n    return `,\\n      data: ${body.implementation}`;\n  }\n\n  return '';\n}\n\nexport function generateQueryParamsAxiosConfig(\n  response: GetterResponse,\n  isVue: boolean,\n  queryParams?: GetterQueryParam,\n) {\n  if (!queryParams && !response.isBlob) {\n    return '';\n  }\n\n  let value = '';\n\n  if (queryParams) {\n    value += isVue ? ',\\n        params: unref(params)' : ',\\n        params';\n  }\n\n  if (response.isBlob) {\n    value += `,\\n        responseType: 'blob'`;\n  }\n\n  return value;\n}\n\ninterface GenerateMutatorConfigOptions {\n  route: string;\n  body: GetterBody;\n  headers?: GetterQueryParam;\n  queryParams?: GetterQueryParam;\n  response: GetterResponse;\n  verb: Verbs;\n  isFormData: boolean;\n  isFormUrlEncoded: boolean;\n  hasSignal: boolean;\n  hasSignalParam?: boolean;\n  isExactOptionalPropertyTypes: boolean;\n  isVue?: boolean;\n}\n\nexport function generateMutatorConfig({\n  route,\n  body,\n  headers,\n  queryParams,\n  response,\n  verb,\n  isFormData,\n  isFormUrlEncoded,\n  hasSignal,\n  hasSignalParam = false,\n  isExactOptionalPropertyTypes,\n  isVue,\n}: GenerateMutatorConfigOptions) {\n  const bodyOptions = getIsBodyVerb(verb)\n    ? generateBodyMutatorConfig(body, isFormData, isFormUrlEncoded)\n    : '';\n\n  const queryParamsOptions = generateQueryParamsAxiosConfig(\n    response,\n    isVue ?? false,\n    queryParams,\n  );\n\n  const headerOptions = body.contentType\n    ? `,\\n      headers: {'Content-Type': '${body.contentType}', ${\n        headers ? '...headers' : ''\n      }}`\n    : headers\n      ? ',\\n      headers'\n      : '';\n\n  // Use querySignal if API has a param named \"signal\" to avoid conflict\n  const signalVar = hasSignalParam ? 'querySignal' : 'signal';\n  const signalProp = hasSignalParam ? `signal: ${signalVar}` : 'signal';\n\n  return `{url: \\`${route}\\`, method: '${verb.toUpperCase()}'${headerOptions}${bodyOptions}${queryParamsOptions}${\n    hasSignal\n      ? `, ${\n          isExactOptionalPropertyTypes\n            ? `...(${signalVar} ? { ${signalProp} }: {})`\n            : signalProp\n        }`\n      : ''\n  }\\n    }`;\n}\n\nexport function generateMutatorRequestOptions(\n  requestOptions: boolean | object | undefined,\n  hasSecondArgument: boolean,\n) {\n  if (!hasSecondArgument) {\n    return isObject(requestOptions)\n      ? `{${stringify(requestOptions)?.slice(1, -1)}}`\n      : '';\n  }\n\n  if (isObject(requestOptions)) {\n    return `{${stringify(requestOptions)?.slice(1, -1)} ...options}`;\n  }\n\n  return 'options';\n}\n\nexport function generateFormDataAndUrlEncodedFunction({\n  body,\n  formData,\n  formUrlEncoded,\n  isFormData,\n  isFormUrlEncoded,\n}: GenerateFormDataAndUrlEncodedFunctionOptions) {\n  if (isFormData && body.formData) {\n    if (formData) {\n      return `const formData = ${formData.name}(${body.implementation})`;\n    }\n\n    return body.formData;\n  }\n\n  if (isFormUrlEncoded && body.formUrlEncoded) {\n    if (formUrlEncoded) {\n      return `const formUrlEncoded = ${formUrlEncoded.name}(${body.implementation})`;\n    }\n\n    return body.formUrlEncoded;\n  }\n\n  return '';\n}\n","import { entries, isEmptyish } from 'remeda';\n\nimport { resolveObject, resolveRef } from '../resolvers';\nimport type {\n  ContextSpec,\n  GeneratorSchema,\n  OpenApiComponentsObject,\n  OpenApiParameterObject,\n} from '../types';\nimport { jsDoc, pascal, sanitize } from '../utils';\n\nexport function generateParameterDefinition(\n  parameters: OpenApiComponentsObject['parameters'] = {},\n  context: ContextSpec,\n  suffix: string,\n): GeneratorSchema[] {\n  if (isEmptyish(parameters)) {\n    return [];\n  }\n\n  const generatorSchemas: GeneratorSchema[] = [];\n  for (const [parameterName, parameter] of entries(parameters)) {\n    const modelName = sanitize(`${pascal(parameterName)}${suffix}`, {\n      underscore: '_',\n      whitespace: '_',\n      dash: true,\n      es5keyword: true,\n      es5IdentifierName: true,\n    });\n    const { schema, imports } = resolveRef<OpenApiParameterObject>(\n      parameter,\n      context,\n    );\n\n    if (schema.in !== 'query' && schema.in !== 'header') {\n      continue;\n    }\n\n    if (!schema.schema || imports.length > 0) {\n      generatorSchemas.push({\n        name: modelName,\n        imports:\n          imports.length > 0\n            ? [\n                {\n                  name: imports[0].name,\n                  schemaName: imports[0].schemaName,\n                },\n              ]\n            : [],\n        model: `export type ${modelName} = ${\n          imports.length > 0 ? imports[0].name : 'unknown'\n        };\\n`,\n        dependencies: imports.length > 0 ? [imports[0].name] : [],\n      });\n\n      continue;\n    }\n\n    const resolvedObject = resolveObject({\n      schema: schema.schema,\n      propName: modelName,\n      context,\n    });\n\n    const doc = jsDoc(schema);\n\n    const model = `${doc}export type ${modelName} = ${\n      resolvedObject.value || 'unknown'\n    };\\n`;\n\n    generatorSchemas.push(...resolvedObject.schemas);\n\n    if (modelName !== resolvedObject.value) {\n      generatorSchemas.push({\n        name: modelName,\n        model,\n        imports: resolvedObject.imports,\n        dependencies: resolvedObject.dependencies,\n      });\n    }\n  }\n\n  return generatorSchemas;\n}\n","import { getScalar } from '../getters';\nimport type { ContextSpec, OpenApiSchemaObject } from '../types';\nimport { jsDoc } from '../utils';\n\ninterface GenerateInterfaceOptions {\n  name: string;\n  schema: OpenApiSchemaObject;\n  context: ContextSpec;\n}\n\n/**\n * Generate the interface string\n * An eslint comment is insert if the resulted object is empty\n *\n * @param name interface name\n * @param schema\n */\nexport function generateInterface({\n  name,\n  schema,\n  context,\n}: GenerateInterfaceOptions) {\n  const scalar = getScalar({\n    item: schema,\n    name,\n    context,\n  });\n  const isEmptyObject = scalar.value === '{}';\n  const shouldUseTypeAlias =\n    context?.output.override?.useTypeOverInterfaces || scalar.useTypeAlias;\n\n  let model = '';\n\n  model += jsDoc(schema);\n\n  if (isEmptyObject) {\n    model +=\n      '// eslint-disable-next-line @typescript-eslint/no-empty-interface\\n';\n  }\n\n  if (scalar.type === 'object' && !shouldUseTypeAlias) {\n    if (\n      scalar.type === 'object' &&\n      schema.properties &&\n      Object.values(schema.properties).length > 0 &&\n      Object.values(schema.properties).every((item) => 'const' in item)\n    ) {\n      const mappedScalarValue = scalar.value\n        .replaceAll(';', ',')\n        .replaceAll('?:', ':');\n\n      model += `export const ${name}Value = ${mappedScalarValue} as const;\\nexport type ${name} = typeof ${name}Value;\\n`;\n    } else {\n      const blankInterfaceValue =\n        scalar.value === 'unknown' ? '{}' : scalar.value;\n\n      model += `export interface ${name} ${blankInterfaceValue}\\n`;\n    }\n  } else {\n    model += `export type ${name} = ${scalar.value};\\n`;\n  }\n\n  // Filter out imports that refer to the type defined in current file (OpenAPI recursive schema definitions)\n  const externalModulesImportsOnly = scalar.imports.filter((importName) =>\n    importName.alias ? importName.alias !== name : importName.name !== name,\n  );\n\n  return [\n    ...scalar.schemas,\n    {\n      name,\n      model,\n      imports: externalModulesImportsOnly,\n      dependencies: scalar.dependencies,\n      schema,\n    },\n  ];\n}\n","import { isDereferenced } from '@scalar/openapi-types/helpers';\nimport { isArray, isEmptyish } from 'remeda';\n\nimport {\n  getEnum,\n  getEnumDescriptions,\n  getEnumNames,\n  resolveDiscriminators,\n} from '../getters';\nimport { resolveRef, resolveValue } from '../resolvers';\nimport type {\n  ContextSpec,\n  GeneratorSchema,\n  InputFiltersOptions,\n  OpenApiSchemaObject,\n  OpenApiSchemasObject,\n} from '../types';\nimport { conventionName, isString, jsDoc, pascal, sanitize } from '../utils';\nimport { generateInterface } from './interface';\n\n/**\n * Extract all types from #/components/schemas\n */\nexport function generateSchemasDefinition(\n  schemas: OpenApiSchemasObject = {},\n  context: ContextSpec,\n  suffix: string,\n  filters?: InputFiltersOptions,\n): GeneratorSchema[] {\n  if (isEmptyish(schemas)) {\n    return [];\n  }\n\n  const transformedSchemas = resolveDiscriminators(schemas, context);\n\n  let generateSchemas = Object.entries(transformedSchemas);\n  if (filters?.schemas) {\n    const schemasFilters = filters.schemas;\n    const mode = filters.mode ?? 'include';\n\n    generateSchemas = generateSchemas.filter(([schemaName]) => {\n      const isMatch = schemasFilters.some((filter) =>\n        isString(filter) ? filter === schemaName : filter.test(schemaName),\n      );\n\n      return mode === 'include' ? isMatch : !isMatch;\n    });\n  }\n\n  const models = generateSchemas.flatMap(([schemaName, schema]) =>\n    generateSchemaDefinitions(schemaName, schema, context, suffix),\n  );\n\n  // Deduplicate schemas by normalized name to prevent duplicate exports\n  // This handles cases where different source schemas produce the same normalized name\n  const seenNames = new Set<string>();\n  const deduplicatedModels: GeneratorSchema[] = [];\n  for (const schema of models) {\n    const normalizedName = conventionName(\n      schema.name,\n      context.output.namingConvention,\n    );\n    if (!seenNames.has(normalizedName)) {\n      seenNames.add(normalizedName);\n      deduplicatedModels.push(schema);\n    }\n  }\n\n  return sortSchemasByDependencies(deduplicatedModels);\n}\n\nfunction sortSchemasByDependencies(\n  schemas: GeneratorSchema[],\n): GeneratorSchema[] {\n  if (schemas.length === 0) {\n    return schemas;\n  }\n\n  const schemaNames = new Set(schemas.map((schema) => schema.name));\n  const dependencyMap = new Map<string, Set<string>>();\n\n  for (const schema of schemas) {\n    const dependencies = new Set<string>();\n\n    if (schema.dependencies)\n      for (const dependencyName of schema.dependencies) {\n        if (dependencyName && schemaNames.has(dependencyName)) {\n          dependencies.add(dependencyName);\n        }\n      }\n\n    for (const imp of schema.imports) {\n      const dependencyName = imp.alias || imp.name;\n      if (dependencyName && schemaNames.has(dependencyName)) {\n        dependencies.add(dependencyName);\n      }\n    }\n\n    dependencyMap.set(schema.name, dependencies);\n  }\n\n  const sorted: GeneratorSchema[] = [];\n  const temporary = new Set<string>();\n  const permanent = new Set<string>();\n  const schemaMap = new Map(schemas.map((schema) => [schema.name, schema]));\n\n  const visit = (name: string) => {\n    if (permanent.has(name)) {\n      return;\n    }\n\n    if (temporary.has(name)) {\n      // Circular dependency detected; retain current DFS order for this cycle\n      return;\n    }\n\n    temporary.add(name);\n\n    const dependencies = dependencyMap.get(name);\n    if (dependencies)\n      for (const dep of dependencies) {\n        if (dep !== name) {\n          visit(dep);\n        }\n      }\n\n    temporary.delete(name);\n    permanent.add(name);\n\n    const schema = schemaMap.get(name);\n    if (schema) {\n      sorted.push(schema);\n    }\n  };\n\n  for (const schema of schemas) visit(schema.name);\n\n  return sorted;\n}\n\nfunction shouldCreateInterface(schema: OpenApiSchemaObject) {\n  const isNullable = isArray(schema.type) && schema.type.includes('null');\n\n  return (\n    (!schema.type || schema.type === 'object') &&\n    !schema.allOf &&\n    !schema.oneOf &&\n    !schema.anyOf &&\n    isDereferenced(schema) &&\n    !schema.enum &&\n    !isNullable\n  );\n}\n\nfunction generateSchemaDefinitions(\n  schemaName: string,\n  schema: OpenApiSchemaObject,\n  context: ContextSpec,\n  suffix: string,\n): GeneratorSchema[] {\n  const sanitizedSchemaName = sanitize(`${pascal(schemaName)}${suffix}`, {\n    underscore: '_',\n    whitespace: '_',\n    dash: true,\n    es5keyword: true,\n    es5IdentifierName: true,\n  });\n\n  if (typeof schema === 'boolean') {\n    return [\n      {\n        name: sanitizedSchemaName,\n        model: `export type ${sanitizedSchemaName} = ${schema ? 'any' : 'never'};\\n`,\n        imports: [],\n        schema: schema as any,\n      },\n    ];\n  }\n\n  if (shouldCreateInterface(schema)) {\n    return generateInterface({\n      name: sanitizedSchemaName,\n      schema,\n      context,\n    });\n  }\n\n  const resolvedValue = resolveValue({\n    schema,\n    name: sanitizedSchemaName,\n    context,\n  });\n\n  let output = '';\n\n  let imports = resolvedValue.imports;\n\n  output += jsDoc(schema);\n\n  if (resolvedValue.isEnum && !resolvedValue.isRef) {\n    output += getEnum(\n      resolvedValue.value,\n      sanitizedSchemaName,\n      getEnumNames(resolvedValue.originalSchema),\n      context.output.override.enumGenerationType,\n      getEnumDescriptions(resolvedValue.originalSchema),\n      context.output.override.namingConvention?.enum,\n    );\n  } else if (\n    sanitizedSchemaName === resolvedValue.value &&\n    resolvedValue.isRef\n  ) {\n    // Don't add type if schema has same name and the referred schema will be an interface\n    const { schema: referredSchema } = resolveRef(schema, context);\n    if (!shouldCreateInterface(referredSchema as OpenApiSchemaObject)) {\n      const imp = resolvedValue.imports.find(\n        (imp) => imp.name === sanitizedSchemaName,\n      );\n\n      if (imp) {\n        const alias = `${resolvedValue.value}Bis`;\n\n        output += `export type ${sanitizedSchemaName} = ${alias};\\n`;\n\n        imports = imports.map((imp) =>\n          imp.name === sanitizedSchemaName ? { ...imp, alias } : imp,\n        );\n        resolvedValue.dependencies = [imp.name];\n      } else {\n        output += `export type ${sanitizedSchemaName} = ${resolvedValue.value};\\n`;\n      }\n    }\n  } else {\n    resolvedValue.schemas = resolvedValue.schemas.filter((schema) => {\n      if (schema.name !== sanitizedSchemaName) {\n        return true;\n      }\n\n      output += `${schema.model}\\n`;\n      imports = imports.concat(schema.imports);\n      resolvedValue.dependencies.push(...(schema.dependencies ?? []));\n\n      return false;\n    });\n    output += `export type ${sanitizedSchemaName} = ${resolvedValue.value};\\n`;\n  }\n\n  return [\n    ...resolvedValue.schemas,\n    {\n      name: sanitizedSchemaName,\n      model: output,\n      imports,\n      dependencies: resolvedValue.dependencies,\n      schema,\n    },\n  ];\n}\n","import {\n  getBody,\n  getOperationId,\n  getParameters,\n  getParams,\n  getProps,\n  getQueryParams,\n  getResponse,\n} from '../getters';\nimport type {\n  ContextSpec,\n  GeneratorVerbOptions,\n  GeneratorVerbsOptions,\n  NormalizedInputOptions,\n  NormalizedMutator,\n  NormalizedOperationOptions,\n  NormalizedOutputOptions,\n  OpenApiComponentsObject,\n  OpenApiOperationObject,\n  OpenApiPathItemObject,\n  Verbs,\n} from '../types';\nimport {\n  asyncReduce,\n  camel,\n  dynamicImport,\n  isObject,\n  isString,\n  isVerb,\n  jsDoc,\n  mergeDeep,\n  sanitize,\n} from '../utils';\nimport { generateMutator } from './mutator';\n\nexport interface GenerateVerbOptionsParams {\n  verb: Verbs;\n  output: NormalizedOutputOptions;\n  operation: OpenApiOperationObject;\n  route: string;\n  pathRoute: string;\n  verbParameters?: OpenApiPathItemObject['parameters'];\n  components?: OpenApiComponentsObject;\n  context: ContextSpec;\n}\n\nexport async function generateVerbOptions({\n  verb,\n  output,\n  operation,\n  route,\n  pathRoute,\n  verbParameters = [],\n  context,\n}: GenerateVerbOptionsParams): Promise<GeneratorVerbOptions> {\n  const {\n    responses,\n    requestBody,\n    parameters: operationParameters,\n    tags = [],\n    deprecated,\n    description,\n    summary,\n  } = operation;\n  const operationId = getOperationId(operation, route, verb);\n  const overrideOperation = output.override.operations[operationId];\n  const overrideTag = Object.entries(\n    output.override.tags,\n  ).reduce<NormalizedOperationOptions>(\n    (acc, [tag, options]) =>\n      tags.includes(tag) && options ? mergeDeep(acc, options) : acc,\n    {},\n  );\n\n  const override = mergeDeep(\n    mergeDeep(output.override, overrideTag),\n    overrideOperation,\n  );\n\n  const overrideOperationName =\n    overrideOperation?.operationName ?? output.override.operationName;\n  const operationName = overrideOperationName\n    ? overrideOperationName(operation, route, verb)\n    : sanitize(camel(operationId), { es5keyword: true });\n\n  const response = getResponse({\n    responses,\n    operationName,\n    context,\n    contentType: override.contentType,\n  });\n\n  const body = getBody({\n    requestBody: requestBody!,\n    operationName,\n    context,\n    contentType: override.contentType,\n  });\n\n  const parameters = getParameters({\n    parameters: [...verbParameters, ...(operationParameters ?? [])],\n    context,\n  });\n\n  const queryParams = getQueryParams({\n    queryParams: parameters.query,\n    operationName,\n    context,\n  });\n\n  const headers = output.headers\n    ? getQueryParams({\n        queryParams: parameters.header,\n        operationName,\n        context,\n        suffix: 'headers',\n      })\n    : undefined;\n\n  const params = getParams({\n    route,\n    pathParams: parameters.path,\n    operationId: operationId!,\n    context,\n    output,\n  });\n\n  const props = getProps({\n    body,\n    queryParams,\n    params,\n    headers,\n    operationName,\n    context,\n  });\n\n  const mutator = await generateMutator({\n    output: output.target,\n    name: operationName,\n    mutator: override.mutator,\n    workspace: context.workspace,\n    tsconfig: context.output.tsconfig,\n  });\n\n  const formData =\n    !override.formData.disabled && body.formData\n      ? await generateMutator({\n          output: output.target,\n          name: operationName,\n          mutator: override.formData.mutator,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n  const formUrlEncoded =\n    isString(override.formUrlEncoded) || isObject(override.formUrlEncoded)\n      ? await generateMutator({\n          output: output.target,\n          name: operationName,\n          mutator: override.formUrlEncoded,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n  const paramsSerializer =\n    isString(override.paramsSerializer) || isObject(override.paramsSerializer)\n      ? await generateMutator({\n          output: output.target,\n          name: 'paramsSerializer',\n          mutator: override.paramsSerializer as NormalizedMutator,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n  const fetchReviver =\n    isString(override.fetch.jsonReviver) || isObject(override.fetch.jsonReviver)\n      ? await generateMutator({\n          output: output.target,\n          name: 'fetchReviver',\n          mutator: override.fetch.jsonReviver as NormalizedMutator,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n  const doc = jsDoc({ description, deprecated, summary });\n\n  const verbOption: GeneratorVerbOptions = {\n    verb: verb as Verbs,\n    tags,\n    route,\n    pathRoute,\n    summary: operation.summary,\n    operationId,\n    operationName,\n    response,\n    body,\n    headers,\n    queryParams,\n    params,\n    props,\n    mutator,\n    formData,\n    formUrlEncoded,\n    paramsSerializer,\n    fetchReviver,\n    override,\n    doc,\n    deprecated,\n    originalOperation: operation,\n  };\n\n  const transformer = await dynamicImport(\n    override.transformer,\n    context.workspace,\n  );\n\n  return transformer ? transformer(verbOption) : verbOption;\n}\n\nexport interface GenerateVerbsOptionsParams {\n  verbs: OpenApiPathItemObject;\n  input: NormalizedInputOptions;\n  output: NormalizedOutputOptions;\n  route: string;\n  pathRoute: string;\n  context: ContextSpec;\n}\n\nexport function generateVerbsOptions({\n  verbs,\n  input,\n  output,\n  route,\n  pathRoute,\n  context,\n}: GenerateVerbsOptionsParams): Promise<GeneratorVerbsOptions> {\n  return asyncReduce(\n    _filteredVerbs(verbs, input.filters),\n    async (acc, [verb, operation]: [string, OpenApiOperationObject]) => {\n      if (isVerb(verb)) {\n        const verbOptions = await generateVerbOptions({\n          verb,\n          output,\n          verbParameters: verbs.parameters,\n          route,\n          pathRoute,\n          operation,\n          context,\n        });\n\n        acc.push(verbOptions);\n      }\n\n      return acc;\n    },\n    [] as GeneratorVerbsOptions,\n  );\n}\n\nexport function _filteredVerbs(\n  verbs: OpenApiPathItemObject,\n  filters: NormalizedInputOptions['filters'],\n) {\n  if (filters?.tags === undefined) {\n    return Object.entries(verbs);\n  }\n\n  const filterTags = filters.tags || [];\n  const filterMode = filters.mode ?? 'include';\n\n  return Object.entries(verbs).filter(\n    ([, operation]: [string, OpenApiOperationObject]) => {\n      const operationTags = operation.tags ?? [];\n\n      const isMatch = operationTags.some((tag) =>\n        filterTags.some((filterTag) =>\n          filterTag instanceof RegExp ? filterTag.test(tag) : filterTag === tag,\n        ),\n      );\n\n      return filterMode === 'exclude' ? !isMatch : isMatch;\n    },\n  );\n}\n","import fs from 'fs-extra';\nimport { groupBy } from 'remeda';\n\nimport { generateImports } from '../generators';\nimport {\n  type GeneratorImport,\n  type GeneratorSchema,\n  NamingConvention,\n} from '../types';\nimport { conventionName, upath } from '../utils';\n\ntype CanonicalInfo = Pick<GeneratorImport, 'importPath' | 'name'>;\n\n/**\n * Patterns to detect operation-derived types (params, bodies, responses).\n * These types are auto-generated from OpenAPI operations, not from component schemas.\n */\nconst OPERATION_TYPE_PATTERNS = [\n  /Params$/i, // GetUserParams, ListUsersParams\n  /Body$/, // CreateUserBody, UpdatePostBody (case-sensitive to avoid \"Antibody\")\n  /Body(One|Two|Three|Four|Five|Item)$/, // BodyOne, BodyTwo (union body types)\n  /Parameter$/i, // PageParameter, LimitParameter\n  /Query$/i, // GetUserQuery\n  /Header$/i, // AuthHeader\n  /Response\\d*$/i, // GetUser200Response, NotFoundResponse\n  /^[1-5]\\d{2}$/, // 200, 201, 404 (valid HTTP status codes: 1xx-5xx)\n  /\\d{3}(One|Two|Three|Four|Five|Item)$/i, // 200One, 200Two (union response types)\n  /^(get|post|put|patch|delete|head|options)[A-Z].*\\d{3}$/, // operation types with status codes (get...200, post...404)\n];\n\n/**\n * Check if a schema name matches operation type patterns.\n */\nfunction isOperationType(schemaName: string): boolean {\n  return OPERATION_TYPE_PATTERNS.some((pattern) => pattern.test(schemaName));\n}\n\n/**\n * Split schemas into regular and operation types.\n */\nexport function splitSchemasByType(schemas: GeneratorSchema[]): {\n  regularSchemas: GeneratorSchema[];\n  operationSchemas: GeneratorSchema[];\n} {\n  const regularSchemas: GeneratorSchema[] = [];\n  const operationSchemas: GeneratorSchema[] = [];\n\n  for (const schema of schemas) {\n    if (isOperationType(schema.name)) {\n      operationSchemas.push(schema);\n    } else {\n      regularSchemas.push(schema);\n    }\n  }\n\n  return { regularSchemas, operationSchemas };\n}\n\n/**\n * Fix cross-directory imports when schemas reference other schemas in a different directory.\n * Updates import paths to use correct relative paths between directories.\n */\nfunction fixSchemaImports(\n  schemas: GeneratorSchema[],\n  targetSchemaNames: Set<string>,\n  fromPath: string,\n  toPath: string,\n  namingConvention: NamingConvention,\n): void {\n  const relativePath = upath.relativeSafe(fromPath, toPath);\n\n  for (const schema of schemas) {\n    schema.imports = schema.imports.map((imp) => {\n      if (targetSchemaNames.has(imp.name)) {\n        const fileName = conventionName(imp.name, namingConvention);\n        return {\n          ...imp,\n          importPath: upath.joinSafe(relativePath, fileName),\n        };\n      }\n      return imp;\n    });\n  }\n}\n\n/**\n * Fix imports in operation schemas that reference regular schemas.\n */\nexport function fixCrossDirectoryImports(\n  operationSchemas: GeneratorSchema[],\n  regularSchemaNames: Set<string>,\n  schemaPath: string,\n  operationSchemaPath: string,\n  namingConvention: NamingConvention,\n): void {\n  fixSchemaImports(\n    operationSchemas,\n    regularSchemaNames,\n    operationSchemaPath,\n    schemaPath,\n    namingConvention,\n  );\n}\n\n/**\n * Fix imports in regular schemas that reference operation schemas.\n */\nexport function fixRegularSchemaImports(\n  regularSchemas: GeneratorSchema[],\n  operationSchemaNames: Set<string>,\n  schemaPath: string,\n  operationSchemaPath: string,\n  namingConvention: NamingConvention,\n): void {\n  fixSchemaImports(\n    regularSchemas,\n    operationSchemaNames,\n    schemaPath,\n    operationSchemaPath,\n    namingConvention,\n  );\n}\n\nfunction getSchemaKey(\n  schemaPath: string,\n  schemaName: string,\n  namingConvention: NamingConvention,\n  fileExtension: string,\n) {\n  return getPath(\n    schemaPath,\n    conventionName(schemaName, namingConvention),\n    fileExtension,\n  )\n    .toLowerCase()\n    .replaceAll('\\\\', '/');\n}\n\nfunction getSchemaGroups(\n  schemaPath: string,\n  schemas: GeneratorSchema[],\n  namingConvention: NamingConvention,\n  fileExtension: string,\n) {\n  return groupBy(schemas, (schema) =>\n    getSchemaKey(schemaPath, schema.name, namingConvention, fileExtension),\n  );\n}\n\nfunction getCanonicalMap(\n  schemaGroups: Record<string, GeneratorSchema[]>,\n  schemaPath: string,\n  namingConvention: NamingConvention,\n  fileExtension: string,\n) {\n  const canonicalPathMap = new Map<string, CanonicalInfo>();\n  for (const [key, groupSchemas] of Object.entries(schemaGroups)) {\n    const canonicalPath = getPath(\n      schemaPath,\n      conventionName(groupSchemas[0].name, namingConvention),\n      fileExtension,\n    );\n\n    canonicalPathMap.set(key, {\n      importPath: canonicalPath,\n      name: groupSchemas[0].name,\n    });\n  }\n  return canonicalPathMap;\n}\n\nfunction normalizeCanonicalImportPaths(\n  schemas: GeneratorSchema[],\n  canonicalPathMap: Map<string, CanonicalInfo>,\n  schemaPath: string,\n  namingConvention: NamingConvention,\n  fileExtension: string,\n) {\n  for (const schema of schemas) {\n    schema.imports = schema.imports.map((imp) => {\n      const resolvedImportKey = resolveImportKey(\n        schemaPath,\n        imp.importPath ?? `./${conventionName(imp.name, namingConvention)}`,\n        fileExtension,\n      );\n      const canonical = canonicalPathMap.get(resolvedImportKey);\n      if (!canonical?.importPath) return imp;\n\n      const importPath = removeFileExtension(\n        upath.relativeSafe(\n          schemaPath,\n          canonical.importPath.replaceAll('\\\\', '/'),\n        ),\n        fileExtension,\n      );\n\n      return { ...imp, importPath };\n    });\n  }\n}\n\nfunction mergeSchemaGroup(schemas: GeneratorSchema[]): GeneratorSchema {\n  const baseSchemaName = schemas[0].name;\n  const baseSchema = schemas[0].schema;\n  const mergedImports = [\n    ...new Map(\n      schemas\n        .flatMap((schema) => schema.imports)\n        .map((imp) => [JSON.stringify(imp), imp]),\n    ).values(),\n  ];\n  const mergedDependencies = [\n    ...new Set(schemas.flatMap((schema) => schema.dependencies ?? [])),\n  ];\n  return {\n    name: baseSchemaName,\n    schema: baseSchema,\n    model: schemas.map((schema) => schema.model).join('\\n'),\n    imports: mergedImports,\n    dependencies: mergedDependencies,\n  };\n}\n\nfunction resolveImportKey(\n  schemaPath: string,\n  importPath: string,\n  fileExtension: string,\n) {\n  return upath\n    .join(schemaPath, `${importPath}${fileExtension}`)\n    .toLowerCase()\n    .replaceAll('\\\\', '/');\n}\n\nfunction removeFileExtension(path: string, fileExtension: string) {\n  return path.endsWith(fileExtension)\n    ? path.slice(0, path.length - fileExtension.length)\n    : path;\n}\n\ninterface GetSchemaOptions {\n  schema: GeneratorSchema;\n  target: string;\n  header: string;\n  namingConvention?: NamingConvention;\n}\n\nfunction getSchema({\n  schema: { imports, model },\n  target,\n  header,\n  namingConvention = NamingConvention.CAMEL_CASE,\n}: GetSchemaOptions): string {\n  let file = header;\n  file += generateImports({\n    imports: imports.filter(\n      (imp) =>\n        !model.includes(`type ${imp.alias || imp.name} =`) &&\n        !model.includes(`interface ${imp.alias || imp.name} {`),\n    ),\n    target,\n    namingConvention,\n  });\n  file += imports.length > 0 ? '\\n\\n' : '\\n';\n  file += model;\n  return file;\n}\n\nfunction getPath(path: string, name: string, fileExtension: string): string {\n  return upath.join(path, `/${name}${fileExtension}`);\n}\n\nexport function writeModelInline(acc: string, model: string): string {\n  return acc + `${model}\\n`;\n}\n\nexport function writeModelsInline(array: GeneratorSchema[]): string {\n  let acc = '';\n  for (const { model } of array) {\n    acc = writeModelInline(acc, model);\n  }\n  return acc;\n}\n\ninterface WriteSchemaOptions {\n  path: string;\n  schema: GeneratorSchema;\n  target: string;\n  namingConvention: NamingConvention;\n  fileExtension: string;\n  header: string;\n}\n\nexport async function writeSchema({\n  path,\n  schema,\n  target,\n  namingConvention,\n  fileExtension,\n  header,\n}: WriteSchemaOptions) {\n  const name = conventionName(schema.name, namingConvention);\n\n  try {\n    await fs.outputFile(\n      getPath(path, name, fileExtension),\n      getSchema({\n        schema,\n        target,\n        header,\n        namingConvention,\n      }),\n    );\n  } catch (error) {\n    throw new Error(\n      `Oups... . An Error occurred while writing schema ${name} => ${error}`,\n    );\n  }\n}\n\ninterface WriteSchemasOptions {\n  schemaPath: string;\n  schemas: GeneratorSchema[];\n  target: string;\n  namingConvention: NamingConvention;\n  fileExtension: string;\n  header: string;\n  indexFiles: boolean;\n}\n\nexport async function writeSchemas({\n  schemaPath,\n  schemas,\n  target,\n  namingConvention,\n  fileExtension,\n  header,\n  indexFiles,\n}: WriteSchemasOptions) {\n  const schemaGroups = getSchemaGroups(\n    schemaPath,\n    schemas,\n    namingConvention,\n    fileExtension,\n  );\n\n  const canonicalPathByKey = getCanonicalMap(\n    schemaGroups,\n    schemaPath,\n    namingConvention,\n    fileExtension,\n  );\n\n  normalizeCanonicalImportPaths(\n    schemas,\n    canonicalPathByKey,\n    schemaPath,\n    namingConvention,\n    fileExtension,\n  );\n\n  for (const groupSchemas of Object.values(schemaGroups)) {\n    if (groupSchemas.length === 1) {\n      await writeSchema({\n        path: schemaPath,\n        schema: groupSchemas[0],\n        target,\n        namingConvention,\n        fileExtension,\n        header,\n      });\n      continue;\n    }\n\n    const mergedSchema = mergeSchemaGroup(groupSchemas);\n\n    await writeSchema({\n      path: schemaPath,\n      schema: mergedSchema,\n      target,\n      namingConvention,\n      fileExtension,\n      header,\n    });\n  }\n\n  if (indexFiles) {\n    const schemaFilePath = upath.join(schemaPath, `/index${fileExtension}`);\n    await fs.ensureFile(schemaFilePath);\n\n    // Ensure separate files are used for parallel schema writing.\n    // Throw an exception if duplicates are detected (using convention names)\n    const ext = fileExtension.endsWith('.ts')\n      ? fileExtension.slice(0, -3)\n      : fileExtension;\n    const conventionNamesSet = new Set(\n      Object.values(schemaGroups).map((group) =>\n        conventionName(group[0].name, namingConvention),\n      ),\n    );\n\n    try {\n      // Create unique export statements from schemas (deduplicate by schema name)\n      const uniqueSchemaNames = [...conventionNamesSet];\n\n      // Create export statements\n      const currentExports = uniqueSchemaNames\n        .map((schemaName) => `export * from './${schemaName}${ext}';`)\n        .toSorted((a, b) => a.localeCompare(b));\n\n      const existingContent = await fs.readFile(schemaFilePath, 'utf8');\n      const existingExports =\n        existingContent\n          .match(/export\\s+\\*\\s+from\\s+['\"][^'\"]+['\"]/g)\n          ?.map((statement) => {\n            const match = statement.match(\n              /export\\s+\\*\\s+from\\s+['\"]([^'\"]+)['\"]/,\n            );\n            if (!match) return undefined;\n            return `export * from '${match[1]}';`;\n          })\n          .filter((statement): statement is string => Boolean(statement)) ?? [];\n\n      const exports = [...new Set([...existingExports, ...currentExports])]\n        .toSorted((a, b) => a.localeCompare(b))\n        .join('\\n');\n\n      const fileContent = `${header}\\n${exports}`;\n\n      await fs.writeFile(schemaFilePath, fileContent, { encoding: 'utf8' });\n    } catch (error) {\n      throw new Error(\n        `Oups... . An Error occurred while writing schema index file ${schemaFilePath} => ${error}`,\n      );\n    }\n  }\n}\n","import { uniqueBy } from 'remeda';\n\nimport type { GeneratorImport, NormalizedOutputOptions } from '../types';\nimport { conventionName, isObject, upath } from '../utils';\n\nexport function generateImportsForBuilder(\n  output: NormalizedOutputOptions,\n  imports: GeneratorImport[],\n  relativeSchemasPath: string,\n) {\n  const isZodSchemaOutput =\n    isObject(output.schemas) && output.schemas.type === 'zod';\n\n  if (!output.indexFiles) {\n    return uniqueBy(imports, (x) => x.name).map((i) => {\n      const baseName = i.schemaName || i.name;\n      const name = conventionName(baseName, output.namingConvention);\n      const suffix = isZodSchemaOutput ? '.zod' : '';\n      const importExtension = output.fileExtension?.replace(/\\.ts$/, '') || '';\n      return {\n        exports: isZodSchemaOutput ? [{ ...i, values: true }] : [i],\n        dependency: upath.joinSafe(\n          relativeSchemasPath,\n          `${name}${suffix}${importExtension}`,\n        ),\n      };\n    });\n  } else {\n    if (isZodSchemaOutput) {\n      return [\n        {\n          exports: imports.map((i) => ({ ...i, values: true })),\n          dependency: upath.joinSafe(relativeSchemasPath, 'index.zod'),\n        },\n      ];\n    } else {\n      return [{ exports: imports, dependency: relativeSchemasPath }];\n    }\n  }\n}\n","import {\n  type GeneratorTarget,\n  type GeneratorTargetFull,\n  type NormalizedOutputOptions,\n  OutputClient,\n  type WriteSpecBuilder,\n} from '../types';\nimport { compareVersions, pascal } from '../utils';\n\nexport function generateTarget(\n  builder: WriteSpecBuilder,\n  options: NormalizedOutputOptions,\n): GeneratorTarget {\n  const operationNames = Object.values(builder.operations).map(\n    ({ operationName }) => operationName,\n  );\n  const isAngularClient = options?.client === OutputClient.ANGULAR;\n\n  const titles = builder.title({\n    outputClient: options.client,\n    title: pascal(builder.info.title),\n    customTitleFunc: options.override.title,\n    output: options,\n  });\n\n  const target = Object.values(builder.operations).reduce<\n    Required<GeneratorTargetFull>\n  >(\n    (acc, operation, index, arr) => {\n      acc.imports.push(...operation.imports);\n      acc.importsMock.push(...operation.importsMock);\n      acc.implementation += operation.implementation + '\\n';\n      acc.implementationMock.function += operation.implementationMock.function;\n      acc.implementationMock.handler += operation.implementationMock.handler;\n\n      const handlerNameSeparator =\n        acc.implementationMock.handlerName.length > 0 ? ',\\n  ' : '  ';\n      acc.implementationMock.handlerName +=\n        handlerNameSeparator + operation.implementationMock.handlerName + '()';\n\n      if (operation.mutator) {\n        acc.mutators.push(operation.mutator);\n      }\n\n      if (operation.formData) {\n        acc.formData.push(operation.formData);\n      }\n      if (operation.formUrlEncoded) {\n        acc.formUrlEncoded.push(operation.formUrlEncoded);\n      }\n      if (operation.paramsSerializer) {\n        acc.paramsSerializer.push(operation.paramsSerializer);\n      }\n\n      if (operation.clientMutators) {\n        acc.clientMutators.push(...operation.clientMutators);\n      }\n\n      if (operation.fetchReviver) {\n        acc.fetchReviver.push(operation.fetchReviver);\n      }\n\n      if (index === arr.length - 1) {\n        const isMutator = acc.mutators.some((mutator) =>\n          isAngularClient ? mutator.hasThirdArg : mutator.hasSecondArg,\n        );\n\n        const typescriptVersion =\n          options.packageJson?.dependencies?.typescript ??\n          options.packageJson?.devDependencies?.typescript ??\n          '4.4.0';\n\n        const hasAwaitedType = compareVersions(typescriptVersion, '4.5.0');\n\n        const header = builder.header({\n          outputClient: options.client,\n          isRequestOptions: options.override.requestOptions !== false,\n          isMutator,\n          isGlobalMutator: !!options.override.mutator,\n          provideIn: options.override.angular.provideIn,\n          hasAwaitedType,\n          titles,\n          output: options,\n          verbOptions: builder.verbOptions,\n          clientImplementation: acc.implementation,\n        });\n\n        acc.implementation = header.implementation + acc.implementation;\n        acc.implementationMock.handler =\n          acc.implementationMock.handler +\n          header.implementationMock +\n          acc.implementationMock.handlerName;\n\n        const footer = builder.footer({\n          outputClient: options?.client,\n          operationNames,\n          hasMutator: acc.mutators.length > 0,\n          hasAwaitedType,\n          titles,\n          output: options,\n        });\n        acc.implementation += footer.implementation;\n        acc.implementationMock.handler += footer.implementationMock;\n      }\n      return acc;\n    },\n    {\n      imports: [],\n      implementation: '',\n      implementationMock: {\n        function: '',\n        handler: '',\n        handlerName: '',\n      },\n      importsMock: [],\n      mutators: [],\n      clientMutators: [],\n      formData: [],\n      formUrlEncoded: [],\n      paramsSerializer: [],\n      fetchReviver: [],\n    },\n  );\n\n  return {\n    ...target,\n    implementationMock:\n      target.implementationMock.function + target.implementationMock.handler,\n  };\n}\n","export function getOrvalGeneratedTypes() {\n  return `\n// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497\ntype IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <\nT,\n>() => T extends Y ? 1 : 2\n? A\n: B;\n\ntype WritableKeys<T> = {\n[P in keyof T]-?: IfEquals<\n  { [Q in P]: T[P] },\n  { -readonly [Q in P]: T[P] },\n  P\n>;\n}[keyof T];\n\ntype UnionToIntersection<U> =\n  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;\ntype DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;\n\ntype Writable<T> = Pick<T, WritableKeys<T>>;\ntype NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {\n  [P in keyof Writable<T>]: T[P] extends object\n    ? NonReadonly<NonNullable<T[P]>>\n    : T[P];\n} : DistributeReadOnlyOverUnions<T>;\n`;\n}\n\nexport function getTypedResponse() {\n  return `\ninterface TypedResponse<T> extends Response {\n  json(): Promise<T>;\n}\n`;\n}\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport type { WriteModeProps } from '../types';\nimport {\n  conventionName,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  upath,\n} from '../utils';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTarget } from './target';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport async function writeSingleMode({\n  builder,\n  output,\n  projectName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> {\n  try {\n    const { path, dirname } = getFileInfo(output.target, {\n      backupFilename: conventionName(\n        builder.info.title,\n        output.namingConvention,\n      ),\n      extension: output.fileExtension,\n    });\n\n    const {\n      imports,\n      importsMock,\n      implementation,\n      implementationMock,\n      mutators,\n      clientMutators,\n      formData,\n      formUrlEncoded,\n      paramsSerializer,\n      fetchReviver,\n    } = generateTarget(builder, output);\n\n    let data = header;\n\n    const schemasPath = output.schemas\n      ? upath.relativeSafe(\n          dirname,\n          getFileInfo(\n            typeof output.schemas === 'string'\n              ? output.schemas\n              : output.schemas.path,\n            { extension: output.fileExtension },\n          ).dirname,\n        )\n      : undefined;\n\n    const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n      output.tsconfig,\n    );\n\n    const importsForBuilder = schemasPath\n      ? generateImportsForBuilder(\n          output,\n          imports.filter(\n            (imp) => !importsMock.some((impMock) => imp.name === impMock.name),\n          ),\n          schemasPath,\n        )\n      : [];\n\n    data += builder.imports({\n      client: output.client,\n      implementation,\n      imports: importsForBuilder,\n      projectName,\n      hasSchemaDir: !!output.schemas,\n      isAllowSyntheticDefaultImports,\n      hasGlobalMutator: !!output.override.mutator,\n      hasTagsMutator: Object.values(output.override.tags).some(\n        (tag) => !!tag?.mutator,\n      ),\n      hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n      packageJson: output.packageJson,\n      output,\n    });\n\n    if (output.mock) {\n      const importsMockForBuilder = schemasPath\n        ? generateImportsForBuilder(output, importsMock, schemasPath)\n        : [];\n      data += builder.importsMock({\n        implementation: implementationMock,\n        imports: importsMockForBuilder,\n        projectName,\n        hasSchemaDir: !!output.schemas,\n        isAllowSyntheticDefaultImports,\n        options: isFunction(output.mock) ? undefined : output.mock,\n      });\n    }\n\n    if (mutators) {\n      data += generateMutatorImports({ mutators, implementation });\n    }\n\n    if (clientMutators) {\n      data += generateMutatorImports({ mutators: clientMutators });\n    }\n\n    if (formData) {\n      data += generateMutatorImports({ mutators: formData });\n    }\n\n    if (formUrlEncoded) {\n      data += generateMutatorImports({ mutators: formUrlEncoded });\n    }\n\n    if (paramsSerializer) {\n      data += generateMutatorImports({ mutators: paramsSerializer });\n    }\n\n    if (fetchReviver) {\n      data += generateMutatorImports({ mutators: fetchReviver });\n    }\n\n    if (implementation.includes('NonReadonly<')) {\n      data += getOrvalGeneratedTypes();\n      data += '\\n';\n    }\n\n    if (implementation.includes('TypedResponse<')) {\n      data += getTypedResponse();\n      data += '\\n';\n    }\n\n    if (!output.schemas && needSchema) {\n      data += generateModelsInline(builder.schemas);\n    }\n\n    data += `${implementation.trim()}\\n`;\n\n    if (output.mock) {\n      data += '\\n\\n';\n      data += implementationMock;\n    }\n\n    await fs.outputFile(path, data);\n\n    return [path];\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : 'unknown error';\n    throw new Error(\n      `Oups... . An Error occurred while writing file => ${errorMsg}`,\n    );\n  }\n}\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport { OutputClient, type WriteModeProps } from '../types';\nimport {\n  conventionName,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  upath,\n} from '../utils';\nimport { getMockFileExtensionByTypeName } from '../utils/file-extensions';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTarget } from './target';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport async function writeSplitMode({\n  builder,\n  output,\n  projectName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> {\n  try {\n    const { filename, dirname, extension } = getFileInfo(output.target, {\n      backupFilename: conventionName(\n        builder.info.title,\n        output.namingConvention,\n      ),\n      extension: output.fileExtension,\n    });\n\n    const {\n      imports,\n      implementation,\n      implementationMock,\n      importsMock,\n      mutators,\n      clientMutators,\n      formData,\n      formUrlEncoded,\n      paramsSerializer,\n      fetchReviver,\n    } = generateTarget(builder, output);\n\n    let implementationData = header;\n    let mockData = header;\n\n    const relativeSchemasPath = output.schemas\n      ? upath.relativeSafe(\n          dirname,\n          getFileInfo(\n            typeof output.schemas === 'string'\n              ? output.schemas\n              : output.schemas.path,\n            { extension: output.fileExtension },\n          ).dirname,\n        )\n      : './' + filename + '.schemas';\n\n    const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n      output.tsconfig,\n    );\n\n    const importsForBuilder = generateImportsForBuilder(\n      output,\n      imports,\n      relativeSchemasPath,\n    );\n\n    implementationData += builder.imports({\n      client: output.client,\n      implementation,\n      imports: importsForBuilder,\n      projectName,\n      hasSchemaDir: !!output.schemas,\n      isAllowSyntheticDefaultImports,\n      hasGlobalMutator: !!output.override.mutator,\n      hasTagsMutator: Object.values(output.override.tags).some(\n        (tag) => !!tag?.mutator,\n      ),\n      hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n      packageJson: output.packageJson,\n      output,\n    });\n\n    const importsMockForBuilder = generateImportsForBuilder(\n      output,\n      importsMock,\n      relativeSchemasPath,\n    );\n\n    mockData += builder.importsMock({\n      implementation: implementationMock,\n      imports: importsMockForBuilder,\n      projectName,\n      hasSchemaDir: !!output.schemas,\n      isAllowSyntheticDefaultImports,\n      options: isFunction(output.mock) ? undefined : output.mock,\n    });\n\n    const schemasPath = output.schemas\n      ? undefined\n      : upath.join(dirname, filename + '.schemas' + extension);\n\n    if (schemasPath && needSchema) {\n      const schemasData = header + generateModelsInline(builder.schemas);\n\n      await fs.outputFile(\n        upath.join(dirname, filename + '.schemas' + extension),\n        schemasData,\n      );\n    }\n\n    if (mutators) {\n      implementationData += generateMutatorImports({\n        mutators,\n        implementation,\n      });\n    }\n\n    if (clientMutators) {\n      implementationData += generateMutatorImports({\n        mutators: clientMutators,\n      });\n    }\n\n    if (formData) {\n      implementationData += generateMutatorImports({ mutators: formData });\n    }\n\n    if (formUrlEncoded) {\n      implementationData += generateMutatorImports({\n        mutators: formUrlEncoded,\n      });\n    }\n\n    if (paramsSerializer) {\n      implementationData += generateMutatorImports({\n        mutators: paramsSerializer,\n      });\n    }\n\n    if (fetchReviver) {\n      implementationData += generateMutatorImports({\n        mutators: fetchReviver,\n      });\n    }\n\n    if (implementation.includes('NonReadonly<')) {\n      implementationData += getOrvalGeneratedTypes();\n      implementationData += '\\n';\n    }\n\n    if (implementation.includes('TypedResponse<')) {\n      implementationData += getTypedResponse();\n      implementationData += '\\n';\n    }\n\n    implementationData += `\\n${implementation}`;\n    mockData += `\\n${implementationMock}`;\n\n    const implementationFilename =\n      filename +\n      (OutputClient.ANGULAR === output.client ? '.service' : '') +\n      extension;\n\n    const implementationPath = upath.join(dirname, implementationFilename);\n    await fs.outputFile(\n      upath.join(dirname, implementationFilename),\n      implementationData,\n    );\n\n    const mockPath = output.mock\n      ? upath.join(\n          dirname,\n          filename +\n            '.' +\n            getMockFileExtensionByTypeName(output.mock) +\n            extension,\n        )\n      : undefined;\n\n    if (mockPath) {\n      await fs.outputFile(mockPath, mockData);\n    }\n\n    return [\n      implementationPath,\n      ...(schemasPath ? [schemasPath] : []),\n      ...(mockPath ? [mockPath] : []),\n    ];\n  } catch (error) {\n    throw new Error(\n      `Oups... . An Error occurred while splitting => ${error}`,\n    );\n  }\n}\n","import {\n  type GeneratorOperation,\n  type GeneratorTarget,\n  type GeneratorTargetFull,\n  type NormalizedOutputOptions,\n  OutputClient,\n  type WriteSpecBuilder,\n} from '../types';\nimport { compareVersions, kebab, pascal } from '../utils';\n\nfunction addDefaultTagIfEmpty(operation: GeneratorOperation) {\n  return {\n    ...operation,\n    tags: operation.tags.length > 0 ? operation.tags : ['default'],\n  };\n}\n\nfunction generateTargetTags(\n  currentAcc: Record<string, GeneratorTargetFull>,\n  operation: GeneratorOperation,\n): Record<string, GeneratorTargetFull> {\n  const tag = kebab(operation.tags[0]);\n  const currentOperation = currentAcc[tag];\n\n  if (!currentOperation) {\n    currentAcc[tag] = {\n      imports: operation.imports,\n      importsMock: operation.importsMock,\n      mutators: operation.mutator ? [operation.mutator] : [],\n      clientMutators: operation.clientMutators ?? [],\n      formData: operation.formData ? [operation.formData] : [],\n      formUrlEncoded: operation.formUrlEncoded\n        ? [operation.formUrlEncoded]\n        : [],\n      paramsSerializer: operation.paramsSerializer\n        ? [operation.paramsSerializer]\n        : [],\n      fetchReviver: operation.fetchReviver ? [operation.fetchReviver] : [],\n      implementation: operation.implementation,\n      implementationMock: {\n        function: operation.implementationMock.function,\n        handler: operation.implementationMock.handler,\n        handlerName: '  ' + operation.implementationMock.handlerName + '()',\n      },\n    };\n\n    return currentAcc;\n  }\n\n  currentAcc[tag] = {\n    implementation: currentOperation.implementation + operation.implementation,\n    imports: [...currentOperation.imports, ...operation.imports],\n    importsMock: [...currentOperation.importsMock, ...operation.importsMock],\n    implementationMock: {\n      function:\n        currentOperation.implementationMock.function +\n        operation.implementationMock.function,\n      handler:\n        currentOperation.implementationMock.handler +\n        operation.implementationMock.handler,\n      handlerName:\n        currentOperation.implementationMock.handlerName +\n        ',\\n  ' +\n        operation.implementationMock.handlerName +\n        '()',\n    },\n    mutators: operation.mutator\n      ? [...(currentOperation.mutators ?? []), operation.mutator]\n      : currentOperation.mutators,\n    clientMutators: operation.clientMutators\n      ? [\n          ...(currentOperation.clientMutators ?? []),\n          ...operation.clientMutators,\n        ]\n      : currentOperation.clientMutators,\n    formData: operation.formData\n      ? [...(currentOperation.formData ?? []), operation.formData]\n      : currentOperation.formData,\n    formUrlEncoded: operation.formUrlEncoded\n      ? [...(currentOperation.formUrlEncoded ?? []), operation.formUrlEncoded]\n      : currentOperation.formUrlEncoded,\n    paramsSerializer: operation.paramsSerializer\n      ? [\n          ...(currentOperation.paramsSerializer ?? []),\n          operation.paramsSerializer,\n        ]\n      : currentOperation.paramsSerializer,\n    fetchReviver: operation.fetchReviver\n      ? [...(currentOperation.fetchReviver ?? []), operation.fetchReviver]\n      : currentOperation.fetchReviver,\n  };\n  return currentAcc;\n}\n\nexport function generateTargetForTags(\n  builder: WriteSpecBuilder,\n  options: NormalizedOutputOptions,\n) {\n  const isAngularClient = options.client === OutputClient.ANGULAR;\n\n  const allTargetTags = Object.values(builder.operations)\n    .map((operation) => addDefaultTagIfEmpty(operation))\n    .reduce<Record<string, GeneratorTargetFull>>(\n      (acc, operation, index, arr) => {\n        const targetTags = generateTargetTags(acc, operation);\n\n        if (index === arr.length - 1) {\n          return Object.entries(targetTags).reduce<\n            Record<string, GeneratorTargetFull>\n          >((acc, [tag, target]) => {\n            const isMutator = !!target.mutators?.some((mutator) =>\n              isAngularClient ? mutator.hasThirdArg : mutator.hasSecondArg,\n            );\n            const operationNames = Object.values(builder.operations)\n              // Operations can have multiple tags, but they are grouped by the first\n              // tag, therefore we only want to handle the case where the tag\n              // is the first in the list of tags.\n              .filter(\n                ({ tags }) =>\n                  tags.map((tag) => kebab(tag)).indexOf(kebab(tag)) === 0,\n              )\n              .map(({ operationName }) => operationName);\n\n            const typescriptVersion =\n              options.packageJson?.dependencies?.typescript ??\n              options.packageJson?.devDependencies?.typescript ??\n              '4.4.0';\n\n            const hasAwaitedType = compareVersions(typescriptVersion, '4.5.0');\n\n            const titles = builder.title({\n              outputClient: options.client,\n              title: pascal(tag),\n              customTitleFunc: options.override.title,\n              output: options,\n            });\n\n            const footer = builder.footer({\n              outputClient: options?.client,\n              operationNames,\n              hasMutator: !!target.mutators?.length,\n              hasAwaitedType,\n              titles,\n              output: options,\n            });\n\n            const header = builder.header({\n              outputClient: options.client,\n              isRequestOptions: options.override.requestOptions !== false,\n              isMutator,\n              isGlobalMutator: !!options.override.mutator,\n              provideIn: options.override.angular.provideIn,\n              hasAwaitedType,\n              titles,\n              output: options,\n              verbOptions: builder.verbOptions,\n              tag,\n              clientImplementation: target.implementation,\n            });\n\n            acc[tag] = {\n              implementation:\n                header.implementation +\n                target.implementation +\n                footer.implementation,\n              implementationMock: {\n                function: target.implementationMock.function,\n                handler:\n                  target.implementationMock.handler +\n                  header.implementationMock +\n                  target.implementationMock.handlerName +\n                  footer.implementationMock,\n                handlerName: target.implementationMock.handlerName,\n              },\n              imports: target.imports,\n              importsMock: target.importsMock,\n              mutators: target.mutators,\n              clientMutators: target.clientMutators,\n              formData: target.formData,\n              formUrlEncoded: target.formUrlEncoded,\n              paramsSerializer: target.paramsSerializer,\n              fetchReviver: target.fetchReviver,\n            };\n\n            return acc;\n          }, {});\n        }\n\n        return targetTags;\n      },\n      {},\n    );\n\n  return Object.entries(allTargetTags).reduce<Record<string, GeneratorTarget>>(\n    (acc, [tag, target]) => {\n      acc[tag] = {\n        ...target,\n        implementationMock:\n          target.implementationMock.function +\n          target.implementationMock.handler,\n      };\n\n      return acc;\n    },\n    {},\n  );\n}\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport { OutputClient, type WriteModeProps } from '../types';\nimport {\n  conventionName,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  pascal,\n  upath,\n} from '../utils';\nimport { getMockFileExtensionByTypeName } from '../utils/file-extensions';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTargetForTags } from './target-tags';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport async function writeSplitTagsMode({\n  builder,\n  output,\n  projectName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> {\n  const { filename, dirname, extension } = getFileInfo(output.target, {\n    backupFilename: conventionName(builder.info.title, output.namingConvention),\n    extension: output.fileExtension,\n  });\n\n  const target = generateTargetForTags(builder, output);\n\n  const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n    output.tsconfig,\n  );\n\n  const indexFilePath =\n    output.mock && !isFunction(output.mock) && output.mock.indexMockFiles\n      ? upath.join(\n          dirname,\n          'index.' + getMockFileExtensionByTypeName(output.mock!) + extension,\n        )\n      : undefined;\n  if (indexFilePath) {\n    await fs.outputFile(indexFilePath, '');\n  }\n\n  const generatedFilePathsArray = await Promise.all(\n    Object.entries(target).map(async ([tag, target]) => {\n      try {\n        const {\n          imports,\n          implementation,\n          implementationMock,\n          importsMock,\n          mutators,\n          clientMutators,\n          formData,\n          fetchReviver,\n          formUrlEncoded,\n          paramsSerializer,\n        } = target;\n\n        let implementationData = header;\n        let mockData = header;\n\n        const relativeSchemasPath = output.schemas\n          ? '../' +\n            upath.relativeSafe(\n              dirname,\n              getFileInfo(\n                typeof output.schemas === 'string'\n                  ? output.schemas\n                  : output.schemas.path,\n                { extension: output.fileExtension },\n              ).dirname,\n            )\n          : '../' + filename + '.schemas';\n\n        const importsForBuilder = generateImportsForBuilder(\n          output,\n          imports,\n          relativeSchemasPath,\n        );\n\n        implementationData += builder.imports({\n          client: output.client,\n          implementation,\n          imports: importsForBuilder,\n          projectName,\n          hasSchemaDir: !!output.schemas,\n          isAllowSyntheticDefaultImports,\n          hasGlobalMutator: !!output.override.mutator,\n          hasTagsMutator: Object.values(output.override.tags).some(\n            (tag) => !!tag?.mutator,\n          ),\n          hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n          packageJson: output.packageJson,\n          output,\n        });\n\n        const importsMockForBuilder = generateImportsForBuilder(\n          output,\n          importsMock,\n          relativeSchemasPath,\n        );\n\n        mockData += builder.importsMock({\n          implementation: implementationMock,\n          imports: importsMockForBuilder,\n          projectName,\n          hasSchemaDir: !!output.schemas,\n          isAllowSyntheticDefaultImports,\n          options: isFunction(output.mock) ? undefined : output.mock,\n        });\n\n        const schemasPath = output.schemas\n          ? undefined\n          : upath.join(dirname, filename + '.schemas' + extension);\n\n        if (schemasPath && needSchema) {\n          const schemasData = header + generateModelsInline(builder.schemas);\n\n          await fs.outputFile(schemasPath, schemasData);\n        }\n\n        if (mutators) {\n          implementationData += generateMutatorImports({\n            mutators,\n            implementation,\n            oneMore: true,\n          });\n        }\n\n        if (clientMutators) {\n          implementationData += generateMutatorImports({\n            mutators: clientMutators,\n            oneMore: true,\n          });\n        }\n\n        if (formData) {\n          implementationData += generateMutatorImports({\n            mutators: formData,\n            oneMore: true,\n          });\n        }\n        if (formUrlEncoded) {\n          implementationData += generateMutatorImports({\n            mutators: formUrlEncoded,\n            oneMore: true,\n          });\n        }\n        if (paramsSerializer) {\n          implementationData += generateMutatorImports({\n            mutators: paramsSerializer,\n            oneMore: true,\n          });\n        }\n\n        if (fetchReviver) {\n          implementationData += generateMutatorImports({\n            mutators: fetchReviver,\n            oneMore: true,\n          });\n        }\n\n        if (implementation.includes('NonReadonly<')) {\n          implementationData += getOrvalGeneratedTypes();\n          implementationData += '\\n';\n        }\n\n        if (implementation.includes('TypedResponse<')) {\n          implementationData += getTypedResponse();\n          implementationData += '\\n';\n        }\n\n        implementationData += `\\n${implementation}`;\n        mockData += `\\n${implementationMock}`;\n\n        const implementationFilename =\n          tag +\n          (OutputClient.ANGULAR === output.client ? '.service' : '') +\n          extension;\n\n        const implementationPath = upath.join(\n          dirname,\n          tag,\n          implementationFilename,\n        );\n        await fs.outputFile(implementationPath, implementationData);\n\n        const mockPath = output.mock\n          ? upath.join(\n              dirname,\n              tag,\n              tag +\n                '.' +\n                getMockFileExtensionByTypeName(output.mock) +\n                extension,\n            )\n          : undefined;\n\n        if (mockPath) {\n          await fs.outputFile(mockPath, mockData);\n          if (indexFilePath) {\n            const localMockPath = upath.joinSafe(\n              './',\n              tag,\n              tag + '.' + getMockFileExtensionByTypeName(output.mock!),\n            );\n            fs.appendFile(\n              indexFilePath,\n              `export { get${pascal(tag)}Mock } from '${localMockPath}'\\n`,\n            );\n          }\n        }\n\n        return [\n          implementationPath,\n          ...(schemasPath ? [schemasPath] : []),\n          ...(mockPath ? [mockPath] : []),\n        ];\n      } catch (error) {\n        throw new Error(\n          `Oups... . An Error occurred while splitting tag ${tag} => ${error}`,\n        );\n      }\n    }),\n  );\n\n  return generatedFilePathsArray.flat();\n}\n","import fs from 'fs-extra';\n\nimport { generateModelsInline, generateMutatorImports } from '../generators';\nimport type { WriteModeProps } from '../types';\nimport {\n  conventionName,\n  getFileInfo,\n  isFunction,\n  isSyntheticDefaultImportsAllow,\n  kebab,\n  upath,\n} from '../utils';\nimport { generateImportsForBuilder } from './generate-imports-for-builder';\nimport { generateTargetForTags } from './target-tags';\nimport { getOrvalGeneratedTypes, getTypedResponse } from './types';\n\nexport async function writeTagsMode({\n  builder,\n  output,\n  projectName,\n  header,\n  needSchema,\n}: WriteModeProps): Promise<string[]> {\n  const { filename, dirname, extension } = getFileInfo(output.target, {\n    backupFilename: conventionName(builder.info.title, output.namingConvention),\n    extension: output.fileExtension,\n  });\n\n  const target = generateTargetForTags(builder, output);\n\n  const isAllowSyntheticDefaultImports = isSyntheticDefaultImportsAllow(\n    output.tsconfig,\n  );\n\n  const generatedFilePathsArray = await Promise.all(\n    Object.entries(target).map(async ([tag, target]) => {\n      try {\n        const {\n          imports,\n          implementation,\n          implementationMock,\n          importsMock,\n          mutators,\n          clientMutators,\n          formData,\n          formUrlEncoded,\n          fetchReviver,\n          paramsSerializer,\n        } = target;\n\n        let data = header;\n\n        const schemasPathRelative = output.schemas\n          ? upath.relativeSafe(\n              dirname,\n              getFileInfo(\n                typeof output.schemas === 'string'\n                  ? output.schemas\n                  : output.schemas.path,\n                { extension: output.fileExtension },\n              ).dirname,\n            )\n          : './' + filename + '.schemas';\n\n        const importsForBuilder = generateImportsForBuilder(\n          output,\n          imports.filter(\n            (imp) => !importsMock.some((impMock) => imp.name === impMock.name),\n          ),\n          schemasPathRelative,\n        );\n\n        data += builder.imports({\n          client: output.client,\n          implementation,\n          imports: importsForBuilder,\n          projectName,\n          hasSchemaDir: !!output.schemas,\n          isAllowSyntheticDefaultImports,\n          hasGlobalMutator: !!output.override.mutator,\n          hasTagsMutator: Object.values(output.override.tags).some(\n            (tag) => !!tag?.mutator,\n          ),\n          hasParamsSerializerOptions: !!output.override.paramsSerializerOptions,\n          packageJson: output.packageJson,\n          output,\n        });\n\n        if (output.mock) {\n          const importsMockForBuilder = generateImportsForBuilder(\n            output,\n            importsMock,\n            schemasPathRelative,\n          );\n\n          data += builder.importsMock({\n            implementation: implementationMock,\n            imports: importsMockForBuilder,\n            projectName,\n            hasSchemaDir: !!output.schemas,\n            isAllowSyntheticDefaultImports,\n            options: isFunction(output.mock) ? undefined : output.mock,\n          });\n        }\n\n        const schemasPath = output.schemas\n          ? undefined\n          : upath.join(dirname, filename + '.schemas' + extension);\n\n        if (schemasPath && needSchema) {\n          const schemasData = header + generateModelsInline(builder.schemas);\n\n          await fs.outputFile(schemasPath, schemasData);\n        }\n\n        if (mutators) {\n          data += generateMutatorImports({ mutators, implementation });\n        }\n\n        if (clientMutators) {\n          data += generateMutatorImports({\n            mutators: clientMutators,\n          });\n        }\n\n        if (formData) {\n          data += generateMutatorImports({ mutators: formData });\n        }\n\n        if (formUrlEncoded) {\n          data += generateMutatorImports({ mutators: formUrlEncoded });\n        }\n\n        if (paramsSerializer) {\n          data += generateMutatorImports({ mutators: paramsSerializer });\n        }\n\n        if (fetchReviver) {\n          data += generateMutatorImports({ mutators: fetchReviver });\n        }\n\n        data += '\\n\\n';\n\n        if (implementation.includes('NonReadonly<')) {\n          data += getOrvalGeneratedTypes();\n          data += '\\n';\n        }\n\n        if (implementation.includes('TypedResponse<')) {\n          data += getTypedResponse();\n          data += '\\n';\n        }\n\n        data += implementation;\n\n        if (output.mock) {\n          data += '\\n\\n';\n\n          data += implementationMock;\n        }\n\n        const implementationPath = upath.join(\n          dirname,\n          `${kebab(tag)}${extension}`,\n        );\n        await fs.outputFile(implementationPath, data);\n\n        return [implementationPath, ...(schemasPath ? [schemasPath] : [])];\n      } catch (error) {\n        throw new Error(\n          `Oups... . An Error occurred while writing tag ${tag} => ${error}`,\n        );\n      }\n    }),\n  );\n\n  return generatedFilePathsArray.flat();\n}\n"],"mappings":"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"}