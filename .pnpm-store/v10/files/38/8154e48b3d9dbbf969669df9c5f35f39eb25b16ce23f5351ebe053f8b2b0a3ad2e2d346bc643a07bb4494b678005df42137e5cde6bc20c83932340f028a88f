{"version":3,"file":"index.mjs","names":["ANGULAR_DEPENDENCIES: GeneratorDependency[]","getAngularDependencies: ClientDependenciesBuilder","generateAngularTitle: ClientTitleBuilder","generateAngularHeader: ClientHeaderBuilder","generateAngularFooter: ClientFooterBuilder","generateAngular: ClientBuilder","angularClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/index.ts"],"sourcesContent":["import {\n  type ClientBuilder,\n  type ClientDependenciesBuilder,\n  type ClientFooterBuilder,\n  type ClientGeneratorsBuilder,\n  type ClientHeaderBuilder,\n  type ClientTitleBuilder,\n  generateFormDataAndUrlEncodedFunction,\n  generateMutatorConfig,\n  generateMutatorRequestOptions,\n  generateOptions,\n  generateVerbImports,\n  type GeneratorDependency,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  getDefaultContentType,\n  isBoolean,\n  pascal,\n  sanitize,\n  toObjectString,\n} from '@orval/core';\n\nconst ANGULAR_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'HttpClient', values: true },\n      { name: 'HttpHeaders' },\n      { name: 'HttpParams' },\n      { name: 'HttpContext' },\n      { name: 'HttpResponse', alias: 'AngularHttpResponse' }, // alias to prevent naming conflict with msw\n      { name: 'HttpEvent' },\n    ],\n    dependency: '@angular/common/http',\n  },\n  {\n    exports: [\n      { name: 'Injectable', values: true },\n      { name: 'inject', values: true },\n    ],\n    dependency: '@angular/core',\n  },\n  {\n    exports: [{ name: 'Observable', values: true }],\n    dependency: 'rxjs',\n  },\n  {\n    exports: [{ name: 'DeepNonNullable' }],\n    dependency: '@orval/core',\n  },\n];\n\nconst returnTypesToWrite = new Map<string, string>();\n\nexport const getAngularDependencies: ClientDependenciesBuilder = () =>\n  ANGULAR_DEPENDENCIES;\n\nexport const generateAngularTitle: ClientTitleBuilder = (title) => {\n  const sanTitle = sanitize(title);\n  return `${pascal(sanTitle)}Service`;\n};\n\nexport const generateAngularHeader: ClientHeaderBuilder = ({\n  title,\n  isRequestOptions,\n  isMutator,\n  isGlobalMutator,\n  provideIn,\n}) => `\n${\n  isRequestOptions && !isGlobalMutator\n    ? `interface HttpClientOptions {\n  headers?: HttpHeaders | Record<string, string | string[]>;\n  context?: HttpContext;\n  params?:\n        | HttpParams\n        | Record<string, string | number | boolean | ReadonlyArray<string | number | boolean>>;\n  reportProgress?: boolean;\n  withCredentials?: boolean;\n  credentials?: RequestCredentials;\n  keepalive?: boolean;\n  priority?: RequestPriority;\n  cache?: RequestCache;\n  mode?: RequestMode;\n  redirect?: RequestRedirect;\n  referrer?: string;\n  integrity?: string;\n  transferCache?: {includeHeaders?: string[]} | boolean;\n  timeout?: number;\n}`\n    : ''\n}\n\n${\n  isRequestOptions && isMutator\n    ? `// eslint-disable-next-line\n    type ThirdParameter<T extends (...args: any) => any> = T extends (\n  config: any,\n  httpClient: any,\n  args: infer P,\n) => any\n  ? P\n  : never;`\n    : ''\n}\n\n@Injectable(${\n  provideIn\n    ? `{ providedIn: '${isBoolean(provideIn) ? 'root' : provideIn}' }`\n    : ''\n})\nexport class ${title} {\n  private readonly http = inject(HttpClient);\n`;\n\nexport const generateAngularFooter: ClientFooterBuilder = ({\n  operationNames,\n}) => {\n  let footer = '};\\n\\n';\n\n  for (const operationName of operationNames) {\n    if (returnTypesToWrite.has(operationName)) {\n      // Map.has ensures Map.get will not return undefined, but TS still complains\n      // bug https://github.com/microsoft/TypeScript/issues/13086\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      footer += returnTypesToWrite.get(operationName) + '\\n';\n    }\n  }\n\n  return footer;\n};\n\nconst generateImplementation = (\n  {\n    headers,\n    queryParams,\n    operationName,\n    response,\n    mutator,\n    body,\n    props,\n    verb,\n    override,\n    formData,\n    formUrlEncoded,\n    paramsSerializer,\n  }: GeneratorVerbOptions,\n  { route, context }: GeneratorOptions,\n) => {\n  const isRequestOptions = override.requestOptions !== false;\n  const isFormData = !override.formData.disabled;\n  const isFormUrlEncoded = override.formUrlEncoded !== false;\n  const isExactOptionalPropertyTypes =\n    !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;\n  const bodyForm = generateFormDataAndUrlEncodedFunction({\n    formData,\n    formUrlEncoded,\n    body,\n    isFormData,\n    isFormUrlEncoded,\n  });\n\n  const dataType = response.definition.success || 'unknown';\n\n  returnTypesToWrite.set(\n    operationName,\n    `export type ${pascal(\n      operationName,\n    )}ClientResult = NonNullable<${dataType}>`,\n  );\n\n  if (mutator) {\n    const mutatorConfig = generateMutatorConfig({\n      route,\n      body,\n      headers,\n      queryParams,\n      response,\n      verb,\n      isFormData,\n      isFormUrlEncoded,\n      hasSignal: false,\n      isExactOptionalPropertyTypes,\n    });\n\n    const requestOptions = isRequestOptions\n      ? generateMutatorRequestOptions(\n          override.requestOptions,\n          mutator.hasThirdArg,\n        )\n      : '';\n\n    const propsImplementation =\n      mutator.bodyTypeName && body.definition\n        ? toObjectString(props, 'implementation').replace(\n            new RegExp(String.raw`(\\w*):\\s?${body.definition}`),\n            `$1: ${mutator.bodyTypeName}<${body.definition}>`,\n          )\n        : toObjectString(props, 'implementation');\n\n    return ` ${operationName}<TData = ${dataType}>(\\n    ${propsImplementation}\\n ${\n      isRequestOptions && mutator.hasThirdArg\n        ? `options?: ThirdParameter<typeof ${mutator.name}>`\n        : ''\n    }) {${bodyForm}\n      return ${mutator.name}<TData>(\n      ${mutatorConfig},\n      this.http,\n      ${requestOptions});\n    }\n  `;\n  }\n\n  const options = generateOptions({\n    route,\n    body,\n    headers,\n    queryParams,\n    response,\n    verb,\n    requestOptions: override.requestOptions,\n    isFormData,\n    isFormUrlEncoded,\n    paramsSerializer,\n    paramsSerializerOptions: override.paramsSerializerOptions,\n    isAngular: true,\n    isExactOptionalPropertyTypes,\n    hasSignal: false,\n  });\n\n  const propsDefinition = toObjectString(props, 'definition');\n\n  // Check for multiple content types in success responses\n  const successTypes = response.types.success;\n  const uniqueContentTypes = [\n    ...new Set(successTypes.map((t) => t.contentType).filter(Boolean)),\n  ];\n  const hasMultipleContentTypes = uniqueContentTypes.length > 1;\n\n  // For multiple content types, determine the default\n  const defaultContentType = hasMultipleContentTypes\n    ? getDefaultContentType(uniqueContentTypes)\n    : (uniqueContentTypes[0] ?? 'application/json');\n  const defaultType = hasMultipleContentTypes\n    ? successTypes.find((t) => t.contentType === defaultContentType)\n    : undefined;\n  const defaultReturnType = defaultType?.value ?? dataType;\n\n  const isModelType = dataType !== 'Blob' && dataType !== 'string';\n  let functionName = operationName;\n  if (isModelType && !hasMultipleContentTypes) {\n    functionName += `<TData = ${dataType}>`;\n  }\n\n  let contentTypeOverloads = '';\n  if (hasMultipleContentTypes && isRequestOptions) {\n    const requiredProps = props.filter((p) => p.required && !p.default);\n    const optionalProps = props.filter((p) => !p.required || p.default);\n\n    contentTypeOverloads = successTypes\n      .filter((t) => t.contentType)\n      .map(({ contentType, value }) => {\n        const requiredPart = requiredProps\n          .map((p) => p.definition)\n          .join(',\\n    ');\n        const acceptPart = `accept: '${contentType}'`;\n        const optionalPart = optionalProps\n          .map((p) => p.definition)\n          .join(',\\n    ');\n\n        const allParams = [requiredPart, acceptPart, optionalPart]\n          .filter(Boolean)\n          .join(',\\n    ');\n        return `${operationName}(${allParams}, options?: HttpClientOptions): Observable<${value}>;`;\n      })\n      .join('\\n  ');\n\n    const requiredPart = requiredProps.map((p) => p.definition).join(',\\n    ');\n    const optionalPart = optionalProps.map((p) => p.definition).join(',\\n    ');\n    const allParams = [requiredPart, 'accept?: string', optionalPart]\n      .filter(Boolean)\n      .join(',\\n    ');\n    contentTypeOverloads += `\\n  ${operationName}(${allParams}, options?: HttpClientOptions): Observable<${defaultReturnType}>;`;\n  }\n\n  const observeOverloads =\n    isRequestOptions && !hasMultipleContentTypes\n      ? `${functionName}(${propsDefinition} options?: HttpClientOptions & { observe?: 'body' }): Observable<${isModelType ? 'TData' : dataType}>;\n ${functionName}(${propsDefinition} options?: HttpClientOptions & { observe: 'events' }): Observable<HttpEvent<${isModelType ? 'TData' : dataType}>>;\n ${functionName}(${propsDefinition} options?: HttpClientOptions & { observe: 'response' }): Observable<AngularHttpResponse<${isModelType ? 'TData' : dataType}>>;`\n      : '';\n\n  const overloads = contentTypeOverloads || observeOverloads;\n\n  if (hasMultipleContentTypes) {\n    const requiredProps = props.filter((p) => p.required && !p.default);\n    const optionalProps = props.filter((p) => !p.required || p.default);\n\n    const requiredPart = requiredProps\n      .map((p) => p.implementation)\n      .join(',\\n    ');\n    const optionalPart = optionalProps\n      .map((p) => p.implementation)\n      .join(',\\n    ');\n    const allParams = [\n      requiredPart,\n      `accept: string = '${defaultContentType}'`,\n      optionalPart,\n    ]\n      .filter(Boolean)\n      .join(',\\n    ');\n\n    return ` ${overloads}\n  ${operationName}(\n    ${allParams},\n    ${isRequestOptions ? 'options?: HttpClientOptions' : ''}\n  ): Observable<any> {${bodyForm}\n    if (accept.includes('json') || accept.includes('+json')) {\n      return this.http.${verb}<any>(\\`${route}\\`, {\n        ...options,\n        responseType: 'json',\n        headers: { Accept: accept, ...options?.headers },\n      });\n    } else if (accept.startsWith('text/') || accept.includes('xml')) {\n      return this.http.${verb}(\\`${route}\\`, {\n        ...options,\n        responseType: 'text',\n        headers: { Accept: accept, ...options?.headers },\n      }) as any;\n    } else {\n      return this.http.${verb}(\\`${route}\\`, {\n        ...options,\n        responseType: 'blob',\n        headers: { Accept: accept, ...options?.headers },\n      }) as any;\n    }\n  }\n`;\n  }\n\n  return ` ${overloads}\n  ${functionName}(\n    ${toObjectString(props, 'implementation')} ${\n      isRequestOptions ? `options?: HttpClientOptions & { observe?: any }` : ''\n    }): Observable<any> {${bodyForm}\n    return this.http.${verb}${isModelType ? '<TData>' : ''}(${options});\n  }\n`;\n};\n\nexport const generateAngular: ClientBuilder = (verbOptions, options) => {\n  const imports = generateVerbImports(verbOptions);\n  const implementation = generateImplementation(verbOptions, options);\n\n  return { implementation, imports };\n};\n\nconst angularClientBuilder: ClientGeneratorsBuilder = {\n  client: generateAngular,\n  header: generateAngularHeader,\n  dependencies: getAngularDependencies,\n  footer: generateAngularFooter,\n  title: generateAngularTitle,\n};\n\nexport const builder = () => () => angularClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}