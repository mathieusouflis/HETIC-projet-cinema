import { Verbs, generateBodyOptions, generateFormDataAndUrlEncodedFunction, generateVerbImports, getIsBodyVerb, isObject, pascal, sanitize, toObjectString } from "@orval/core";

//#region src/index.ts
const SOLID_START_DEPENDENCIES = [{
	exports: [
		{
			name: "query",
			values: true
		},
		{
			name: "action",
			values: true
		},
		{
			name: "cache",
			values: true
		},
		{
			name: "revalidate",
			values: true
		}
	],
	dependency: "@solidjs/router"
}, {
	exports: [{ name: "DeepNonNullable" }],
	dependency: "@orval/core"
}];
const getSolidStartDependencies = () => SOLID_START_DEPENDENCIES;
const generateSolidStartTitle = (title) => {
	return `${pascal(sanitize(title))}`;
};
const generateSolidStartHeader = ({ title }) => `
/**
 * Cache Invalidation:
 *
 * Each query provides .key and .keyFor() for cache invalidation.
 *
 * Examples:
 *   // Invalidate all calls to a query
 *   revalidate(${title}.listPets.key);
 *
 *   // Invalidate a specific call with arguments
 *   revalidate(${title}.showPetById.keyFor("pet-123", 1));
 *
 *   // Invalidate multiple queries
 *   revalidate([${title}.listPets.key, ${title}.showPetById.keyFor("pet-123", 1)]);
 */
export const ${title} = {
`;
const generateSolidStartFooter = () => {
	return "};\n";
};
const generateImplementation = ({ headers, queryParams, operationName, response, mutator, body, props, verb, override, formData, formUrlEncoded, paramsSerializer }, { route, context }) => {
	const isFormData = !override.formData.disabled;
	const isFormUrlEncoded = override.formUrlEncoded !== false;
	const bodyForm = generateFormDataAndUrlEncodedFunction({
		formData,
		formUrlEncoded,
		body,
		isFormData,
		isFormUrlEncoded
	});
	const dataType = response.definition.success || "unknown";
	const isGetVerb = verb === Verbs.GET;
	const isBodyVerb = getIsBodyVerb(verb);
	if (mutator) {
		const propsImplementation$1 = mutator.bodyTypeName && body.definition ? toObjectString(props, "implementation").replace(new RegExp(String.raw`(\w*):\s?${body.definition}`), `$1: ${mutator.bodyTypeName}<${body.definition}>`) : toObjectString(props, "implementation");
		const queryParamsCode$1 = queryParams ? `const queryString = new URLSearchParams(params as any).toString();
    const url = queryString ? \`${route}?\${queryString}\` : \`${route}\`;` : `const url = \`${route}\`;`;
		const fetchMethodOption = `method: '${verb.toUpperCase()}'`;
		const ignoreContentTypes = ["multipart/form-data"];
		const overrideHeaders = isObject(override.requestOptions) && override.requestOptions.headers ? Object.entries(override.requestOptions.headers).map(([key, value]) => `'${key}': \`${value}\``) : [];
		const headersToAdd = [
			...body.contentType && !ignoreContentTypes.includes(body.contentType) ? [`'Content-Type': '${body.contentType}'`] : [],
			...overrideHeaders,
			...headers ? ["...headers"] : []
		];
		const fetchHeadersOption = headersToAdd.length > 0 ? `headers: { ${headersToAdd.join(",")} }` : "";
		const requestBodyParams = generateBodyOptions(body, isFormData, isFormUrlEncoded);
		const fetchBodyOption = requestBodyParams ? isFormData && body.formData || isFormUrlEncoded && body.formUrlEncoded || body.contentType === "text/plain" ? `body: ${requestBodyParams}` : `body: JSON.stringify(${requestBodyParams})` : "";
		const fetchOptions = `{
      ${fetchMethodOption}${fetchHeadersOption ? "," : ""}
      ${fetchHeadersOption}${fetchBodyOption ? "," : ""}
      ${fetchBodyOption}
    }`;
		if (isGetVerb) return `  ${operationName}: query(async (${propsImplementation$1}) => {${bodyForm}
    ${queryParamsCode$1}
    return ${mutator.name}<${dataType}>(
      url,
      ${fetchOptions}
    );
  }, "${operationName}"),
`;
		else return `  ${operationName}: action(async (${propsImplementation$1}) => {${bodyForm}
    ${queryParamsCode$1}
    return ${mutator.name}<${dataType}>(
      url,
      ${fetchOptions}
    );
  }, "${operationName}"),
`;
	}
	const propsImplementation = toObjectString(props, "implementation");
	const queryParamsCode = queryParams ? `const queryString = new URLSearchParams(params as any).toString();
    const url = queryString ? \`${route}?\${queryString}\` : \`${route}\`;` : `const url = \`${route}\`;`;
	const headersCode = headers ? `headers: { ...headers, 'Content-Type': 'application/json' }` : `headers: { 'Content-Type': 'application/json' }`;
	const bodyCode = isBodyVerb && body.implementation ? `,
      body: JSON.stringify(${body.implementation})` : "";
	if (isGetVerb) return `  ${operationName}: query(async (${propsImplementation}) => {${bodyForm}
    ${queryParamsCode}
    const response = await fetch(url, {
      method: '${verb.toUpperCase()}',
      ${headersCode}
    });
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    return response.json() as Promise<${dataType}>;
  }, "${operationName}"),
`;
	else return `  ${operationName}: action(async (${propsImplementation}) => {${bodyForm}
    ${queryParamsCode}
    const response = await fetch(url, {
      method: '${verb.toUpperCase()}',
      ${headersCode}${bodyCode}
    });
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    return response.json() as Promise<${dataType}>;
  }, "${operationName}"),
`;
};
const generateSolidStart = (verbOptions, options) => {
	const imports = generateVerbImports(verbOptions);
	return {
		implementation: generateImplementation(verbOptions, options),
		imports
	};
};
const solidStartClientBuilder = {
	client: generateSolidStart,
	header: generateSolidStartHeader,
	dependencies: getSolidStartDependencies,
	footer: generateSolidStartFooter,
	title: generateSolidStartTitle
};
const builder = () => () => solidStartClientBuilder;
var src_default = builder;

//#endregion
export { builder, src_default as default, generateSolidStart, generateSolidStartFooter, generateSolidStartHeader, generateSolidStartTitle, getSolidStartDependencies };
//# sourceMappingURL=index.mjs.map