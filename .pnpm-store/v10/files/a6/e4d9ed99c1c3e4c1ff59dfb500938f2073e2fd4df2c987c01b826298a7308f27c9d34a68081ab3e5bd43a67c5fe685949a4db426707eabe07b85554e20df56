{"version":3,"file":"index.mjs","names":["AXIOS_DEPENDENCIES: GeneratorDependency[]","generateFetchRequestFunction","getSwrHeader: ClientHeaderBuilder","PARAMS_SERIALIZER_DEPENDENCIES: GeneratorDependency[]","SWR_DEPENDENCIES: GeneratorDependency[]","SWR_INFINITE_DEPENDENCIES: GeneratorDependency[]","SWR_MUTATION_DEPENDENCIES: GeneratorDependency[]","getSwrDependencies: ClientDependenciesBuilder","swrKeyProperties","queryKeyProps","generateSwrHeader: ClientHeaderBuilder","generateSwr: ClientBuilder","swrClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/client.ts","../src/index.ts"],"sourcesContent":["import {\n  type ClientHeaderBuilder,\n  generateFormDataAndUrlEncodedFunction,\n  generateMutatorConfig,\n  generateMutatorRequestOptions,\n  generateOptions,\n  type GeneratorDependency,\n  type GeneratorMutator,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  type GetterResponse,\n  isSyntheticDefaultImportsAllow,\n  OutputHttpClient,\n  toObjectString,\n} from '@orval/core';\nimport {\n  fetchResponseTypeName,\n  generateFetchHeader,\n  generateRequestFunction as generateFetchRequestFunction,\n} from '@orval/fetch';\n\nexport const AXIOS_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'axios',\n        default: true,\n        values: true,\n        syntheticDefaultImport: true,\n      },\n      { name: 'AxiosRequestConfig' },\n      { name: 'AxiosResponse' },\n      { name: 'AxiosError' },\n    ],\n    dependency: 'axios',\n  },\n];\n\nexport const generateSwrRequestFunction = (\n  verbOptions: GeneratorVerbOptions,\n  options: GeneratorOptions,\n) => {\n  return options.context.output.httpClient === OutputHttpClient.AXIOS\n    ? generateAxiosRequestFunction(verbOptions, options)\n    : generateFetchRequestFunction(verbOptions, options);\n};\n\nconst generateAxiosRequestFunction = (\n  {\n    headers,\n    queryParams,\n    operationName,\n    response,\n    mutator,\n    body,\n    props,\n    verb,\n    formData,\n    formUrlEncoded,\n    override,\n    paramsSerializer,\n  }: GeneratorVerbOptions,\n  { route, context }: GeneratorOptions,\n) => {\n  const isRequestOptions = override.requestOptions !== false;\n  const isFormData = !override.formData.disabled;\n  const isFormUrlEncoded = override.formUrlEncoded !== false;\n  const isExactOptionalPropertyTypes =\n    !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;\n  const isSyntheticDefaultImportsAllowed = isSyntheticDefaultImportsAllow(\n    context.output.tsconfig,\n  );\n\n  const bodyForm = generateFormDataAndUrlEncodedFunction({\n    formData,\n    formUrlEncoded,\n    body,\n    isFormData,\n    isFormUrlEncoded,\n  });\n\n  if (mutator) {\n    const mutatorConfig = generateMutatorConfig({\n      route,\n      body,\n      headers,\n      queryParams,\n      response,\n      verb,\n      isFormData,\n      isFormUrlEncoded,\n      hasSignal: false,\n      isExactOptionalPropertyTypes,\n    });\n\n    const propsImplementation =\n      mutator.bodyTypeName && body.definition\n        ? toObjectString(props, 'implementation').replace(\n            new RegExp(String.raw`(\\w*):\\s?${body.definition}`),\n            `$1: ${mutator.bodyTypeName}<${body.definition}>`,\n          )\n        : toObjectString(props, 'implementation');\n\n    const requestOptions = isRequestOptions\n      ? generateMutatorRequestOptions(\n          override.requestOptions,\n          mutator.hasSecondArg,\n        )\n      : '';\n\n    const requestImplementation = `export const ${operationName} = (\\n    ${propsImplementation}\\n ${\n      isRequestOptions && mutator.hasSecondArg\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: SecondParameter<typeof ${mutator.name}>`\n        : ''\n    }) => {${bodyForm}\n    return ${mutator.name}<${response.definition.success || 'unknown'}>(\n    ${mutatorConfig},\n    ${requestOptions});\n  }\n`;\n\n    return requestImplementation;\n  }\n\n  const options = generateOptions({\n    route,\n    body,\n    headers,\n    queryParams,\n    response,\n    verb,\n    requestOptions: override.requestOptions,\n    isFormData,\n    isFormUrlEncoded,\n    paramsSerializer,\n    paramsSerializerOptions: override.paramsSerializerOptions,\n    isExactOptionalPropertyTypes,\n    hasSignal: false,\n  });\n\n  return `export const ${operationName} = (\\n    ${toObjectString(\n    props,\n    'implementation',\n  )} ${\n    isRequestOptions ? `options?: AxiosRequestConfig\\n` : ''\n  } ): Promise<AxiosResponse<${\n    response.definition.success || 'unknown'\n  }>> => {${bodyForm}\n    return axios${\n      isSyntheticDefaultImportsAllowed ? '' : '.default'\n    }.${verb}(${options});\n  }\n`;\n};\n\nexport const getSwrRequestOptions = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? 'axios?: AxiosRequestConfig'\n      : 'fetch?: RequestInit';\n  } else if (mutator.hasSecondArg) {\n    return `request?: SecondParameter<typeof ${mutator.name}>`;\n  } else {\n    return '';\n  }\n};\n\nexport const getSwrErrorType = (\n  response: GetterResponse,\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (mutator) {\n    return mutator.hasErrorType\n      ? `ErrorType<${response.definition.errors || 'unknown'}>`\n      : response.definition.errors || 'unknown';\n  } else {\n    const errorType =\n      httpClient === OutputHttpClient.AXIOS ? 'AxiosError' : 'Promise';\n\n    return `${errorType}<${response.definition.errors || 'unknown'}>`;\n  }\n};\n\nexport const getSwrRequestSecondArg = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? 'axios: axiosOptions'\n      : 'fetch: fetchOptions';\n  } else if (mutator.hasSecondArg) {\n    return 'request: requestOptions';\n  } else {\n    return '';\n  }\n};\n\nexport const getHttpRequestSecondArg = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? `axiosOptions`\n      : `fetchOptions`;\n  } else if (mutator.hasSecondArg) {\n    return 'requestOptions';\n  } else {\n    return '';\n  }\n};\n\nexport const getSwrMutationFetcherOptionType = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? 'AxiosRequestConfig'\n      : 'RequestInit';\n  } else if (mutator.hasSecondArg) {\n    return `SecondParameter<typeof ${mutator.name}>`;\n  } else {\n    return '';\n  }\n};\n\nexport const getSwrMutationFetcherType = (\n  response: GetterResponse,\n  httpClient: OutputHttpClient,\n  includeHttpResponseReturnType: boolean | undefined,\n  operationName: string,\n  mutator?: GeneratorMutator,\n) => {\n  if (httpClient === OutputHttpClient.FETCH) {\n    const responseType = fetchResponseTypeName(\n      includeHttpResponseReturnType,\n      response.definition.success,\n      operationName,\n    );\n\n    return `Promise<${responseType}>`;\n  } else if (mutator) {\n    return `Promise<${response.definition.success || 'unknown'}>`;\n  } else {\n    return `Promise<AxiosResponse<${response.definition.success || 'unknown'}>>`;\n  }\n};\n\nexport const getSwrHeader: ClientHeaderBuilder = (params) => {\n  return params.output.httpClient === OutputHttpClient.FETCH\n    ? generateFetchHeader(params)\n    : '';\n};\n","import {\n  camel,\n  type ClientBuilder,\n  type ClientDependenciesBuilder,\n  type ClientGeneratorsBuilder,\n  type ClientHeaderBuilder,\n  generateVerbImports,\n  type GeneratorDependency,\n  type GeneratorMutator,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  type GetterParams,\n  type GetterProp,\n  type GetterProps,\n  GetterPropType,\n  type GetterResponse,\n  jsDoc,\n  OutputHttpClient,\n  pascal,\n  stringify,\n  type SwrOptions,\n  toObjectString,\n  Verbs,\n} from '@orval/core';\n\nimport {\n  AXIOS_DEPENDENCIES,\n  generateSwrRequestFunction,\n  getHttpRequestSecondArg,\n  getSwrErrorType,\n  getSwrHeader,\n  getSwrMutationFetcherOptionType,\n  getSwrMutationFetcherType,\n  getSwrRequestOptions,\n  getSwrRequestSecondArg,\n} from './client';\n\nconst PARAMS_SERIALIZER_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'qs',\n        default: true,\n        values: true,\n        syntheticDefaultImport: true,\n      },\n    ],\n    dependency: 'qs',\n  },\n];\n\nconst SWR_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useSwr', values: true, default: true },\n      { name: 'SWRConfiguration' },\n      { name: 'Key' },\n      { name: 'Arguments' },\n    ],\n    dependency: 'swr',\n  },\n];\n\nconst SWR_INFINITE_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useSWRInfinite', values: true, default: true },\n      { name: 'SWRInfiniteConfiguration' },\n      { name: 'SWRInfiniteKeyLoader' },\n    ],\n    dependency: 'swr/infinite',\n  },\n];\n\nconst SWR_MUTATION_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useSWRMutation', values: true, default: true },\n      { name: 'SWRMutationConfiguration' },\n      { name: 'SWRMutationKey' },\n    ],\n    dependency: 'swr/mutation',\n  },\n];\n\nexport const getSwrDependencies: ClientDependenciesBuilder = (\n  hasGlobalMutator: boolean,\n  hasParamsSerializerOptions: boolean,\n  _packageJson,\n  httpClient?: OutputHttpClient,\n) => [\n  ...(!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS\n    ? AXIOS_DEPENDENCIES\n    : []),\n  ...(hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : []),\n  ...SWR_DEPENDENCIES,\n  ...SWR_INFINITE_DEPENDENCIES,\n  ...SWR_MUTATION_DEPENDENCIES,\n];\n\nconst generateSwrArguments = ({\n  operationName,\n  mutator,\n  isRequestOptions,\n  isInfinite,\n  httpClient,\n}: {\n  operationName: string;\n  mutator?: GeneratorMutator;\n  isRequestOptions: boolean;\n  isInfinite: boolean;\n  httpClient: OutputHttpClient;\n}) => {\n  const configType = isInfinite\n    ? 'SWRInfiniteConfiguration'\n    : 'SWRConfiguration';\n  const optionsType = isInfinite\n    ? '{ swrKeyLoader?: SWRInfiniteKeyLoader, enabled?: boolean }'\n    : '{ swrKey?: Key, enabled?: boolean }';\n  const definition = `${configType}<Awaited<ReturnType<typeof ${operationName}>>, TError> & ${optionsType}`;\n\n  if (!isRequestOptions) {\n    return `swrOptions?: ${definition}`;\n  }\n\n  return `options?: { swr?:${definition}, ${getSwrRequestOptions(httpClient, mutator)} }\\n`;\n};\n\nconst generateSwrMutationArguments = ({\n  operationName,\n  isRequestOptions,\n  mutator,\n  swrBodyType,\n  httpClient,\n}: {\n  operationName: string;\n  isRequestOptions: boolean;\n  mutator?: GeneratorMutator;\n  swrBodyType: string;\n  httpClient: OutputHttpClient;\n}) => {\n  const definition = `SWRMutationConfiguration<Awaited<ReturnType<typeof ${operationName}>>, TError, Key, ${swrBodyType}, Awaited<ReturnType<typeof ${operationName}>>> & { swrKey?: string }`;\n\n  if (!isRequestOptions) {\n    return `swrOptions?: ${definition}`;\n  }\n\n  return `options?: { swr?:${definition}, ${getSwrRequestOptions(httpClient, mutator)}}\\n`;\n};\n\nconst generateSwrImplementation = ({\n  operationName,\n  swrKeyFnName,\n  swrKeyLoaderFnName,\n  swrProperties,\n  swrKeyProperties,\n  params,\n  mutator,\n  isRequestOptions,\n  response,\n  swrOptions,\n  props,\n  doc,\n  httpClient,\n  pathOnlyParams,\n  headerOnlyParams,\n  hasQueryParams,\n  queryParamType,\n}: {\n  isRequestOptions: boolean;\n  operationName: string;\n  swrKeyFnName: string;\n  swrKeyLoaderFnName: string;\n  swrProperties: string;\n  swrKeyProperties: string;\n  params: GetterParams;\n  props: GetterProps;\n  response: GetterResponse;\n  mutator?: GeneratorMutator;\n  swrOptions: SwrOptions;\n  doc?: string;\n  httpClient: OutputHttpClient;\n  pathOnlyParams: string;\n  headerOnlyParams: string;\n  hasQueryParams: boolean;\n  queryParamType: string;\n}) => {\n  const swrProps = toObjectString(props, 'implementation');\n\n  const hasParamReservedWord = props.some(\n    (prop: GetterProp) => prop.name === 'query',\n  );\n  const queryResultVarName = hasParamReservedWord ? '_query' : 'query';\n\n  const httpFunctionProps = swrProperties;\n\n  const enabledImplementation = `const isEnabled = swrOptions?.enabled !== false${\n    params.length > 0\n      ? ` && !!(${params.map(({ name }) => name).join(' && ')})`\n      : ''\n  }`;\n  const swrKeyImplementation = `const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? ${swrKeyFnName}(${swrKeyProperties}) : null);`;\n  const swrKeyLoaderImplementation = `const swrKeyLoader = swrOptions?.swrKeyLoader ?? (isEnabled ? ${swrKeyLoaderFnName}(${swrKeyProperties}) : () => null);`;\n\n  const errorType = getSwrErrorType(response, httpClient, mutator);\n  const swrRequestSecondArg = getSwrRequestSecondArg(httpClient, mutator);\n  const httpRequestSecondArg = getHttpRequestSecondArg(httpClient, mutator);\n\n  const errorTypeExport = swrOptions.generateErrorTypes\n    ? `export type ${pascal(operationName)}InfiniteError = ${errorType}\\n`\n    : '';\n\n  const useSWRInfiniteImplementation = swrOptions.useInfinite\n    ? `\nexport type ${pascal(\n        operationName,\n      )}InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ${operationName}>>>\n${errorTypeExport}\n${doc}export const ${camel(\n        `use-${operationName}-infinite`,\n      )} = <TError = ${errorType}>(\n  ${swrProps} ${generateSwrArguments({\n    operationName,\n    mutator,\n    isRequestOptions,\n    isInfinite: true,\n    httpClient,\n  })}) => {\n  ${\n    isRequestOptions\n      ? `const {swr: swrOptions${swrRequestSecondArg ? `, ${swrRequestSecondArg}` : ''}} = options ?? {}`\n      : ''\n  }\n\n  ${enabledImplementation}\n  ${swrKeyLoaderImplementation}\n  const swrFn = ${\n    hasQueryParams\n      ? `([_url, pageParams]: [string, ${queryParamType} & { page: number }]) => ${operationName}(${pathOnlyParams}${pathOnlyParams ? ', ' : ''}pageParams${headerOnlyParams ? ', ' + headerOnlyParams : ''}${httpRequestSecondArg ? ', ' + httpRequestSecondArg : ''})`\n      : `([_url]: [string]) => ${operationName}(${pathOnlyParams}${headerOnlyParams ? (pathOnlyParams ? ', ' : '') + headerOnlyParams : ''}${httpRequestSecondArg ? (pathOnlyParams || headerOnlyParams ? ', ' : '') + httpRequestSecondArg : ''})`\n  }\n\n  const ${queryResultVarName} = useSWRInfinite<Awaited<ReturnType<typeof swrFn>>, TError>(swrKeyLoader, swrFn, ${\n    swrOptions.swrInfiniteOptions\n      ? `{\n    ${stringify(swrOptions.swrInfiniteOptions)?.slice(1, -1)}\n    ...swrOptions\n  }`\n      : 'swrOptions'\n  })\n\n  return {\n    swrKeyLoader,\n    ...${queryResultVarName}\n  }\n}\\n`\n    : '';\n\n  const queryErrorTypeExport = swrOptions.generateErrorTypes\n    ? `export type ${pascal(operationName)}QueryError = ${errorType}\\n`\n    : '';\n\n  const useSwrImplementation = `\nexport type ${pascal(\n    operationName,\n  )}QueryResult = NonNullable<Awaited<ReturnType<typeof ${operationName}>>>\n${queryErrorTypeExport}\n${doc}export const ${camel(`use-${operationName}`)} = <TError = ${errorType}>(\n  ${swrProps} ${generateSwrArguments({\n    operationName,\n    mutator,\n    isRequestOptions,\n    isInfinite: false,\n    httpClient,\n  })}) => {\n  ${\n    isRequestOptions\n      ? `const {swr: swrOptions${swrRequestSecondArg ? `, ${swrRequestSecondArg}` : ''}} = options ?? {}`\n      : ''\n  }\n\n  ${enabledImplementation}\n  ${swrKeyImplementation}\n  const swrFn = () => ${operationName}(${httpFunctionProps}${\n    httpFunctionProps && httpRequestSecondArg ? ', ' : ''\n  }${httpRequestSecondArg})\n\n  const ${queryResultVarName} = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, ${\n    swrOptions.swrOptions\n      ? `{\n    ${stringify(swrOptions.swrOptions)?.slice(1, -1)}\n    ...swrOptions\n  }`\n      : 'swrOptions'\n  })\n\n  return {\n    swrKey,\n    ...${queryResultVarName}\n  }\n}\\n`;\n\n  return useSWRInfiniteImplementation + useSwrImplementation;\n};\n\nconst generateSwrSuspenseImplementation = ({\n  operationName,\n  swrKeyFnName,\n  swrKeyProperties,\n  params,\n  mutator,\n  isRequestOptions,\n  response,\n  swrOptions,\n  props,\n  doc,\n  httpClient,\n  httpFunctionProps,\n}: {\n  isRequestOptions: boolean;\n  operationName: string;\n  swrKeyFnName: string;\n  swrKeyProperties: string;\n  params: GetterParams;\n  props: GetterProps;\n  response: GetterResponse;\n  mutator?: GeneratorMutator;\n  swrOptions: SwrOptions;\n  doc?: string;\n  httpClient: OutputHttpClient;\n  httpFunctionProps: string;\n}) => {\n  const swrProps = toObjectString(props, 'implementation');\n\n  const hasParamReservedWord = props.some(\n    (prop: GetterProp) => prop.name === 'query',\n  );\n  const queryResultVarName = hasParamReservedWord ? '_query' : 'query';\n\n  const enabledImplementation = `const isEnabled = swrOptions?.enabled !== false${\n    params.length > 0\n      ? ` && !!(${params.map(({ name }) => name).join(' && ')})`\n      : ''\n  }`;\n  const swrKeyImplementation = `const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? ${swrKeyFnName}(${swrKeyProperties}) : null);`;\n\n  const errorType = getSwrErrorType(response, httpClient, mutator);\n  const swrRequestSecondArg = getSwrRequestSecondArg(httpClient, mutator);\n  const httpRequestSecondArg = getHttpRequestSecondArg(httpClient, mutator);\n\n  const suspenseErrorTypeExport = swrOptions.generateErrorTypes\n    ? `export type ${pascal(operationName)}SuspenseQueryError = ${errorType}\\n`\n    : '';\n\n  const useSwrSuspenseImplementation = `\nexport type ${pascal(\n    operationName,\n  )}SuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof ${operationName}>>>\n${suspenseErrorTypeExport}\n${doc}export const ${camel(`use-${operationName}-suspense`)} = <TError = ${errorType}>(\n  ${swrProps} ${generateSwrArguments({\n    operationName,\n    mutator,\n    isRequestOptions,\n    isInfinite: false,\n    httpClient,\n  })}) => {\n  ${\n    isRequestOptions\n      ? `const {swr: swrOptions${swrRequestSecondArg ? `, ${swrRequestSecondArg}` : ''}} = options ?? {}`\n      : ''\n  }\n\n  ${enabledImplementation}\n  ${swrKeyImplementation}\n  const swrFn = () => ${operationName}(${httpFunctionProps}${\n    httpFunctionProps && httpRequestSecondArg ? ', ' : ''\n  }${httpRequestSecondArg})\n\n  const ${queryResultVarName} = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, ${\n    swrOptions.swrOptions\n      ? `{\n    ${stringify(swrOptions.swrOptions)?.slice(1, -1)}\n    suspense: true,\n    ...swrOptions\n  }`\n      : '{ suspense: true, ...swrOptions }'\n  })\n\n  return {\n    swrKey,\n    ...${queryResultVarName},\n    data: ${queryResultVarName}.data as NonNullable<typeof ${queryResultVarName}.data>,\n  }\n}\\n`;\n\n  return useSwrSuspenseImplementation;\n};\n\nconst generateSwrMutationImplementation = ({\n  isRequestOptions,\n  operationName,\n  swrKeyFnName,\n  swrMutationFetcherName,\n  swrKeyProperties,\n  swrMutationFetcherProperties,\n  swrProps,\n  props,\n  response,\n  mutator,\n  swrOptions,\n  doc,\n  swrBodyType,\n  httpClient,\n  verb,\n}: {\n  isRequestOptions: boolean;\n  operationName: string;\n  swrKeyFnName: string;\n  swrMutationFetcherName: string;\n  swrKeyProperties: string;\n  swrMutationFetcherProperties: string;\n  swrProps: string;\n  props: GetterProps;\n  response: GetterResponse;\n  mutator?: GeneratorMutator;\n  swrOptions: SwrOptions;\n  doc?: string;\n  swrBodyType: string;\n  httpClient: OutputHttpClient;\n  verb?: Verbs;\n}) => {\n  const hasParamReservedWord = props.some(\n    (prop: GetterProp) => prop.name === 'query',\n  );\n  const queryResultVarName = hasParamReservedWord ? '_query' : 'query';\n\n  const swrKeyImplementation = `const swrKey = swrOptions?.swrKey ?? ${swrKeyFnName}(${swrKeyProperties});`;\n\n  const errorType = getSwrErrorType(response, httpClient, mutator);\n  const swrRequestSecondArg = getSwrRequestSecondArg(httpClient, mutator);\n  const httpRequestSecondArg = getHttpRequestSecondArg(httpClient, mutator);\n\n  const mutationErrorTypeExport = swrOptions.generateErrorTypes\n    ? `export type ${pascal(operationName)}MutationError = ${errorType}\\n`\n    : '';\n\n  const useSwrImplementation = `\nexport type ${pascal(\n    operationName,\n  )}MutationResult = NonNullable<Awaited<ReturnType<typeof ${operationName}>>>\n${mutationErrorTypeExport}\n${doc}export const ${camel(`use-${operationName}${verb === Verbs.GET ? '-mutation' : ''}`)} = <TError = ${errorType}>(\n  ${swrProps} ${generateSwrMutationArguments({\n    operationName,\n    isRequestOptions,\n    mutator,\n    swrBodyType,\n    httpClient,\n  })}) => {\n\n  ${isRequestOptions ? `const {swr: swrOptions${swrRequestSecondArg ? `, ${swrRequestSecondArg}` : ''}} = options ?? {}` : ''}\n\n  ${swrKeyImplementation}\n  const swrFn = ${swrMutationFetcherName}(${swrMutationFetcherProperties}${\n    swrMutationFetcherProperties && httpRequestSecondArg ? ', ' : ''\n  }${httpRequestSecondArg});\n\n  const ${queryResultVarName} = useSWRMutation(swrKey, swrFn, ${\n    swrOptions.swrMutationOptions\n      ? `{\n    ${stringify(swrOptions.swrMutationOptions)?.slice(1, -1)}\n    ...swrOptions\n  }`\n      : 'swrOptions'\n  })\n\n  return {\n    swrKey,\n    ...${queryResultVarName}\n  }\n}\\n`;\n\n  return useSwrImplementation;\n};\n\nconst generateSwrHook = (\n  {\n    queryParams,\n    operationName,\n    body,\n    props,\n    verb,\n    params,\n    override,\n    mutator,\n    response,\n    summary,\n    deprecated,\n  }: GeneratorVerbOptions,\n  { route, context }: GeneratorOptions,\n) => {\n  const isRequestOptions = override.requestOptions !== false;\n  const httpClient = context.output.httpClient;\n  const doc = jsDoc({ summary, deprecated });\n\n  const queryKeyProps = toObjectString(\n    props.filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.QUERY_PARAM,\n    ),\n    'implementation',\n  );\n\n  const swrProps = toObjectString(\n    props.filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.QUERY_PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.HEADER,\n    ),\n    'implementation',\n  );\n\n  const swrMutationFetcherProperties = props\n    .filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.QUERY_PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.HEADER,\n    )\n    .map((param) => {\n      return param.type === GetterPropType.NAMED_PATH_PARAMS\n        ? param.destructured\n        : param.name;\n    })\n    .join(',');\n\n  const swrKeyProperties = props\n    .filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.QUERY_PARAM,\n    )\n    .map((prop) => {\n      return prop.type === GetterPropType.NAMED_PATH_PARAMS\n        ? prop.destructured\n        : prop.name;\n    })\n    .join(',');\n\n  const swrMutationFetcherName = camel(`get-${operationName}-mutation-fetcher`);\n\n  if (verb === Verbs.GET) {\n    const swrKeyProperties = props\n      .filter((prop) => prop.type !== GetterPropType.HEADER)\n      .map((param) => {\n        if (param.type === GetterPropType.NAMED_PATH_PARAMS)\n          return param.destructured;\n        return param.type === GetterPropType.BODY\n          ? body.implementation\n          : param.name;\n      })\n      .join(',');\n\n    const swrProperties = props\n      .map((param) => {\n        if (param.type === GetterPropType.NAMED_PATH_PARAMS)\n          return param.destructured;\n        return param.type === GetterPropType.BODY\n          ? body.implementation\n          : param.name;\n      })\n      .join(',');\n\n    // For useSWRInfinite: separate path params from query params\n    const pathOnlyParams = props\n      .filter(\n        (prop) =>\n          prop.type === GetterPropType.PARAM ||\n          prop.type === GetterPropType.NAMED_PATH_PARAMS,\n      )\n      .map((param) => {\n        return param.type === GetterPropType.NAMED_PATH_PARAMS\n          ? param.destructured\n          : param.name;\n      })\n      .join(',');\n\n    const headerOnlyParams = props\n      .filter((prop) => prop.type === GetterPropType.HEADER)\n      .map((param) => param.name)\n      .join(',');\n\n    const hasQueryParams = props.some(\n      (prop) => prop.type === GetterPropType.QUERY_PARAM,\n    );\n\n    // Extract just the type name from definition (e.g., \"params: ListPetsParams\" -> \"ListPetsParams\")\n    const queryParamType =\n      props\n        .find((prop) => prop.type === GetterPropType.QUERY_PARAM)\n        ?.definition.split(': ')[1] ?? 'never';\n\n    const queryKeyProps = toObjectString(\n      props.filter((prop) => prop.type !== GetterPropType.HEADER),\n      'implementation',\n    );\n\n    const swrKeyFnName = camel(`get-${operationName}-key`);\n    const swrKeyFn = `\nexport const ${swrKeyFnName} = (${queryKeyProps}) => [\\`${route}\\`${\n      queryParams ? ', ...(params ? [params]: [])' : ''\n    }] as const;\n`;\n\n    const swrKeyLoaderFnName = camel(\n      `get-${operationName}-infinite-key-loader`,\n    );\n    const swrKeyLoader = override.swr.useInfinite\n      ? `export const ${swrKeyLoaderFnName} = (${queryKeyProps}) => {\n  return (page: number, previousPageData?: Awaited<ReturnType<typeof ${operationName}>>) => {\n    if (previousPageData) {\n      const responseData = previousPageData.data\n      if (!responseData) return null\n\n      // Direct array response (e.g., API returns Pet[]) - stop when empty\n      if (Array.isArray(responseData) && responseData.length === 0) return null\n\n      // Wrapped response with data array (e.g., { data: Pet[], ... }) - stop when nested array is empty\n      if (typeof responseData === 'object' && 'data' in responseData) {\n        if (Array.isArray(responseData.data) && responseData.data.length === 0) return null\n      }\n\n      // Single object response (non-paginated endpoint) - stop after first page\n      if (!Array.isArray(responseData) && !(typeof responseData === 'object' && 'data' in responseData)) return null\n    }\n\n    return [\\`${route}\\`${queryParams ? ', ...(params ? [{...params,page}]: [{page}])' : ''}${\n      body.implementation ? `, ${body.implementation}` : ''\n    }] as const;\n  }\n}\\n`\n      : '';\n\n    const swrImplementation = generateSwrImplementation({\n      operationName,\n      swrKeyFnName,\n      swrKeyLoaderFnName,\n      swrProperties,\n      swrKeyProperties,\n      params,\n      props,\n      mutator,\n      isRequestOptions,\n      response,\n      swrOptions: override.swr,\n      doc,\n      httpClient,\n      pathOnlyParams,\n      headerOnlyParams,\n      hasQueryParams,\n      queryParamType,\n    });\n\n    const swrSuspenseImplementation = override.swr.useSuspense\n      ? generateSwrSuspenseImplementation({\n          operationName,\n          swrKeyFnName,\n          swrKeyProperties,\n          params,\n          props,\n          mutator,\n          isRequestOptions,\n          response,\n          swrOptions: override.swr,\n          doc,\n          httpClient,\n          httpFunctionProps: swrProperties,\n        })\n      : '';\n\n    if (!override.swr.useSWRMutationForGet) {\n      return (\n        swrKeyFn + swrKeyLoader + swrImplementation + swrSuspenseImplementation\n      );\n    }\n\n    // For OutputClient.SWR_GET_MUTATION, generate both useSWR and useSWRMutation\n    const httpFnPropertiesForGetWithoutHeaders = props\n      .filter((prop) => prop.type !== GetterPropType.HEADER)\n      .map((prop) => {\n        return prop.type === GetterPropType.NAMED_PATH_PARAMS\n          ? prop.destructured\n          : prop.name;\n      })\n      .join(', ');\n\n    const headerParamsForGet = props\n      .filter((prop) => prop.type === GetterPropType.HEADER)\n      .map((param) => param.name)\n      .join(', ');\n\n    const httpFnPropertiesForGet = [\n      httpFnPropertiesForGetWithoutHeaders,\n      headerParamsForGet,\n    ]\n      .filter(Boolean)\n      .join(', ');\n\n    const swrMutationFetcherType = getSwrMutationFetcherType(\n      response,\n      httpClient,\n      override.fetch.includeHttpResponseReturnType,\n      operationName,\n      mutator,\n    );\n    const swrMutationFetcherOptionType = getSwrMutationFetcherOptionType(\n      httpClient,\n      mutator,\n    );\n\n    const swrMutationFetcherOptions =\n      isRequestOptions && swrMutationFetcherOptionType\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: ${swrMutationFetcherOptionType}`\n        : '';\n\n    const swrMutationFetcherFn = `\nexport const ${swrMutationFetcherName} = (${queryKeyProps} ${swrMutationFetcherOptions}) => {\n  return (_: Key, __: { arg?: never }): ${swrMutationFetcherType} => {\n    return ${operationName}(${httpFnPropertiesForGet}${\n      swrMutationFetcherOptions.length > 0\n        ? (httpFnPropertiesForGet.length > 0 ? ', ' : '') + 'options'\n        : ''\n    });\n  }\n}\n`;\n\n    const swrMutationImplementation = generateSwrMutationImplementation({\n      operationName,\n      swrKeyFnName,\n      swrMutationFetcherName,\n      swrKeyProperties,\n      swrMutationFetcherProperties,\n      swrProps,\n      props,\n      isRequestOptions,\n      response,\n      mutator,\n      swrOptions: override.swr,\n      doc,\n      swrBodyType: 'never',\n      httpClient,\n      verb: Verbs.GET,\n    });\n\n    return (\n      swrKeyFn +\n      swrKeyLoader +\n      swrImplementation +\n      swrSuspenseImplementation +\n      swrMutationFetcherFn +\n      swrMutationImplementation\n    );\n  } else {\n    const httpFnPropertiesWithoutHeaders = props\n      .filter((prop) => prop.type !== GetterPropType.HEADER)\n      .map((prop) => {\n        if (prop.type === GetterPropType.NAMED_PATH_PARAMS) {\n          return prop.destructured;\n        } else if (prop.type === GetterPropType.BODY) {\n          return `arg`;\n        } else {\n          return prop.name;\n        }\n      })\n      .join(', ');\n\n    const headerParams = props\n      .filter((prop) => prop.type === GetterPropType.HEADER)\n      .map((param) => param.name)\n      .join(', ');\n\n    const httpFnProperties = [httpFnPropertiesWithoutHeaders, headerParams]\n      .filter(Boolean)\n      .join(', ');\n\n    const swrKeyFnName = camel(`get-${operationName}-mutation-key`);\n    const swrMutationKeyFn = `export const ${swrKeyFnName} = (${queryKeyProps}) => [\\`${route}\\`${\n      queryParams ? ', ...(params ? [params]: [])' : ''\n    }] as const;\n`;\n\n    const swrMutationFetcherOptionType = getSwrMutationFetcherOptionType(\n      httpClient,\n      mutator,\n    );\n\n    const swrMutationFetcherOptions =\n      isRequestOptions && swrMutationFetcherOptionType\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: ${swrMutationFetcherOptionType}`\n        : '';\n\n    const swrMutationFetcherArg = props.some(\n      (prop) => prop.type === GetterPropType.BODY,\n    )\n      ? '{ arg }'\n      : '__';\n\n    const swrBodyType =\n      props\n        .find((prop) => prop.type === GetterPropType.BODY)\n        ?.implementation.split(': ')[1] ?? 'Arguments';\n\n    const swrMutationFetcherFn = `\nexport const ${swrMutationFetcherName} = (${swrProps} ${swrMutationFetcherOptions}) => {\n  return (_: Key, ${swrMutationFetcherArg}: { arg: ${swrBodyType} }) => {\n    return ${operationName}(${httpFnProperties}${\n      swrMutationFetcherOptions.length > 0\n        ? (httpFnProperties.length > 0 ? ', ' : '') + 'options'\n        : ''\n    });\n  }\n}\\n`;\n\n    const swrImplementation = generateSwrMutationImplementation({\n      operationName,\n      swrKeyFnName,\n      swrMutationFetcherName,\n      swrKeyProperties,\n      swrMutationFetcherProperties,\n      swrProps,\n      props,\n      isRequestOptions,\n      response,\n      mutator,\n      swrOptions: override.swr,\n      doc,\n      swrBodyType,\n      httpClient: context.output.httpClient,\n    });\n\n    return swrMutationFetcherFn + swrMutationKeyFn + swrImplementation;\n  }\n};\n\nexport const generateSwrHeader: ClientHeaderBuilder = (params) =>\n  `\n  ${\n    params.hasAwaitedType\n      ? ''\n      : `type AwaitedInput<T> = PromiseLike<T> | T;\\n\n      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;\\n\\n`\n  }\n  ${\n    params.isRequestOptions && params.isMutator\n      ? `type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\\n\\n`\n      : ''\n  }\n  ${getSwrHeader(params)}\n`;\n\nexport const generateSwr: ClientBuilder = (verbOptions, options) => {\n  const imports = generateVerbImports(verbOptions);\n  const functionImplementation = generateSwrRequestFunction(\n    verbOptions,\n    options,\n  );\n  const hookImplementation = generateSwrHook(verbOptions, options);\n\n  return {\n    implementation: `${functionImplementation}\\n\\n${hookImplementation}`,\n    imports,\n  };\n};\n\nconst swrClientBuilder: ClientGeneratorsBuilder = {\n  client: generateSwr,\n  header: generateSwrHeader,\n  dependencies: getSwrDependencies,\n};\n\nexport const builder = () => () => swrClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}