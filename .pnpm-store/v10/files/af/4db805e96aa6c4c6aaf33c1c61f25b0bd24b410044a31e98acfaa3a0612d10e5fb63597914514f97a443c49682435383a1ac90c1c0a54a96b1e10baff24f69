import { GetterPropType, OutputClient, OutputHttpClient, TEMPLATE_TAG_REGEX, Verbs, camel, compareVersions, generateFormDataAndUrlEncodedFunction, generateMutator, generateMutatorConfig, generateMutatorRequestOptions, generateOptions, generateVerbImports, getRouteAsArray, isObject, isString, isSyntheticDefaultImportsAllow, jsDoc, mergeDeep, pascal, stringify, toObjectString, upath } from "@orval/core";
import { generateFetchHeader, generateRequestFunction } from "@orval/fetch";
import chalk from "chalk";
import { omitBy } from "remeda";

//#region src/utils.ts
const normalizeQueryOptions = (queryOptions = {}, outputWorkspace) => {
	return {
		...queryOptions.usePrefetch ? { usePrefetch: true } : {},
		...queryOptions.useInvalidate ? { useInvalidate: true } : {},
		...queryOptions.useQuery ? { useQuery: true } : {},
		...queryOptions.useInfinite ? { useInfinite: true } : {},
		...queryOptions.useInfiniteQueryParam ? { useInfiniteQueryParam: queryOptions.useInfiniteQueryParam } : {},
		...queryOptions.options ? { options: queryOptions.options } : {},
		...queryOptions.queryKey ? { queryKey: normalizeMutator(outputWorkspace, queryOptions.queryKey) } : {},
		...queryOptions.queryOptions ? { queryOptions: normalizeMutator(outputWorkspace, queryOptions.queryOptions) } : {},
		...queryOptions.mutationOptions ? { mutationOptions: normalizeMutator(outputWorkspace, queryOptions.mutationOptions) } : {},
		...queryOptions.signal ? { signal: true } : {},
		...queryOptions.shouldExportMutatorHooks ? { shouldExportMutatorHooks: true } : {},
		...queryOptions.shouldExportQueryKey ? { shouldExportQueryKey: true } : {},
		...queryOptions.shouldExportHttpClient ? { shouldExportHttpClient: true } : {},
		...queryOptions.shouldSplitQueryKey ? { shouldSplitQueryKey: true } : {},
		...queryOptions.useOperationIdAsQueryKey ? { useOperationIdAsQueryKey: true } : {}
	};
};
const normalizeMutator = (workspace, mutator) => {
	if (isObject(mutator)) {
		if (!mutator.path) throw new Error(chalk.red(`Mutator need a path`));
		return {
			...mutator,
			path: upath.resolve(workspace, mutator.path),
			default: mutator.default ?? !mutator.name
		};
	}
	if (isString(mutator)) return {
		path: upath.resolve(workspace, mutator),
		default: true
	};
	return mutator;
};
function vueWrapTypeWithMaybeRef(props) {
	return props.map((prop) => {
		const [paramName, paramType] = prop.implementation.split(":");
		if (!paramType) return prop;
		const name = prop.type === GetterPropType.NAMED_PATH_PARAMS ? prop.name : paramName;
		const [type, defaultValue] = paramType.split("=");
		return {
			...prop,
			implementation: `${name}: MaybeRef<${type.trim()}>${defaultValue ? ` = ${defaultValue}` : ""}`
		};
	});
}
const vueUnRefParams = (props) => {
	return props.map((prop) => {
		if (prop.type === GetterPropType.NAMED_PATH_PARAMS) return `const ${prop.destructured} = unref(${prop.name});`;
		return `${prop.name} = unref(${prop.name});`;
	}).join("\n");
};
const wrapRouteParameters = (route, prepend, append) => route.replaceAll(TEMPLATE_TAG_REGEX, `\${${prepend}$1${append}}`);
const makeRouteSafe = (route) => wrapRouteParameters(route, "encodeURIComponent(String(", "))");
const isVue = (client) => OutputClient.VUE_QUERY === client;
const isSolid = (client) => OutputClient.SOLID_QUERY === client;
const isAngular = (client) => OutputClient.ANGULAR_QUERY === client;
const isReact = (client) => OutputClient.REACT_QUERY === client;
const isSvelte = (client) => OutputClient.SVELTE_QUERY === client;
const getQueryTypeForFramework = (type) => {
	switch (type) {
		case "suspenseQuery": return "query";
		case "suspenseInfiniteQuery": return "infiniteQuery";
		default: return type;
	}
};
const getHasSignal = ({ overrideQuerySignal = false }) => overrideQuerySignal;

//#endregion
//#region src/client.ts
const AXIOS_DEPENDENCIES = [{
	exports: [
		{
			name: "axios",
			default: true,
			values: true,
			syntheticDefaultImport: true
		},
		{ name: "AxiosRequestConfig" },
		{ name: "AxiosResponse" },
		{ name: "AxiosError" }
	],
	dependency: "axios"
}];
const ANGULAR_HTTP_DEPENDENCIES = [
	{
		exports: [
			{
				name: "HttpClient",
				values: true
			},
			{
				name: "HttpHeaders",
				values: true
			},
			{
				name: "HttpParams",
				values: true
			},
			{ name: "HttpContext" }
		],
		dependency: "@angular/common/http"
	},
	{
		exports: [{
			name: "lastValueFrom",
			values: true
		}, {
			name: "fromEvent",
			values: true
		}],
		dependency: "rxjs"
	},
	{
		exports: [{
			name: "takeUntil",
			values: true
		}],
		dependency: "rxjs/operators"
	}
];
const generateQueryRequestFunction = (verbOptions, options, isVue$1, isAngularClient = false) => {
	if (isAngularClient || options.context.output.httpClient === OutputHttpClient.ANGULAR) return generateAngularHttpRequestFunction(verbOptions, options);
	return options.context.output.httpClient === OutputHttpClient.AXIOS ? generateAxiosRequestFunction(verbOptions, options, isVue$1) : generateRequestFunction(verbOptions, options);
};
const generateAngularHttpRequestFunction = ({ headers, queryParams, operationName, response, mutator, body, props, verb, formData, formUrlEncoded, override }, { route, context }) => {
	const isRequestOptions = override.requestOptions !== false;
	const isFormData = !override.formData.disabled;
	const isFormUrlEncoded = override.formUrlEncoded !== false;
	const hasSignal = getHasSignal({ overrideQuerySignal: override.query.signal });
	const hasSignalParam = props.some((prop) => prop.name === "signal");
	const bodyForm = generateFormDataAndUrlEncodedFunction({
		formData,
		formUrlEncoded,
		body,
		isFormData,
		isFormUrlEncoded
	});
	if (mutator) {
		const mutatorConfig = generateMutatorConfig({
			route,
			body,
			headers,
			queryParams,
			response,
			verb,
			isFormData,
			isFormUrlEncoded,
			hasSignal,
			hasSignalParam,
			isExactOptionalPropertyTypes: !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes,
			isVue: false
		});
		const requestOptions = isRequestOptions ? generateMutatorRequestOptions(override.requestOptions, mutator.hasSecondArg) : "";
		const propsImplementation = toObjectString(props, "implementation");
		return `${override.query.shouldExportHttpClient ? "export " : ""}const ${operationName} = (\n    ${propsImplementation}\n ${isRequestOptions && mutator.hasSecondArg ? `options${context.output.optionsParamRequired ? "" : "?"}: SecondParameter<typeof ${mutator.name}>,` : ""} ${getSignalDefinition({
			hasSignal,
			hasSignalParam
		})}) => {
      ${bodyForm}
      return ${mutator.name}<${response.definition.success || "unknown"}>(
      ${mutatorConfig},
      ${requestOptions});
    }
  `;
	}
	const queryProps = toObjectString(props, "implementation").replace(/,\s*$/, "");
	const dataType = response.definition.success || "unknown";
	const hasQueryParams = queryParams?.schema.name;
	const urlConstruction = hasQueryParams ? `const httpParams = params ? new HttpParams({ fromObject: params as Record<string, string> }) : undefined;
    const url = \`${route}\`;` : `const url = \`${route}\`;`;
	const httpOptions = [];
	if (hasQueryParams) httpOptions.push("params: httpParams");
	if (headers) httpOptions.push("headers: new HttpHeaders(headers)");
	const optionsStr = httpOptions.length > 0 ? `, { ${httpOptions.join(", ")} }` : "";
	let httpCall;
	const bodyArg = body.definition ? toObjectString([body], "implementation").replace(/,\s*$/, "") : "";
	switch (verb) {
		case "get":
		case "head":
			httpCall = `http.${verb}<${dataType}>(url${optionsStr})`;
			break;
		case "delete":
			httpCall = bodyArg ? `http.${verb}<${dataType}>(url, { ${httpOptions.length > 0 ? httpOptions.join(", ") + ", " : ""}body: ${bodyArg} })` : `http.${verb}<${dataType}>(url${optionsStr})`;
			break;
		default:
			httpCall = `http.${verb}<${dataType}>(url, ${bodyArg || "undefined"}${optionsStr})`;
			break;
	}
	const additionalParams = [queryProps, hasSignal ? "options?: { signal?: AbortSignal | null }" : ""].filter(Boolean).join(", ");
	return `${override.query.shouldExportHttpClient ? "export " : ""}const ${operationName} = (
    http: HttpClient${additionalParams ? `,\n    ${additionalParams}` : ""}
  ): Promise<${dataType}> => {
    ${bodyForm}
    ${urlConstruction}
    const request$ = ${httpCall};
    if (options?.signal) {
      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));
    }
    return lastValueFrom(request$);
  }
`;
};
const generateAxiosRequestFunction = ({ headers, queryParams, operationName, response, mutator, body, props: _props, verb, formData, formUrlEncoded, override, paramsSerializer }, { route: _route, context }, isVue$1) => {
	let props = _props;
	let route = _route;
	if (isVue$1) props = vueWrapTypeWithMaybeRef(_props);
	if (context.output.urlEncodeParameters) route = makeRouteSafe(route);
	const isRequestOptions = override.requestOptions !== false;
	const isFormData = !override.formData.disabled;
	const isFormUrlEncoded = override.formUrlEncoded !== false;
	const hasSignal = getHasSignal({ overrideQuerySignal: override.query.signal });
	const hasSignalParam = _props.some((prop) => prop.name === "signal");
	const isExactOptionalPropertyTypes = !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;
	const bodyForm = generateFormDataAndUrlEncodedFunction({
		formData,
		formUrlEncoded,
		body,
		isFormData,
		isFormUrlEncoded
	});
	if (mutator) {
		const mutatorConfig = generateMutatorConfig({
			route,
			body,
			headers,
			queryParams,
			response,
			verb,
			isFormData,
			isFormUrlEncoded,
			hasSignal,
			hasSignalParam,
			isExactOptionalPropertyTypes,
			isVue: isVue$1
		});
		const bodyDefinition = body.definition.replace("[]", String.raw`\[\]`);
		const propsImplementation = mutator.bodyTypeName && body.definition ? toObjectString(props, "implementation").replace(new RegExp(String.raw`(\w*):\s?${bodyDefinition}`), `$1: ${mutator.bodyTypeName}<${body.definition}>`) : toObjectString(props, "implementation");
		const requestOptions = isRequestOptions ? generateMutatorRequestOptions(override.requestOptions, mutator.hasSecondArg) : "";
		if (mutator.isHook) {
			const ret = `${override.query.shouldExportMutatorHooks ? "export " : ""}const use${pascal(operationName)}Hook = () => {
        const ${operationName} = ${mutator.name}<${response.definition.success || "unknown"}>();

        return useCallback((\n    ${propsImplementation}\n ${isRequestOptions && mutator.hasSecondArg ? `options${context.output.optionsParamRequired ? "" : "?"}: SecondParameter<ReturnType<typeof ${mutator.name}>>,` : ""}${getSignalDefinition({
				hasSignal,
				hasSignalParam
			})}) => {${bodyForm}
        return ${operationName}(
          ${mutatorConfig},
          ${requestOptions});
        }, [${operationName}])
      }
    `;
			const vueRet = `${override.query.shouldExportMutatorHooks ? "export " : ""}const use${pascal(operationName)}Hook = () => {
        const ${operationName} = ${mutator.name}<${response.definition.success || "unknown"}>();

        return (\n    ${propsImplementation}\n ${isRequestOptions && mutator.hasSecondArg ? `options${context.output.optionsParamRequired ? "" : "?"}: SecondParameter<ReturnType<typeof ${mutator.name}>>,` : ""}${getSignalDefinition({
				hasSignal,
				hasSignalParam
			})}) => {${bodyForm}
        return ${operationName}(
          ${mutatorConfig},
          ${requestOptions});
        }
      }
    `;
			return isVue$1 ? vueRet : ret;
		}
		return `${override.query.shouldExportHttpClient ? "export " : ""}const ${operationName} = (\n    ${propsImplementation}\n ${isRequestOptions && mutator.hasSecondArg ? `options${context.output.optionsParamRequired ? "" : "?"}: SecondParameter<typeof ${mutator.name}>,` : ""}${getSignalDefinition({
			hasSignal,
			hasSignalParam
		})}) => {
      ${isVue$1 ? vueUnRefParams(props) : ""}
      ${bodyForm}
      return ${mutator.name}<${response.definition.success || "unknown"}>(
      ${mutatorConfig},
      ${requestOptions});
    }
  `;
	}
	const isSyntheticDefaultImportsAllowed = isSyntheticDefaultImportsAllow(context.output.tsconfig);
	const options = generateOptions({
		route,
		body,
		headers,
		queryParams,
		response,
		verb,
		requestOptions: override.requestOptions,
		isFormData,
		isFormUrlEncoded,
		paramsSerializer,
		paramsSerializerOptions: override.paramsSerializerOptions,
		isExactOptionalPropertyTypes,
		hasSignal,
		hasSignalParam,
		isVue: isVue$1
	});
	const optionsArgs = generateRequestOptionsArguments({
		isRequestOptions,
		hasSignal,
		hasSignalParam
	});
	const queryProps = toObjectString(props, "implementation");
	return `${override.query.shouldExportHttpClient ? "export " : ""}const ${operationName} = (\n    ${queryProps} ${optionsArgs} ): Promise<AxiosResponse<${response.definition.success || "unknown"}>> => {
    ${isVue$1 ? vueUnRefParams(props) : ""}
    ${bodyForm}
    return axios${isSyntheticDefaultImportsAllowed ? "" : ".default"}.${verb}(${options});
  }
`;
};
const generateRequestOptionsArguments = ({ isRequestOptions, hasSignal, hasSignalParam = false }) => {
	if (isRequestOptions) return "options?: AxiosRequestConfig\n";
	return getSignalDefinition({
		hasSignal,
		hasSignalParam
	});
};
const getSignalDefinition = ({ hasSignal, hasSignalParam = false }) => {
	if (!hasSignal) return "";
	return `${hasSignalParam ? "querySignal" : "signal"}?: AbortSignal\n`;
};
const getQueryArgumentsRequestType = (httpClient, mutator) => {
	if (!mutator) return httpClient === OutputHttpClient.AXIOS ? `axios?: AxiosRequestConfig` : "fetch?: RequestInit";
	if (mutator.hasSecondArg && !mutator.isHook) return `request?: SecondParameter<typeof ${mutator.name}>`;
	if (mutator.hasSecondArg && mutator.isHook) return `request?: SecondParameter<ReturnType<typeof ${mutator.name}>>`;
	return "";
};
const getQueryOptions = ({ isRequestOptions, mutator, isExactOptionalPropertyTypes, hasSignal, httpClient, hasSignalParam = false }) => {
	const signalVar = hasSignalParam ? "querySignal" : "signal";
	const signalProp = hasSignalParam ? `signal: ${signalVar}` : "signal";
	if (!mutator && isRequestOptions) {
		const options = httpClient === OutputHttpClient.AXIOS ? "axiosOptions" : "fetchOptions";
		if (!hasSignal) return options;
		return `{ ${isExactOptionalPropertyTypes ? `...(${signalVar} ? { ${signalProp} } : {})` : signalProp}, ...${options} }`;
	}
	if (mutator?.hasSecondArg && httpClient === OutputHttpClient.ANGULAR) {
		if (!hasSignal) return "http";
		return `http, ${signalVar}`;
	}
	if (mutator?.hasSecondArg && isRequestOptions) {
		if (!hasSignal) return "requestOptions";
		return httpClient === OutputHttpClient.AXIOS || httpClient === OutputHttpClient.ANGULAR ? `requestOptions, ${signalVar}` : `{ ${signalProp}, ...requestOptions }`;
	}
	if (hasSignal) {
		if (httpClient === OutputHttpClient.AXIOS) return signalVar;
		if (httpClient === OutputHttpClient.ANGULAR && mutator) return signalVar;
		return `{ ${signalProp} }`;
	}
	return "";
};
const getHookOptions = ({ isRequestOptions, httpClient, mutator }) => {
	if (!isRequestOptions) return "";
	let value = "const {query: queryOptions";
	if (!mutator) {
		const options = httpClient === OutputHttpClient.AXIOS ? ", axios: axiosOptions" : ", fetch: fetchOptions";
		value += options;
	}
	if (mutator?.hasSecondArg) value += ", request: requestOptions";
	value += "} = options ?? {};";
	return value;
};
const dedupeUnionTypes = (types) => {
	if (!types) return types;
	return [...new Set(types.split("|").map((t) => t.trim()).filter(Boolean))].join(" | ");
};
const getQueryErrorType = (operationName, response, httpClient, mutator) => {
	const errorsType = dedupeUnionTypes(response.definition.errors || "unknown");
	if (mutator) return mutator.hasErrorType ? `${mutator.default ? pascal(operationName) : ""}ErrorType<${errorsType}>` : errorsType;
	else return httpClient === OutputHttpClient.AXIOS ? `AxiosError<${errorsType}>` : errorsType;
};
const getHooksOptionImplementation = (isRequestOptions, httpClient, operationName, mutator) => {
	const options = httpClient === OutputHttpClient.AXIOS ? ", axios: axiosOptions" : ", fetch: fetchOptions";
	return isRequestOptions ? `const mutationKey = ['${operationName}'];
const {mutation: mutationOptions${mutator ? mutator.hasSecondArg ? ", request: requestOptions" : "" : options}} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }${mutator?.hasSecondArg ? ", request: undefined" : ""}${mutator ? "" : httpClient === OutputHttpClient.AXIOS ? ", axios: undefined" : ", fetch: undefined"}};` : "";
};
const getMutationRequestArgs = (isRequestOptions, httpClient, mutator) => {
	const options = httpClient === OutputHttpClient.AXIOS ? "axiosOptions" : "fetchOptions";
	if (mutator?.hasSecondArg && httpClient === OutputHttpClient.ANGULAR) return "http";
	return isRequestOptions ? mutator ? mutator.hasSecondArg ? "requestOptions" : "" : options : "";
};
const getHttpFunctionQueryProps = (isVue$1, httpClient, queryProperties, isAngular$1 = false, hasMutator = false) => {
	const result = isVue$1 && httpClient === OutputHttpClient.FETCH && queryProperties ? queryProperties.split(",").map((prop) => `unref(${prop})`).join(",") : queryProperties;
	if ((isAngular$1 || httpClient === OutputHttpClient.ANGULAR) && !hasMutator) return result ? `http, ${result}` : "http";
	return result;
};
const getQueryHeader = (params) => {
	return params.output.httpClient === OutputHttpClient.FETCH ? generateFetchHeader(params) : "";
};

//#endregion
//#region src/dependencies.ts
const REACT_DEPENDENCIES = [{
	exports: [{
		name: "useCallback",
		values: true
	}],
	dependency: "react"
}];
const PARAMS_SERIALIZER_DEPENDENCIES = [{
	exports: [{
		name: "qs",
		default: true,
		values: true,
		syntheticDefaultImport: true
	}],
	dependency: "qs"
}];
const SVELTE_QUERY_DEPENDENCIES_V3 = [{
	exports: [
		{
			name: "useQuery",
			values: true
		},
		{
			name: "useInfiniteQuery",
			values: true
		},
		{
			name: "useMutation",
			values: true
		},
		{
			name: "useQueryClient",
			values: true
		},
		{ name: "UseQueryOptions" },
		{ name: "UseInfiniteQueryOptions" },
		{ name: "UseMutationOptions" },
		{ name: "QueryFunction" },
		{ name: "MutationFunction" },
		{ name: "UseQueryStoreResult" },
		{ name: "UseInfiniteQueryStoreResult" },
		{ name: "QueryKey" },
		{ name: "CreateMutationResult" },
		{ name: "InvalidateOptions" }
	],
	dependency: "@sveltestack/svelte-query"
}];
const SVELTE_QUERY_DEPENDENCIES = [{
	exports: [
		{
			name: "createQuery",
			values: true
		},
		{
			name: "createInfiniteQuery",
			values: true
		},
		{
			name: "createMutation",
			values: true
		},
		{
			name: "useQueryClient",
			values: true
		},
		{ name: "CreateQueryOptions" },
		{ name: "CreateInfiniteQueryOptions" },
		{ name: "MutationFunctionContext" },
		{ name: "CreateMutationOptions" },
		{ name: "QueryFunction" },
		{ name: "MutationFunction" },
		{ name: "CreateQueryResult" },
		{ name: "CreateInfiniteQueryResult" },
		{ name: "QueryKey" },
		{ name: "InfiniteData" },
		{ name: "CreateMutationResult" },
		{ name: "DataTag" },
		{ name: "QueryClient" },
		{ name: "InvalidateOptions" }
	],
	dependency: "@tanstack/svelte-query"
}];
const isSvelteQueryV3 = (packageJson) => {
	const hasSvelteQuery = packageJson?.dependencies?.["@sveltestack/svelte-query"] ?? packageJson?.devDependencies?.["@sveltestack/svelte-query"] ?? packageJson?.peerDependencies?.["@sveltestack/svelte-query"];
	const hasSvelteQueryV4 = packageJson?.dependencies?.["@tanstack/svelte-query"] ?? packageJson?.devDependencies?.["@tanstack/svelte-query"] ?? packageJson?.peerDependencies?.["@tanstack/svelte-query"];
	return !!hasSvelteQuery && !hasSvelteQueryV4;
};
const isSvelteQueryV6 = (packageJson) => {
	return isQueryV6(packageJson, "svelte-query");
};
const getSvelteQueryDependencies = (hasGlobalMutator, hasParamsSerializerOptions, packageJson, httpClient) => {
	const hasSvelteQueryV3 = isSvelteQueryV3(packageJson);
	return [
		...!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS ? AXIOS_DEPENDENCIES : [],
		...hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : [],
		...hasSvelteQueryV3 ? SVELTE_QUERY_DEPENDENCIES_V3 : SVELTE_QUERY_DEPENDENCIES
	];
};
const REACT_QUERY_DEPENDENCIES_V3 = [{
	exports: [
		{
			name: "useQuery",
			values: true
		},
		{
			name: "useInfiniteQuery",
			values: true
		},
		{
			name: "useMutation",
			values: true
		},
		{
			name: "useQueryClient",
			values: true
		},
		{ name: "UseQueryOptions" },
		{ name: "UseInfiniteQueryOptions" },
		{ name: "UseMutationOptions" },
		{ name: "QueryFunction" },
		{ name: "MutationFunction" },
		{ name: "UseQueryResult" },
		{ name: "UseInfiniteQueryResult" },
		{ name: "QueryKey" },
		{ name: "QueryClient" },
		{ name: "UseMutationResult" },
		{ name: "InvalidateOptions" }
	],
	dependency: "react-query"
}];
const REACT_QUERY_DEPENDENCIES = [{
	exports: [
		{
			name: "useQuery",
			values: true
		},
		{
			name: "useSuspenseQuery",
			values: true
		},
		{
			name: "useInfiniteQuery",
			values: true
		},
		{
			name: "useSuspenseInfiniteQuery",
			values: true
		},
		{
			name: "useMutation",
			values: true
		},
		{
			name: "useQueryClient",
			values: true
		},
		{ name: "UseQueryOptions" },
		{ name: "DefinedInitialDataOptions" },
		{ name: "UndefinedInitialDataOptions" },
		{ name: "UseSuspenseQueryOptions" },
		{ name: "UseInfiniteQueryOptions" },
		{ name: "UseSuspenseInfiniteQueryOptions" },
		{ name: "UseMutationOptions" },
		{ name: "QueryFunction" },
		{ name: "MutationFunction" },
		{ name: "UseQueryResult" },
		{ name: "DefinedUseQueryResult" },
		{ name: "UseSuspenseQueryResult" },
		{ name: "UseInfiniteQueryResult" },
		{ name: "DefinedUseInfiniteQueryResult" },
		{ name: "UseSuspenseInfiniteQueryResult" },
		{ name: "QueryKey" },
		{ name: "QueryClient" },
		{ name: "InfiniteData" },
		{ name: "UseMutationResult" },
		{ name: "DataTag" },
		{ name: "InvalidateOptions" }
	],
	dependency: "@tanstack/react-query"
}];
const getReactQueryDependencies = (hasGlobalMutator, hasParamsSerializerOptions, packageJson, httpClient, hasTagsMutator, override) => {
	const hasReactQuery = packageJson?.dependencies?.["react-query"] ?? packageJson?.devDependencies?.["react-query"] ?? packageJson?.peerDependencies?.["react-query"];
	const hasReactQueryV4 = packageJson?.dependencies?.["@tanstack/react-query"] ?? packageJson?.devDependencies?.["@tanstack/react-query"] ?? packageJson?.peerDependencies?.["@tanstack/react-query"];
	const useReactQueryV3 = override.query.version === void 0 ? hasReactQuery && !hasReactQueryV4 : override.query.version <= 3;
	return [
		...hasGlobalMutator || hasTagsMutator ? REACT_DEPENDENCIES : [],
		...!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS ? AXIOS_DEPENDENCIES : [],
		...hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : [],
		...useReactQueryV3 ? REACT_QUERY_DEPENDENCIES_V3 : REACT_QUERY_DEPENDENCIES
	];
};
const VUE_QUERY_DEPENDENCIES_V3 = [
	{
		exports: [
			{
				name: "useQuery",
				values: true
			},
			{
				name: "useInfiniteQuery",
				values: true
			},
			{
				name: "useMutation",
				values: true
			}
		],
		dependency: "vue-query"
	},
	{
		exports: [
			{ name: "UseQueryOptions" },
			{ name: "UseInfiniteQueryOptions" },
			{ name: "UseMutationOptions" },
			{ name: "QueryFunction" },
			{ name: "MutationFunction" },
			{ name: "UseQueryResult" },
			{ name: "UseInfiniteQueryResult" },
			{ name: "QueryKey" },
			{ name: "UseMutationReturnType" },
			{ name: "InvalidateOptions" }
		],
		dependency: "vue-query/types"
	},
	{
		exports: [{
			name: "unref",
			values: true
		}, {
			name: "computed",
			values: true
		}],
		dependency: "vue"
	},
	{
		exports: [{ name: "UseQueryReturnType" }],
		dependency: "vue-query/lib/vue/useBaseQuery"
	}
];
const VUE_QUERY_DEPENDENCIES = [{
	exports: [
		{
			name: "useQuery",
			values: true
		},
		{
			name: "useInfiniteQuery",
			values: true
		},
		{
			name: "useMutation",
			values: true
		},
		{ name: "UseQueryOptions" },
		{ name: "UseInfiniteQueryOptions" },
		{ name: "UseMutationOptions" },
		{ name: "QueryFunction" },
		{ name: "MutationFunction" },
		{ name: "QueryKey" },
		{ name: "UseQueryReturnType" },
		{ name: "UseInfiniteQueryReturnType" },
		{ name: "InfiniteData" },
		{ name: "UseMutationReturnType" },
		{ name: "DataTag" },
		{ name: "QueryClient" },
		{ name: "InvalidateOptions" }
	],
	dependency: "@tanstack/vue-query"
}, {
	exports: [
		{
			name: "unref",
			values: true
		},
		{ name: "MaybeRef" },
		{
			name: "computed",
			values: true
		}
	],
	dependency: "vue"
}];
const SOLID_QUERY_DEPENDENCIES = [{
	exports: [
		{
			name: "createQuery",
			values: true
		},
		{
			name: "createInfiniteQuery",
			values: true
		},
		{
			name: "createMutation",
			values: true
		},
		{ name: "CreateQueryOptions" },
		{ name: "CreateInfiniteQueryOptions" },
		{ name: "CreateMutationOptions" },
		{ name: "QueryFunction" },
		{ name: "MutationFunction" },
		{ name: "CreateQueryResult" },
		{ name: "CreateInfiniteQueryResult" },
		{ name: "QueryKey" },
		{ name: "InfiniteData" },
		{ name: "CreateMutationResult" },
		{ name: "DataTag" },
		{ name: "QueryClient" },
		{ name: "InvalidateOptions" }
	],
	dependency: "@tanstack/solid-query"
}];
const ANGULAR_QUERY_DEPENDENCIES = [{
	exports: [
		{
			name: "injectQuery",
			values: true
		},
		{
			name: "injectInfiniteQuery",
			values: true
		},
		{
			name: "injectMutation",
			values: true
		},
		{ name: "InjectQueryOptions" },
		{ name: "InjectMutationOptions" },
		{ name: "CreateQueryOptions" },
		{ name: "CreateInfiniteQueryOptions" },
		{ name: "CreateMutationOptions" },
		{ name: "QueryFunction" },
		{ name: "MutationFunction" },
		{ name: "QueryKey" },
		{ name: "CreateQueryResult" },
		{ name: "CreateInfiniteQueryResult" },
		{ name: "InfiniteData" },
		{ name: "CreateMutationResult" },
		{ name: "DataTag" },
		{
			name: "QueryClient",
			values: true
		},
		{ name: "InvalidateOptions" },
		{ name: "MutationFunctionContext" }
	],
	dependency: "@tanstack/angular-query-experimental"
}, {
	exports: [
		{
			name: "inject",
			values: true
		},
		{ name: "Signal" },
		{
			name: "computed",
			values: true
		}
	],
	dependency: "@angular/core"
}];
const isVueQueryV3 = (packageJson) => {
	const hasVueQuery = packageJson?.dependencies?.["vue-query"] ?? packageJson?.devDependencies?.["vue-query"] ?? packageJson?.peerDependencies?.["vue-query"];
	const hasVueQueryV4 = packageJson?.dependencies?.["@tanstack/vue-query"] ?? packageJson?.devDependencies?.["@tanstack/vue-query"] ?? packageJson?.peerDependencies?.["@tanstack/vue-query"];
	return !!hasVueQuery && !hasVueQueryV4;
};
const getVueQueryDependencies = (hasGlobalMutator, hasParamsSerializerOptions, packageJson, httpClient) => {
	const hasVueQueryV3 = isVueQueryV3(packageJson);
	return [
		...!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS ? AXIOS_DEPENDENCIES : [],
		...hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : [],
		...hasVueQueryV3 ? VUE_QUERY_DEPENDENCIES_V3 : VUE_QUERY_DEPENDENCIES
	];
};
const getSolidQueryDependencies = (hasGlobalMutator, hasParamsSerializerOptions, packageJson, httpClient) => {
	return [
		...!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS ? AXIOS_DEPENDENCIES : [],
		...hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : [],
		...SOLID_QUERY_DEPENDENCIES
	];
};
const getAngularQueryDependencies = (hasGlobalMutator, hasParamsSerializerOptions, packageJson, httpClient) => {
	const useAngularHttp = httpClient === OutputHttpClient.ANGULAR;
	const useAxios = !hasGlobalMutator && httpClient === OutputHttpClient.AXIOS;
	return [
		...useAngularHttp ? ANGULAR_HTTP_DEPENDENCIES : [],
		...useAxios ? AXIOS_DEPENDENCIES : [],
		...hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : [],
		...ANGULAR_QUERY_DEPENDENCIES
	];
};
const isQueryV5 = (packageJson, queryClient) => {
	if (queryClient === "angular-query") return true;
	const version = getPackageByQueryClient(packageJson, queryClient);
	if (!version) return false;
	const withoutRc = version.split("-")[0];
	return compareVersions(withoutRc, "5.0.0");
};
const isQueryV6 = (packageJson, queryClient) => {
	const version = getPackageByQueryClient(packageJson, queryClient);
	if (!version) return false;
	const withoutRc = version.split("-")[0];
	return compareVersions(withoutRc, "6.0.0");
};
const isQueryV5WithDataTagError = (packageJson, queryClient) => {
	if (queryClient === "angular-query") return true;
	const version = getPackageByQueryClient(packageJson, queryClient);
	if (!version) return false;
	const withoutRc = version.split("-")[0];
	return compareVersions(withoutRc, "5.62.0");
};
const isQueryV5WithInfiniteQueryOptionsError = (packageJson, queryClient) => {
	if (queryClient === "angular-query") return true;
	const version = getPackageByQueryClient(packageJson, queryClient);
	if (!version) return false;
	const withoutRc = version.split("-")[0];
	return compareVersions(withoutRc, "5.80.0");
};
const getPackageByQueryClient = (packageJson, queryClient) => {
	switch (queryClient) {
		case "react-query": return packageJson?.dependencies?.["@tanstack/react-query"] ?? packageJson?.devDependencies?.["@tanstack/react-query"] ?? packageJson?.peerDependencies?.["@tanstack/react-query"];
		case "svelte-query": return packageJson?.dependencies?.["@tanstack/svelte-query"] ?? packageJson?.devDependencies?.["@tanstack/svelte-query"] ?? packageJson?.peerDependencies?.["@tanstack/svelte-query"];
		case "vue-query": return packageJson?.dependencies?.["@tanstack/vue-query"] ?? packageJson?.devDependencies?.["@tanstack/vue-query"] ?? packageJson?.peerDependencies?.["@tanstack/vue-query"];
		case "angular-query": return packageJson?.dependencies?.["@tanstack/angular-query-experimental"] ?? packageJson?.devDependencies?.["@tanstack/angular-query-experimental"] ?? packageJson?.peerDependencies?.["@tanstack/angular-query-experimental"];
		case "solid-query": return packageJson?.dependencies?.["@tanstack/solid-query"] ?? packageJson?.devDependencies?.["@tanstack/solid-query"] ?? packageJson?.peerDependencies?.["@tanstack/solid-query"];
	}
};

//#endregion
//#region src/query-options.ts
const QueryType = {
	INFINITE: "infiniteQuery",
	QUERY: "query",
	SUSPENSE_QUERY: "suspenseQuery",
	SUSPENSE_INFINITE: "suspenseInfiniteQuery"
};
const INFINITE_QUERY_PROPERTIES = new Set(["getNextPageParam", "getPreviousPageParam"]);
const generateQueryOptions = ({ params, options, type, outputClient }) => {
	if (options === false) return "";
	const queryConfig = isObject(options) ? ` ${stringify(omitBy(options, (_, key) => type !== QueryType.INFINITE && type !== QueryType.SUSPENSE_INFINITE && INFINITE_QUERY_PROPERTIES.has(key)))?.slice(1, -1)}` : "";
	if (params.length === 0 || isSuspenseQuery(type)) {
		if (options) return `${queryConfig} ...queryOptions`;
		return "...queryOptions";
	}
	return `${!isObject(options) || !Object.hasOwn(options, "enabled") ? isVue(outputClient) ? `enabled: computed(() => !!(${params.map(({ name }) => `unref(${name})`).join(" && ")})),` : `enabled: !!(${params.map(({ name }) => name).join(" && ")}),` : ""}${queryConfig} ...queryOptions`;
};
const isSuspenseQuery = (type) => {
	return [QueryType.SUSPENSE_INFINITE, QueryType.SUSPENSE_QUERY].includes(type);
};
const getQueryOptionsDefinition = ({ operationName, mutator, definitions, type, hasSvelteQueryV4, hasQueryV5, hasQueryV5WithInfiniteQueryOptionsError, queryParams, queryParam, isReturnType, initialData, isAngularClient }) => {
	const isMutatorHook = mutator?.isHook;
	const prefix = !hasSvelteQueryV4 && !isAngularClient ? "Use" : "Create";
	const partialOptions = !isReturnType && hasQueryV5;
	if (type) {
		const funcReturnType = `Awaited<ReturnType<${isMutatorHook ? `ReturnType<typeof use${pascal(operationName)}Hook>` : `typeof ${operationName}`}>>`;
		const optionTypeInitialDataPostfix = initialData && !isSuspenseQuery(type) ? ` & Pick<
        ${pascal(initialData)}InitialDataOptions<
          ${funcReturnType},
          TError,
          ${funcReturnType}${hasQueryV5 && (type === QueryType.INFINITE || type === QueryType.SUSPENSE_INFINITE) && queryParam && queryParams ? `, QueryKey` : ""}
        > , 'initialData'
      >` : "";
		const optionType = `${prefix}${pascal(type)}Options<${funcReturnType}, TError, TData${hasQueryV5 && (type === QueryType.INFINITE || type === QueryType.SUSPENSE_INFINITE) && queryParam && queryParams ? hasQueryV5WithInfiniteQueryOptionsError ? `, QueryKey, ${queryParams.schema.name}['${queryParam}']` : `, ${funcReturnType}, QueryKey, ${queryParams.schema.name}['${queryParam}']` : ""}>`;
		return `${partialOptions ? "Partial<" : ""}${optionType}${partialOptions ? ">" : ""}${optionTypeInitialDataPostfix}`;
	}
	return `${prefix}MutationOptions<Awaited<ReturnType<${isMutatorHook ? `ReturnType<typeof use${pascal(operationName)}Hook>` : `typeof ${operationName}`}>>, TError,${definitions ? `{${definitions}}` : "void"}, TContext>`;
};
const generateQueryArguments = ({ operationName, definitions, mutator, isRequestOptions, type, hasSvelteQueryV4, hasSvelteQueryV6, hasQueryV5, hasQueryV5WithInfiniteQueryOptionsError, queryParams, queryParam, initialData, httpClient, isAngularClient, forQueryOptions = false, forAngularInject = false }) => {
	const definition = getQueryOptionsDefinition({
		operationName,
		mutator,
		definitions,
		type,
		hasSvelteQueryV4,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		queryParams,
		queryParam,
		isReturnType: false,
		initialData,
		isAngularClient
	});
	if (!isRequestOptions) return `${type ? "queryOptions" : "mutationOptions"}${initialData === "defined" ? "" : "?"}: ${definition}`;
	const requestType = getQueryArgumentsRequestType(httpClient, mutator);
	const isQueryRequired = initialData === "defined";
	const optionsType = `{ ${type ? "query" : "mutation"}${isQueryRequired ? "" : "?"}:${definition}, ${requestType}}`;
	if (forAngularInject) return `options${isQueryRequired ? "" : "?"}: ${optionsType} | (() => ${optionsType})\n`;
	return `options${isQueryRequired ? "" : "?"}: ${hasSvelteQueryV6 && !forQueryOptions ? "() => " : ""}${optionsType}\n`;
};

//#endregion
//#region src/return-types.ts
const generateQueryReturnType = ({ outputClient, type, isMutatorHook, operationName, hasVueQueryV4, hasSvelteQueryV4, hasQueryV5, hasQueryV5WithDataTagError, isInitialDataDefined }) => {
	switch (outputClient) {
		case OutputClient.ANGULAR_QUERY:
			if (type !== QueryType.INFINITE && type !== QueryType.SUSPENSE_INFINITE) return `CreateQueryResult<TData, TError>`;
			return `CreateInfiniteQueryResult<TData, TError>`;
		case OutputClient.SOLID_QUERY:
			if (type !== QueryType.INFINITE && type !== QueryType.SUSPENSE_INFINITE) return `CreateQueryResult<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"} }`;
			return `CreateInfiniteQueryResult<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"} }`;
		case OutputClient.SVELTE_QUERY:
			if (!hasSvelteQueryV4) return `Use${pascal(type)}StoreResult<Awaited<ReturnType<${isMutatorHook ? `ReturnType<typeof use${pascal(operationName)}Hook>` : `typeof ${operationName}`}>>, TError, TData, QueryKey> & { queryKey: QueryKey }`;
			return `Create${pascal(type)}Result<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"} }`;
		case OutputClient.VUE_QUERY:
			if (!hasVueQueryV4) return ` UseQueryReturnType<TData, TError, Use${pascal(type)}Result<TData, TError>> & { queryKey: QueryKey }`;
			if (type !== QueryType.INFINITE && type !== QueryType.SUSPENSE_INFINITE) return `UseQueryReturnType<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"} }`;
			return `UseInfiniteQueryReturnType<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"} }`;
		default: return ` ${isInitialDataDefined && !isSuspenseQuery(type) ? "Defined" : ""}Use${pascal(type)}Result<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"} }`;
	}
};
const generateMutatorReturnType = ({ outputClient, dataType, variableType }) => {
	if (outputClient === OutputClient.ANGULAR_QUERY) return `: CreateMutationResult<
        Awaited<ReturnType<${dataType}>>,
        TError,
        ${variableType},
        TContext
      >`;
	if (outputClient === OutputClient.REACT_QUERY) return `: UseMutationResult<
        Awaited<ReturnType<${dataType}>>,
        TError,
        ${variableType},
        TContext
      >`;
	if (outputClient === OutputClient.SOLID_QUERY) return `: CreateMutationResult<
        Awaited<ReturnType<${dataType}>>,
        TError,
        ${variableType},
        TContext
      >`;
	if (outputClient === OutputClient.SVELTE_QUERY) return `: CreateMutationResult<
        Awaited<ReturnType<${dataType}>>,
        TError,
        ${variableType},
        TContext
      >`;
	if (outputClient === OutputClient.VUE_QUERY) return `: UseMutationReturnType<
        Awaited<ReturnType<${dataType}>>,
        TError,
        ${variableType},
        TContext
      >`;
	return "";
};
const getQueryFnArguments = ({ hasQueryParam, hasSignal, hasSignalParam = false }) => {
	if (!hasQueryParam && !hasSignal) return "";
	const signalDestructure = hasSignalParam ? "signal: querySignal" : "signal";
	if (hasQueryParam) {
		if (hasSignal) return `{ ${signalDestructure}, pageParam }`;
		return "{ pageParam }";
	}
	return `{ ${signalDestructure} }`;
};
const getQueryReturnStatement = ({ outputClient, hasSvelteQueryV4, hasSvelteQueryV6, hasQueryV5, hasQueryV5WithDataTagError, queryResultVarName, queryOptionsVarName }) => {
	if (isAngular(outputClient)) return `return ${queryResultVarName};`;
	if (isVue(outputClient)) return `${queryResultVarName}.queryKey = unref(${queryOptionsVarName}).queryKey as ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"};

  return ${queryResultVarName};`;
	if (hasSvelteQueryV6) return `return ${queryResultVarName}`;
	if (hasSvelteQueryV4) return `${queryResultVarName}.queryKey = ${queryOptionsVarName}.queryKey;

  return ${queryResultVarName};`;
	return `return { ...${queryResultVarName}, queryKey: ${queryOptionsVarName}.queryKey };`;
};

//#endregion
//#region src/mutation-generator.ts
const normalizeTarget = (target) => typeof target === "string" ? { query: target } : target;
const serializeTarget = (target) => JSON.stringify({
	query: target.query,
	params: target.params ?? []
});
const generateVariableRef = (varName) => {
	const parts = varName.split(".");
	if (parts.length === 1) return `variables.${varName}`;
	return `variables.${parts[0]}?.${parts.slice(1).join("?.")}`;
};
const generateParamArgs = (params) => {
	if (Array.isArray(params)) return params.map((v) => generateVariableRef(v)).join(", ");
	return Object.values(params).map((v) => generateVariableRef(v)).join(", ");
};
const generateInvalidateCall = (target) => {
	return `    queryClient.invalidateQueries({ queryKey: ${camel(`get-${target.query}-query-key`)}(${target.params ? generateParamArgs(target.params) : ""}) });`;
};
const generateMutationHook = async ({ verbOptions, options, outputClient, hasQueryV5, hasQueryV5WithInfiniteQueryOptionsError, hasSvelteQueryV4, hasSvelteQueryV6, isRequestOptions, httpClient, doc, isAngularHttp }) => {
	const { operationName, body, props, mutator, response, operationId, override } = verbOptions;
	const { route, context, output } = options;
	const query = override.query;
	const mutationOptionsMutator = query.mutationOptions ? await generateMutator({
		output,
		mutator: query.mutationOptions,
		name: `${operationName}MutationOptions`,
		workspace: context.workspace,
		tsconfig: context.output.tsconfig
	}) : void 0;
	const definitions = props.map(({ definition, type }) => type === GetterPropType.BODY ? mutator?.bodyTypeName ? `data: ${mutator.bodyTypeName}<${body.definition}>` : `data: ${body.definition}` : definition).join(";");
	const properties = props.map(({ name, type }) => type === GetterPropType.BODY ? "data" : name).join(",");
	const errorType = getQueryErrorType(operationName, response, httpClient, mutator);
	const dataType = mutator?.isHook ? `ReturnType<typeof use${pascal(operationName)}Hook>` : `typeof ${operationName}`;
	const isAngularClient = isAngular(outputClient);
	const mutationOptionFnReturnType = getQueryOptionsDefinition({
		operationName,
		mutator,
		definitions,
		hasSvelteQueryV4,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		isReturnType: true,
		isAngularClient
	});
	const mutationArguments = generateQueryArguments({
		operationName,
		definitions,
		mutator,
		isRequestOptions,
		hasSvelteQueryV4,
		hasSvelteQueryV6,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		httpClient,
		isAngularClient
	});
	const mutationArgumentsForOptions = generateQueryArguments({
		operationName,
		definitions,
		mutator,
		isRequestOptions,
		hasSvelteQueryV4,
		hasSvelteQueryV6,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		httpClient,
		isAngularClient,
		forQueryOptions: true
	});
	const mutationOptionsFnName = camel(mutationOptionsMutator || mutator?.isHook ? `use-${operationName}-mutationOptions` : `get-${operationName}-mutationOptions`);
	const hooksOptionImplementation = getHooksOptionImplementation(isRequestOptions, httpClient, camel(operationName), mutator);
	const invalidatesConfig = (query.mutationInvalidates ?? []).filter((rule) => rule.onMutations.includes(operationName)).flatMap((rule) => rule.invalidates).map((t) => normalizeTarget(t));
	const seenTargets = /* @__PURE__ */ new Set();
	const uniqueInvalidates = invalidatesConfig.filter((target) => {
		const key = serializeTarget(target);
		if (seenTargets.has(key)) return false;
		seenTargets.add(key);
		return true;
	});
	const hasInvalidation = uniqueInvalidates.length > 0 && (isAngularClient || isReact(outputClient) || isSvelte(outputClient));
	const mutationOptionsFn = `export const ${mutationOptionsFnName} = <TError = ${errorType},
    TContext = unknown>(${isAngularHttp && (!mutator || mutator.hasSecondArg) ? "http: HttpClient, " : ""}${hasInvalidation ? "queryClient: QueryClient, " : ""}${mutationArgumentsForOptions}): ${mutationOptionFnReturnType} => {

${hooksOptionImplementation}

      ${mutator?.isHook ? `const ${operationName} =  use${pascal(operationName)}Hook()` : ""}


      const mutationFn: MutationFunction<Awaited<ReturnType<${dataType}>>, ${definitions ? `{${definitions}}` : "void"}> = (${properties ? "props" : ""}) => {
          ${properties ? `const {${properties}} = props ?? {};` : ""}

          return  ${operationName}(${isAngularHttp && !mutator ? "http, " : ""}${properties}${properties ? "," : ""}${getMutationRequestArgs(isRequestOptions, httpClient, mutator)})
        }

${hasInvalidation ? isAngular(outputClient) ? `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : "void"}, onMutateResult: TContext, context: MutationFunctionContext) => {
${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join("\n")}
    mutationOptions?.onSuccess?.(data, variables, onMutateResult, context);
  };` : isReact(outputClient) ? `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : "void"}, context: TContext) => {
${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join("\n")}
    mutationOptions?.onSuccess?.(data, variables, context);
  };` : isSvelte(outputClient) ? hasSvelteQueryV6 ? `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : "void"}, onMutateResult: TContext, context: MutationFunctionContext) => {
${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join("\n")}
    mutationOptions?.onSuccess?.(data, variables, onMutateResult, context);
  };` : `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : "void"}, context: TContext | undefined) => {
${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join("\n")}
    mutationOptions?.onSuccess?.(data, variables, context);
  };` : "" : ""}

        ${mutationOptionsMutator ? `const customOptions = ${mutationOptionsMutator.name}({...mutationOptions, mutationFn}${mutationOptionsMutator.hasSecondArg ? `, { url: \`${route.replaceAll("/${", "/{")}\` }` : ""}${mutationOptionsMutator.hasThirdArg ? `, { operationId: '${operationId}', operationName: '${operationName}' }` : ""});` : ""}


  return  ${mutationOptionsMutator ? "customOptions" : hasInvalidation ? "{ mutationFn, onSuccess, ...mutationOptions }" : "{ mutationFn, ...mutationOptions }"}}`;
	const operationPrefix = getFrameworkPrefix(hasSvelteQueryV4, isAngular(outputClient), isSolid(outputClient));
	const optionalQueryClientArgument = hasSvelteQueryV6 ? ", queryClient?: () => QueryClient" : (hasQueryV5 || isSvelte(outputClient) && hasInvalidation) && !isAngular(outputClient) ? ", queryClient?: QueryClient" : "";
	const mutationImplementation = `${mutationOptionsFnName}(${hasInvalidation ? hasSvelteQueryV6 ? "backupQueryClient, " : `queryClient${isReact(outputClient) || isSvelte(outputClient) ? " ?? backupQueryClient" : ""}, ` : ""}${isRequestOptions ? "options" : "mutationOptions"}${hasSvelteQueryV6 ? "?.()" : ""})`;
	const mutationOptionsVarName = camel(`${operationName}-mutation-options`);
	return {
		implementation: `
${mutationOptionsFn}

    export type ${pascal(operationName)}MutationResult = NonNullable<Awaited<ReturnType<${dataType}>>>
    ${body.definition ? `export type ${pascal(operationName)}MutationBody = ${mutator?.bodyTypeName ? `${mutator.bodyTypeName}<${body.definition}>` : body.definition}` : ""}
    export type ${pascal(operationName)}MutationError = ${errorType}

    ${doc}export const ${camel(`${operationPrefix}-${operationName}`)} = <TError = ${errorType},
    TContext = unknown>(${mutationArguments} ${optionalQueryClientArgument})${generateMutatorReturnType({
			outputClient,
			dataType,
			variableType: definitions ? `{${definitions}}` : "void"
		})} => {
${isAngular(outputClient) ? isAngularHttp && (!mutator || mutator.hasSecondArg) ? `      const http = inject(HttpClient);${hasInvalidation ? "\n      const queryClient = inject(QueryClient);" : ""}
      const ${mutationOptionsVarName} = ${mutationOptionsFnName}(http${hasInvalidation ? ", queryClient" : ""}${isRequestOptions ? ", options" : ", mutationOptions"});

      return ${operationPrefix}Mutation(() => ${mutationOptionsVarName});` : `      const ${mutationOptionsVarName} = ${mutationImplementation};

      return ${operationPrefix}Mutation(() => ${mutationOptionsVarName});` : `      ${(isReact(outputClient) || isSvelte(outputClient)) && hasInvalidation ? `const backupQueryClient = useQueryClient(${hasSvelteQueryV6 && optionalQueryClientArgument ? "queryClient?.()" : ""});\n      ` : ""}return ${operationPrefix}Mutation(${hasSvelteQueryV6 ? `() => ({ ...${mutationImplementation} })${optionalQueryClientArgument ? `, queryClient` : ""}` : isSvelte(outputClient) ? mutationImplementation : `${mutationImplementation}${optionalQueryClientArgument ? `, queryClient` : ""}`});`}
    }
    `,
		mutators: mutationOptionsMutator ? [mutationOptionsMutator] : void 0
	};
};

//#endregion
//#region src/query-generator.ts
/**
* Get framework-aware prefix for hook names and type definitions
* @param hasSvelteQueryV4 - Whether using Svelte Query v4
* @param isAngularClient - Whether using Angular client
* @param isSolidClient - Whether using Solid Query client
* @param capitalize - Whether to capitalize the prefix (for type definitions)
* @returns The appropriate prefix string
*/
const getFrameworkPrefix = (hasSvelteQueryV4, isAngularClient, isSolidClient, capitalize = false) => {
	let prefix;
	if (hasSvelteQueryV4 || isSolidClient) prefix = "create";
	else if (isAngularClient) prefix = "inject";
	else prefix = "use";
	return capitalize ? prefix.charAt(0).toUpperCase() + prefix.slice(1) : prefix;
};
const generatePrefetch = ({ usePrefetch, type, useQuery, useInfinite, operationName, mutator, doc, queryProps, dataType, errorType, queryArguments, queryOptionsVarName, queryOptionsFnName, queryProperties, isRequestOptions }) => {
	if (!(usePrefetch && (type === QueryType.QUERY || type === QueryType.INFINITE || type === QueryType.SUSPENSE_QUERY && !useQuery || type === QueryType.SUSPENSE_INFINITE && !useInfinite))) return "";
	const prefetchType = type === QueryType.QUERY || type === QueryType.SUSPENSE_QUERY ? "query" : "infinite-query";
	const prefetchFnName = camel(`prefetch-${prefetchType}`);
	if (mutator?.isHook) return `${doc}export const ${camel(`use-prefetch-${operationName}-${prefetchType}`)} = <TData = Awaited<ReturnType<${dataType}>>, TError = ${errorType}>(${queryProps} ${queryArguments}) => {
  const queryClient = useQueryClient();
  const ${queryOptionsVarName} = ${queryOptionsFnName}(${queryProperties}${queryProperties ? "," : ""}${isRequestOptions ? "options" : "queryOptions"})
  return useCallback(async (): Promise<QueryClient> => {
    await queryClient.${prefetchFnName}(${queryOptionsVarName})
    return queryClient;
  },[queryClient, ${queryOptionsVarName}]);
};\n`;
	else return `${doc}export const ${camel(`prefetch-${operationName}-${prefetchType}`)} = async <TData = Awaited<ReturnType<${dataType}>>, TError = ${errorType}>(\n queryClient: QueryClient, ${queryProps} ${queryArguments}\n  ): Promise<QueryClient> => {

  const ${queryOptionsVarName} = ${queryOptionsFnName}(${queryProperties}${queryProperties ? "," : ""}${isRequestOptions ? "options" : "queryOptions"})

  await queryClient.${prefetchFnName}(${queryOptionsVarName});

  return queryClient;
}\n`;
};
const generateQueryImplementation = ({ queryOption: { name, queryParam, options, type, queryKeyFnName }, operationName, queryProperties, queryKeyProperties, queryParams, params, props, mutator, queryOptionsMutator, queryKeyMutator, isRequestOptions, response, outputClient, httpClient, isExactOptionalPropertyTypes, hasSignal, route, hasVueQueryV4, hasSvelteQueryV4, hasSvelteQueryV6, hasQueryV5, hasQueryV5WithDataTagError, hasQueryV5WithInfiniteQueryOptionsError, doc, usePrefetch, useQuery, useInfinite, useInvalidate }) => {
	const hasSignalParam = props.some((prop) => prop.name === "signal");
	const queryPropDefinitions = toObjectString(props, "definition");
	const definedInitialDataQueryPropsDefinitions = toObjectString(props.map((prop) => {
		const regex = new RegExp(String.raw`^${prop.name}\s*\?:`);
		if (!regex.test(prop.definition)) return prop;
		const definitionWithUndefined = prop.definition.replace(regex, `${prop.name}: undefined | `);
		return {
			...prop,
			definition: definitionWithUndefined
		};
	}), "definition");
	const queryProps = toObjectString(props, "implementation");
	const angularQueryPropsDefinitions = toObjectString(props.map((prop) => {
		const getterType = prop.definition.replace(/^(\w+)(\??): (.+)$/, (_match, name$1, optional, type$1) => `${name$1}${optional}: ${type$1} | (() => ${type$1.replace(" | undefined", "")}${optional ? " | undefined" : ""})`);
		return {
			...prop,
			definition: getterType
		};
	}), "definition");
	const hasInfiniteQueryParam = queryParam && queryParams?.schema.name;
	const isAngularHttp = isAngular(outputClient) || httpClient === OutputHttpClient.ANGULAR;
	let httpFunctionProps = queryParam ? props.map((param) => {
		if (param.type === GetterPropType.NAMED_PATH_PARAMS && !isVue(outputClient)) return param.destructured;
		return param.name === "params" ? `{...${isVue(outputClient) ? `unref(params)` : "params"}, '${queryParam}': pageParam || ${isVue(outputClient) ? `unref(params)?.['${queryParam}']` : `params?.['${queryParam}']`}}` : param.name;
	}).join(",") : getHttpFunctionQueryProps(isVue(outputClient), httpClient, queryProperties, isAngularHttp, !!mutator);
	if (queryParam && isAngularHttp && !mutator) httpFunctionProps = httpFunctionProps ? `http, ${httpFunctionProps}` : "http";
	const definedInitialDataReturnType = generateQueryReturnType({
		outputClient,
		type,
		isMutatorHook: mutator?.isHook,
		operationName,
		hasVueQueryV4,
		hasSvelteQueryV4,
		hasQueryV5,
		hasQueryV5WithDataTagError,
		isInitialDataDefined: true
	});
	const returnType = generateQueryReturnType({
		outputClient,
		type,
		isMutatorHook: mutator?.isHook,
		operationName,
		hasVueQueryV4,
		hasSvelteQueryV4,
		hasQueryV5,
		hasQueryV5WithDataTagError
	});
	const errorType = getQueryErrorType(operationName, response, httpClient, mutator);
	const dataType = mutator?.isHook ? `ReturnType<typeof use${pascal(operationName)}Hook>` : `typeof ${operationName}`;
	const definedInitialDataQueryArguments = generateQueryArguments({
		operationName,
		mutator,
		definitions: "",
		isRequestOptions,
		type,
		hasSvelteQueryV4,
		hasSvelteQueryV6,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		queryParams,
		queryParam,
		initialData: "defined",
		httpClient,
		isAngularClient: isAngular(outputClient)
	});
	const undefinedInitialDataQueryArguments = generateQueryArguments({
		operationName,
		definitions: "",
		mutator,
		isRequestOptions,
		type,
		hasSvelteQueryV4,
		hasSvelteQueryV6,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		queryParams,
		queryParam,
		initialData: "undefined",
		httpClient,
		isAngularClient: isAngular(outputClient)
	});
	const queryArguments = generateQueryArguments({
		operationName,
		definitions: "",
		mutator,
		isRequestOptions,
		type,
		hasSvelteQueryV4,
		hasSvelteQueryV6,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		queryParams,
		queryParam,
		httpClient,
		isAngularClient: isAngular(outputClient),
		forAngularInject: isAngular(outputClient)
	});
	const queryArgumentsForOptions = generateQueryArguments({
		operationName,
		definitions: "",
		mutator,
		isRequestOptions,
		type,
		hasSvelteQueryV4,
		hasSvelteQueryV6,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		queryParams,
		queryParam,
		httpClient,
		isAngularClient: isAngular(outputClient),
		forQueryOptions: true
	});
	const queryOptions = getQueryOptions({
		isRequestOptions,
		isExactOptionalPropertyTypes,
		mutator,
		hasSignal,
		httpClient,
		hasSignalParam
	});
	const hookOptions = getHookOptions({
		isRequestOptions,
		httpClient,
		mutator
	});
	const queryFnArguments = getQueryFnArguments({
		hasQueryParam: !!queryParam && props.some(({ type: type$1 }) => type$1 === "queryParam"),
		hasSignal,
		hasSignalParam
	});
	const queryOptionFnReturnType = getQueryOptionsDefinition({
		operationName,
		mutator,
		definitions: "",
		type,
		hasSvelteQueryV4,
		hasQueryV5,
		hasQueryV5WithInfiniteQueryOptionsError,
		queryParams,
		queryParam,
		isReturnType: true,
		isAngularClient: isAngular(outputClient)
	});
	const queryOptionsImp = generateQueryOptions({
		params,
		options,
		type,
		outputClient
	});
	const queryOptionsFnName = camel(queryKeyMutator || queryOptionsMutator || mutator?.isHook ? `use-${name}-queryOptions` : `get-${name}-queryOptions`);
	const queryOptionsVarName = isRequestOptions ? "queryOptions" : "options";
	const queryResultVarName = props.some((prop) => prop.name === "query") ? "_query" : "query";
	const infiniteParam = queryParams && queryParam ? `, ${queryParams.schema.name}['${queryParam}']` : "";
	const TData = hasQueryV5 && (type === QueryType.INFINITE || type === QueryType.SUSPENSE_INFINITE) ? `InfiniteData<Awaited<ReturnType<${dataType}>>${infiniteParam}>` : `Awaited<ReturnType<${dataType}>>`;
	const queryOptionsFn = `export const ${queryOptionsFnName} = <TData = ${TData}, TError = ${errorType}>(${isAngularHttp && (!mutator || mutator.hasSecondArg) ? "http: HttpClient, " : ""}${queryProps} ${queryArgumentsForOptions}) => {

${hookOptions}

  const queryKey =  ${queryKeyMutator ? `${queryKeyMutator.name}({ ${queryProperties} }${queryKeyMutator.hasSecondArg ? `, { url: \`${route}\`, queryOptions }` : ""});` : `${hasVueQueryV4 ? "" : "queryOptions?.queryKey ?? "}${queryKeyFnName}(${queryKeyProperties});`}

  ${mutator?.isHook ? `const ${operationName} =  use${pascal(operationName)}Hook();` : ""}

    const queryFn: QueryFunction<Awaited<ReturnType<${mutator?.isHook ? `ReturnType<typeof use${pascal(operationName)}Hook>` : `typeof ${operationName}`}>>${hasQueryV5 && hasInfiniteQueryParam ? `, QueryKey, ${queryParams.schema.name}['${queryParam}']` : ""}> = (${queryFnArguments}) => ${operationName}(${httpFunctionProps}${httpFunctionProps ? ", " : ""}${queryOptions});

      ${isVue(outputClient) ? vueUnRefParams(props.filter((prop) => prop.type === GetterPropType.NAMED_PATH_PARAMS)) : ""}

      ${queryOptionsMutator ? `const customOptions = ${queryOptionsMutator.name}({...queryOptions, queryKey, queryFn}${queryOptionsMutator.hasSecondArg ? `, { ${queryProperties} }` : ""}${queryOptionsMutator.hasThirdArg ? `, { url: \`${route}\` }` : ""});` : ""}

   return  ${queryOptionsMutator ? "customOptions" : `{ queryKey, queryFn, ${queryOptionsImp}}`} as ${queryOptionFnReturnType} ${isVue(outputClient) || isAngular(outputClient) ? "" : `& { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ", TError" : ""}>` : "QueryKey"} }`}
}`;
	const operationPrefix = getFrameworkPrefix(hasSvelteQueryV4, isAngular(outputClient), isSolid(outputClient));
	const optionalQueryClientArgument = hasSvelteQueryV6 ? `, queryClient?: () => QueryClient` : hasQueryV5 && !isAngular(outputClient) ? ", queryClient?: QueryClient" : "";
	const queryHookName = camel(`${operationPrefix}-${name}`);
	const overrideTypes = `
export function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\n ${definedInitialDataQueryPropsDefinitions} ${definedInitialDataQueryArguments} ${optionalQueryClientArgument}\n  ): ${definedInitialDataReturnType}
export function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\n ${queryPropDefinitions} ${undefinedInitialDataQueryArguments} ${optionalQueryClientArgument}\n  ): ${returnType}
export function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\n ${queryPropDefinitions} ${queryArguments} ${optionalQueryClientArgument}\n  ): ${returnType}`;
	const prefetch = generatePrefetch({
		usePrefetch,
		type,
		useQuery,
		useInfinite,
		operationName,
		mutator,
		queryProps,
		dataType,
		errorType,
		queryArguments: queryArgumentsForOptions,
		queryOptionsVarName,
		queryOptionsFnName,
		queryProperties,
		isRequestOptions,
		doc
	});
	const shouldGenerateInvalidate = useInvalidate && (type === QueryType.QUERY || type === QueryType.INFINITE || type === QueryType.SUSPENSE_QUERY && !useQuery || type === QueryType.SUSPENSE_INFINITE && !useInfinite);
	const invalidateFnName = camel(`invalidate-${name}`);
	return `
${queryOptionsFn}

export type ${pascal(name)}QueryResult = NonNullable<Awaited<ReturnType<${dataType}>>>
export type ${pascal(name)}QueryError = ${errorType}

${hasQueryV5 && OutputClient.REACT_QUERY === outputClient ? overrideTypes : ""}
${doc}
export function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\n ${hasSvelteQueryV6 ? toObjectString(props.map((p) => ({
		...p,
		definition: p.definition.replace(":", ": () => ")
	})), "definition") : isAngular(outputClient) ? angularQueryPropsDefinitions : queryProps} ${queryArguments} ${optionalQueryClientArgument} \n ): ${returnType} {

  ${hasSvelteQueryV6 ? "" : isAngular(outputClient) && (!mutator || mutator.hasSecondArg) ? `const http = inject(HttpClient);` : isAngular(outputClient) ? "" : `const ${queryOptionsVarName} = ${queryOptionsFnName}(${queryProperties}${queryProperties ? "," : ""}${isRequestOptions ? "options" : "queryOptions"})`}

  const ${queryResultVarName} = ${camel(`${operationPrefix}-${isAngular(outputClient) || hasSvelteQueryV4 ? getQueryTypeForFramework(type) : type}`)}(${isAngular(outputClient) ? `() => {${props.length > 0 ? `
    // Resolve params if getter function (for signal reactivity)
    ${props.map((p) => `const _${p.name} = typeof ${p.name} === 'function' ? ${p.name}() : ${p.name};`).join("\n    ")}` : ""}
    // Resolve options if getter function (for signal reactivity)
    const _options = typeof ${isRequestOptions ? "options" : "queryOptions"} === 'function' ? ${isRequestOptions ? "options" : "queryOptions"}() : ${isRequestOptions ? "options" : "queryOptions"};
    return ${queryOptionsFnName}(${!mutator || mutator.hasSecondArg ? "http" : ""}${props.length > 0 ? `${!mutator || mutator.hasSecondArg ? ", " : ""}${props.map((p) => `_${p.name}`).join(", ")}` : ""}, _options);
  }` : hasSvelteQueryV6 ? `() => ${queryOptionsFnName}(${toObjectString(props.map((p) => ({
		...p,
		name: p.default || !p.required ? `${p.name}?.()` : `${p.name}()`
	})), "name")}${isRequestOptions ? "options?.()" : "queryOptions?.()"})` : `${queryOptionsVarName}${!isAngular(outputClient) && optionalQueryClientArgument ? ", queryClient" : ""}`}${hasSvelteQueryV6 ? `, queryClient` : ""}) as ${returnType};

  ${getQueryReturnStatement({
		outputClient,
		hasSvelteQueryV4,
		hasSvelteQueryV6,
		hasQueryV5,
		hasQueryV5WithDataTagError,
		queryResultVarName,
		queryOptionsVarName
	})}
}\n
${prefetch}
${shouldGenerateInvalidate ? `${doc}export const ${invalidateFnName} = async (\n queryClient: QueryClient, ${queryProps} options?: InvalidateOptions\n  ): Promise<QueryClient> => {

  await queryClient.invalidateQueries({ queryKey: ${queryKeyFnName}(${queryKeyProperties}) }, options);

  return queryClient;
}\n` : ""}
`;
};
const generateQueryHook = async (verbOptions, options, outputClient) => {
	const { queryParams, operationName, body, props: _props, verb, params, override, mutator, response, operationId, summary, deprecated } = verbOptions;
	const { route, override: { operations }, context, output } = options;
	let props = _props;
	if (isVue(outputClient)) props = vueWrapTypeWithMaybeRef(_props);
	const query = override.query;
	const isRequestOptions = override.requestOptions !== false;
	const operationQueryOptions = operations[operationId]?.query;
	const isExactOptionalPropertyTypes = !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;
	const queryVersion = query.version;
	const hasVueQueryV4 = OutputClient.VUE_QUERY === outputClient && (!isVueQueryV3(context.output.packageJson) || queryVersion === 4);
	const hasSvelteQueryV4 = OutputClient.SVELTE_QUERY === outputClient && (!isSvelteQueryV3(context.output.packageJson) || queryVersion === 4);
	const hasSvelteQueryV6 = OutputClient.SVELTE_QUERY === outputClient && isSvelteQueryV6(context.output.packageJson);
	const hasQueryV5 = queryVersion === 5 || isQueryV5(context.output.packageJson, outputClient);
	const hasQueryV5WithDataTagError = queryVersion === 5 || isQueryV5WithDataTagError(context.output.packageJson, outputClient);
	const hasQueryV5WithInfiniteQueryOptionsError = queryVersion === 5 || isQueryV5WithInfiniteQueryOptionsError(context.output.packageJson, outputClient);
	const httpClient = context.output.httpClient;
	const isAngularHttp = isAngular(outputClient) || httpClient === OutputHttpClient.ANGULAR;
	const doc = jsDoc({
		summary,
		deprecated
	});
	let implementation = "";
	let mutators;
	const hasOperationQueryOption = [
		operationQueryOptions?.useQuery,
		operationQueryOptions?.useSuspenseQuery,
		operationQueryOptions?.useInfinite,
		operationQueryOptions?.useSuspenseInfiniteQuery
	].some(Boolean);
	let isQuery = Verbs.GET === verb && [
		override.query.useQuery,
		override.query.useSuspenseQuery,
		override.query.useInfinite,
		override.query.useSuspenseInfiniteQuery
	].some(Boolean) || hasOperationQueryOption;
	let isMutation = override.query.useMutation && verb !== Verbs.GET;
	if (operationQueryOptions?.useMutation !== void 0) isMutation = operationQueryOptions.useMutation;
	if (verb !== Verbs.GET && isQuery) isMutation = false;
	if (verb === Verbs.GET && isMutation) isQuery = false;
	if (isQuery) {
		const queryKeyMutator = query.queryKey ? await generateMutator({
			output,
			mutator: query.queryKey,
			name: `${operationName}QueryKey`,
			workspace: context.workspace,
			tsconfig: context.output.tsconfig
		}) : void 0;
		const queryOptionsMutator = query.queryOptions ? await generateMutator({
			output,
			mutator: query.queryOptions,
			name: `${operationName}QueryOptions`,
			workspace: context.workspace,
			tsconfig: context.output.tsconfig
		}) : void 0;
		const queryProperties = props.map((param) => {
			if (param.type === GetterPropType.NAMED_PATH_PARAMS && !isVue(outputClient)) return param.destructured;
			return param.type === GetterPropType.BODY ? body.implementation : param.name;
		}).join(",");
		const queryKeyProperties = props.filter((prop) => prop.type !== GetterPropType.HEADER).map((param) => {
			if (param.type === GetterPropType.NAMED_PATH_PARAMS && !isVue(outputClient)) return param.destructured;
			return param.type === GetterPropType.BODY ? body.implementation : param.name;
		}).join(",");
		const queries = [
			...query.useInfinite || operationQueryOptions?.useInfinite ? [{
				name: camel(`${operationName}-infinite`),
				options: query.options,
				type: QueryType.INFINITE,
				queryParam: query.useInfiniteQueryParam,
				queryKeyFnName: camel(`get-${operationName}-infinite-query-key`)
			}] : [],
			...query.useQuery || operationQueryOptions?.useQuery ? [{
				name: operationName,
				options: query.options,
				type: QueryType.QUERY,
				queryKeyFnName: camel(`get-${operationName}-query-key`)
			}] : [],
			...query.useSuspenseQuery || operationQueryOptions?.useSuspenseQuery ? [{
				name: camel(`${operationName}-suspense`),
				options: query.options,
				type: QueryType.SUSPENSE_QUERY,
				queryKeyFnName: camel(`get-${operationName}-query-key`)
			}] : [],
			...query.useSuspenseInfiniteQuery || operationQueryOptions?.useSuspenseInfiniteQuery ? [{
				name: camel(`${operationName}-suspense-infinite`),
				options: query.options,
				type: QueryType.SUSPENSE_INFINITE,
				queryParam: query.useInfiniteQueryParam,
				queryKeyFnName: camel(`get-${operationName}-infinite-query-key`)
			}] : []
		];
		const uniqueQueryOptionsByKeys = queries.filter((obj, index, self) => index === self.findIndex((t) => t.queryKeyFnName === obj.queryKeyFnName));
		implementation += `
${queryKeyMutator ? "" : uniqueQueryOptionsByKeys.reduce((acc, queryOption) => {
			const makeOptionalParam = (impl) => {
				if (impl.includes("=")) return impl;
				return impl.replace(/^(\w+):\s*/, "$1?: ");
			};
			const queryKeyProps = toObjectString(props.filter((prop) => prop.type !== GetterPropType.HEADER).map((prop) => ({
				...prop,
				implementation: prop.type === GetterPropType.PARAM || prop.type === GetterPropType.NAMED_PATH_PARAMS ? prop.implementation : makeOptionalParam(prop.implementation)
			})), "implementation");
			const routeString = isVue(outputClient) || override.query.shouldSplitQueryKey ? getRouteAsArray(route) : `\`${route}\``;
			const queryKeyIdentifier = override.query.useOperationIdAsQueryKey ? `"${operationName}"` : routeString;
			const queryKeyParams = props.filter((p) => override.query.useOperationIdAsQueryKey ? true : p.type === GetterPropType.QUERY_PARAM).toSorted((a) => a.required ? -1 : 1).map((p) => `...(${p.name} ? [${p.name}] : [])`).join(", ");
			return acc + `
${override.query.shouldExportQueryKey ? "export " : ""}const ${queryOption.queryKeyFnName} = (${queryKeyProps}) => {
    return [
    ${[
				queryOption.type === QueryType.INFINITE || queryOption.type === QueryType.SUSPENSE_INFINITE ? `'infinite'` : "",
				queryKeyIdentifier,
				queryKeyParams,
				body.implementation
			].filter((x) => !!x).join(", ")}
    ] as const;
    }
`;
		}, "")}`;
		implementation += `
    ${queries.reduce((acc, queryOption) => {
			return acc + generateQueryImplementation({
				queryOption,
				operationName,
				queryProperties,
				queryKeyProperties,
				params,
				props,
				mutator,
				isRequestOptions,
				queryParams,
				response,
				outputClient,
				httpClient,
				isExactOptionalPropertyTypes,
				hasSignal: getHasSignal({ overrideQuerySignal: override.query.signal }),
				queryOptionsMutator,
				queryKeyMutator,
				route,
				hasVueQueryV4,
				hasSvelteQueryV4,
				hasSvelteQueryV6,
				hasQueryV5,
				hasQueryV5WithDataTagError,
				hasQueryV5WithInfiniteQueryOptionsError,
				doc,
				usePrefetch: query.usePrefetch,
				useQuery: query.useQuery,
				useInfinite: query.useInfinite,
				useInvalidate: query.useInvalidate
			});
		}, "")}
`;
		mutators = queryOptionsMutator || queryKeyMutator ? [...queryOptionsMutator ? [queryOptionsMutator] : [], ...queryKeyMutator ? [queryKeyMutator] : []] : void 0;
	}
	if (isMutation) {
		const mutationResult = await generateMutationHook({
			verbOptions: {
				...verbOptions,
				props
			},
			options,
			outputClient,
			hasQueryV5,
			hasQueryV5WithInfiniteQueryOptionsError,
			hasSvelteQueryV4,
			hasSvelteQueryV6,
			isRequestOptions,
			httpClient,
			doc,
			isAngularHttp
		});
		implementation += mutationResult.implementation;
		mutators = mutationResult.mutators ? [...mutators ?? [], ...mutationResult.mutators] : mutators;
	}
	return {
		implementation,
		mutators
	};
};

//#endregion
//#region src/index.ts
const generateQueryHeader = (params) => {
	return `${params.hasAwaitedType ? "" : `type AwaitedInput<T> = PromiseLike<T> | T;\n
      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;\n\n`}
${params.isRequestOptions && params.isMutator ? `type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n` : ""}
${getQueryHeader(params)}
`;
};
const generateQuery = async (verbOptions, options, outputClient) => {
	const imports = generateVerbImports(verbOptions);
	const functionImplementation = generateQueryRequestFunction(verbOptions, options, isVue(outputClient));
	const { implementation: hookImplementation, mutators } = await generateQueryHook(verbOptions, options, outputClient);
	return {
		implementation: `${functionImplementation}\n\n${hookImplementation}`,
		imports,
		mutators
	};
};
const dependenciesBuilder = {
	"react-query": getReactQueryDependencies,
	"vue-query": getVueQueryDependencies,
	"svelte-query": getSvelteQueryDependencies,
	"angular-query": getAngularQueryDependencies,
	"solid-query": getSolidQueryDependencies
};
const builder = ({ type = "react-query", options: queryOptions, output } = {}) => () => {
	const client = (verbOptions, options, outputClient) => {
		if (options.override.useNamedParameters && (type === "vue-query" || outputClient === "vue-query")) throw new Error(`vue-query client does not support named parameters, and had broken reactivity previously, please set useNamedParameters to false; See for context: https://github.com/orval-labs/orval/pull/931#issuecomment-1752355686`);
		if (queryOptions) {
			const normalizedQueryOptions = normalizeQueryOptions(queryOptions, options.context.workspace);
			verbOptions.override.query = mergeDeep(normalizedQueryOptions, verbOptions.override.query);
			options.override.query = mergeDeep(normalizedQueryOptions, verbOptions.override.query);
		}
		return generateQuery(verbOptions, options, outputClient, output);
	};
	return {
		client,
		header: generateQueryHeader,
		dependencies: dependenciesBuilder[type]
	};
};
var src_default = builder;

//#endregion
export { builder, src_default as default, generateQuery, generateQueryHeader, getAngularQueryDependencies, getReactQueryDependencies, getSolidQueryDependencies, getSvelteQueryDependencies, getVueQueryDependencies };
//# sourceMappingURL=index.mjs.map