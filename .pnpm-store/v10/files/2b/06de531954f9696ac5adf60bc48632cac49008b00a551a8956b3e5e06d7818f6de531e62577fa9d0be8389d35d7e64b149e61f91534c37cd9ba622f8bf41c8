{"version":3,"file":"index.mjs","names":["e","t","DEFAULT_FORMAT_MOCK: Record<\n  Required<OpenApiSchemaObject>['format'],\n  string\n>","imports: GeneratorImport[]","includedProperties: string[]","numberImports: GeneratorImport[]","stringImports: GeneratorImport[]","enumImports: GeneratorImport[]","e","prop","combineImports: GeneratorImport[]","includedProperties: string[]","e","generateMSWImports: GenerateMockImports","splitMockImplementations: string[]","DEFAULT_MOCK_OPTIONS: GlobalMockOptions","generateMockImports: GenerateMockImports"],"sources":["../src/delay.ts","../../../node_modules/remeda/dist/prop-Cv_AVBuA.js","../src/faker/compatible-v9.ts","../src/faker/constants.ts","../src/faker/getters/object.ts","../src/faker/getters/scalar.ts","../src/faker/resolvers/value.ts","../src/faker/getters/combine.ts","../src/faker/getters/route.ts","../src/msw/mocks.ts","../src/msw/index.ts","../src/index.ts"],"sourcesContent":["import type { GlobalMockOptions, NormalizedOverrideOutput } from '@orval/core';\n\nexport const getDelay = (\n  override?: NormalizedOverrideOutput,\n  options?: GlobalMockOptions,\n): GlobalMockOptions['delay'] => {\n  const overrideDelay = override?.mock?.delay ?? options?.delay;\n  const delayFunctionLazyExecute =\n    override?.mock?.delayFunctionLazyExecute ??\n    options?.delayFunctionLazyExecute;\n  switch (typeof overrideDelay) {\n    case 'function': {\n      return delayFunctionLazyExecute ? overrideDelay : overrideDelay();\n    }\n    case 'number':\n    case 'boolean': {\n      return overrideDelay;\n    }\n    default: {\n      return false;\n    }\n  }\n};\n","function e(e,...n){return typeof e==`string`||typeof e==`number`||typeof e==`symbol`?r=>t(r,e,...n):t(e,...n)}function t(e,...t){let n=e;for(let e of t){if(n==null)return;n=n[e]}return n}export{e as prop};\n//# sourceMappingURL=prop-Cv_AVBuA.js.map","import { compareVersions, type PackageJson } from '@orval/core';\n\nconst getFakerPackageVersion = (packageJson: PackageJson) => {\n  return (\n    packageJson.dependencies?.['@faker-js/faker'] ??\n    packageJson.devDependencies?.['@faker-js/faker'] ??\n    packageJson.peerDependencies?.['@faker-js/faker']\n  );\n};\n\nexport const isFakerVersionV9 = (packageJson: PackageJson) => {\n  const version = getFakerPackageVersion(packageJson);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '9.0.0');\n};\n","import type { OpenApiSchemaObject } from '@orval/core';\n\nexport const DEFAULT_FORMAT_MOCK: Record<\n  Required<OpenApiSchemaObject>['format'],\n  string\n> = {\n  bic: 'faker.finance.bic()',\n  binary:\n    \"new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' ')))\",\n  city: 'faker.location.city()',\n  country: 'faker.location.country()',\n  date: 'faker.date.past().toISOString().slice(0, 10)',\n  'date-time': \"faker.date.past().toISOString().slice(0, 19) + 'Z'\",\n  email: 'faker.internet.email()',\n  firstName: 'faker.person.firstName()',\n  gender: 'faker.person.gender()',\n  iban: 'faker.finance.iban()',\n  ipv4: 'faker.internet.ipv4()',\n  ipv6: 'faker.internet.ipv6()',\n  jobTitle: 'faker.person.jobTitle()',\n  lastName: 'faker.person.lastName()',\n  password: 'faker.internet.password()',\n  phoneNumber: 'faker.phone.number()',\n  streetName: 'faker.location.street()',\n  uri: 'faker.internet.url()',\n  url: 'faker.internet.url()',\n  userName: 'faker.internet.userName()',\n  uuid: 'faker.string.uuid()',\n  zipCode: 'faker.location.zipCode()',\n};\n\n// #980 replace CUID so tests are consistent\nexport const DEFAULT_OBJECT_KEY_MOCK = 'faker.string.alphanumeric(5)';\n","import {\n  type ContextSpec,\n  type GeneratorImport,\n  getKey,\n  isBoolean,\n  isReference,\n  type MockOptions,\n  type OpenApiReferenceObject,\n  type OpenApiSchemaObject,\n  pascal,\n  PropertySortOrder,\n} from '@orval/core';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { DEFAULT_OBJECT_KEY_MOCK } from '../constants';\nimport { resolveMockValue } from '../resolvers/value';\nimport { combineSchemasMock } from './combine';\n\nexport const overrideVarName = 'overrideResponse';\n\ninterface GetMockObjectOptions {\n  item: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpec;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}\n\nexport function getMockObject({\n  item,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: GetMockObjectOptions): MockDefinition {\n  if (isReference(item)) {\n    return resolveMockValue({\n      schema: {\n        ...item,\n        name: item.name,\n        path: item.path ? `${item.path}.${item.name}` : item.name,\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (item.allOf || item.oneOf || item.anyOf) {\n    const separator = item.allOf ? 'allOf' : item.oneOf ? 'oneOf' : 'anyOf';\n    return combineSchemasMock({\n      item,\n      separator,\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (Array.isArray(item.type)) {\n    return combineSchemasMock({\n      item: {\n        anyOf: item.type.map((type) => ({ type })),\n        name: item.name,\n      },\n      separator: 'anyOf',\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (item.properties) {\n    let value =\n      !combine || combine.separator === 'oneOf' || combine.separator === 'anyOf'\n        ? '{'\n        : '';\n    const imports: GeneratorImport[] = [];\n    const includedProperties: string[] = [];\n\n    const entries = Object.entries(item.properties);\n    if (context.output.propertySortOrder === PropertySortOrder.ALPHABETICAL) {\n      entries.sort((a, b) => {\n        return a[0].localeCompare(b[0]);\n      });\n    }\n    const propertyScalars = entries\n      .map(\n        ([key, prop]: [\n          string,\n          OpenApiReferenceObject | OpenApiSchemaObject,\n        ]) => {\n          if (combine?.includedProperties.includes(key)) {\n            return;\n          }\n\n          const isRequired =\n            mockOptions?.required ??\n            (Array.isArray(item.required) ? item.required : []).includes(key);\n\n          // Check to see if the property is a reference to an existing property\n          // Fixes issue #910\n          if (\n            '$ref' in prop &&\n            existingReferencedProperties.includes(\n              pascal(prop.$ref.split('/').pop() ?? ''),\n            )\n          ) {\n            return;\n          }\n\n          const resolvedValue = resolveMockValue({\n            schema: {\n              ...prop,\n              name: key,\n              path: item.path ? `${item.path}.${key}` : `#.${key}`,\n            },\n            mockOptions,\n            operationId,\n            tags,\n            context,\n            imports,\n            existingReferencedProperties,\n            splitMockImplementations,\n          });\n\n          imports.push(...resolvedValue.imports);\n          includedProperties.push(key);\n\n          const keyDefinition = getKey(key);\n\n          if (!isRequired && !resolvedValue.overrided) {\n            return `${keyDefinition}: faker.helpers.arrayElement([${resolvedValue.value}, undefined])`;\n          }\n\n          const isNullable =\n            Array.isArray(prop.type) && prop.type.includes('null');\n          if (isNullable && !resolvedValue.overrided) {\n            return `${keyDefinition}: faker.helpers.arrayElement([${resolvedValue.value}, null])`;\n          }\n\n          return `${keyDefinition}: ${resolvedValue.value}`;\n        },\n      )\n      .filter(Boolean);\n\n    if (allowOverride) {\n      propertyScalars.push(`...${overrideVarName}`);\n    }\n\n    value += propertyScalars.join(', ');\n    value +=\n      !combine || combine.separator === 'oneOf' || combine.separator === 'anyOf'\n        ? '}'\n        : '';\n\n    return {\n      value,\n      imports,\n      name: item.name,\n      includedProperties,\n    };\n  }\n\n  if (item.additionalProperties) {\n    if (isBoolean(item.additionalProperties)) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n    if (\n      isReference(item.additionalProperties) &&\n      existingReferencedProperties.includes(\n        item.additionalProperties.$ref.split('/').pop() ?? '',\n      )\n    ) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n\n    const resolvedValue = resolveMockValue({\n      schema: {\n        ...item.additionalProperties,\n        name: item.name,\n        path: item.path ? `${item.path}.#` : '#',\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n\n    return {\n      ...resolvedValue,\n      value: `{\n        [${DEFAULT_OBJECT_KEY_MOCK}]: ${resolvedValue.value}\n      }`,\n    };\n  }\n\n  return { value: '{}', imports: [], name: item.name };\n}\n","import {\n  type ContextSpec,\n  EnumGeneration,\n  escape,\n  type GeneratorImport,\n  mergeDeep,\n  type MockOptions,\n  type OpenApiSchemaObject,\n  pascal,\n} from '@orval/core';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { isFakerVersionV9 } from '../compatible-v9';\nimport { DEFAULT_FORMAT_MOCK } from '../constants';\nimport {\n  getNullable,\n  resolveMockOverride,\n  resolveMockValue,\n} from '../resolvers';\nimport { getMockObject } from './object';\n\ninterface GetMockScalarOptions {\n  item: MockSchemaObject;\n  imports: GeneratorImport[];\n  mockOptions?: MockOptions;\n  operationId: string;\n  isRef?: boolean;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpec;\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}\n\nexport function getMockScalar({\n  item,\n  imports,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: GetMockScalarOptions): MockDefinition {\n  // Add the property to the existing properties to validate on object recursion\n  if (item.isRef) {\n    existingReferencedProperties = [...existingReferencedProperties, item.name];\n  }\n\n  const operationProperty = resolveMockOverride(\n    mockOptions?.operations?.[operationId]?.properties,\n    item,\n  );\n\n  if (operationProperty) {\n    return operationProperty;\n  }\n\n  const overrideTag = Object.entries(mockOptions?.tags ?? {})\n    .toSorted((a, b) => {\n      return a[0].localeCompare(b[0]);\n    })\n    .reduce(\n      (acc, [tag, options]) =>\n        tags.includes(tag) ? mergeDeep(acc, options) : acc,\n      {} as { properties: Record<string, unknown> },\n    );\n\n  const tagProperty = resolveMockOverride(overrideTag.properties, item);\n\n  if (tagProperty) {\n    return tagProperty;\n  }\n\n  const property = resolveMockOverride(mockOptions?.properties, item);\n\n  if (property) {\n    return property;\n  }\n\n  if (\n    (context.output.override.mock?.useExamples || mockOptions?.useExamples) &&\n    item.example !== undefined\n  ) {\n    return {\n      value: JSON.stringify(item.example),\n      imports: [],\n      name: item.name,\n      overrided: true,\n    };\n  }\n\n  const ALL_FORMAT = {\n    ...DEFAULT_FORMAT_MOCK,\n    ...mockOptions?.format,\n  };\n\n  const isNullable = Array.isArray(item.type) && item.type.includes('null');\n  if (item.format && ALL_FORMAT[item.format]) {\n    let value = ALL_FORMAT[item.format] as string;\n\n    const dateFormats = ['date', 'date-time'];\n    if (dateFormats.includes(item.format) && context.output.override.useDates) {\n      value = `new Date(${value})`;\n    }\n\n    return {\n      value: getNullable(value, isNullable),\n      imports: [],\n      name: item.name,\n      overrided: false,\n    };\n  }\n\n  const type = getItemType(item);\n  const isFakerV9 =\n    !!context.output.packageJson &&\n    isFakerVersionV9(context.output.packageJson);\n\n  switch (type) {\n    case 'number':\n    case 'integer': {\n      const intFunction =\n        context.output.override.useBigInt &&\n        (item.format === 'int64' || item.format === 'uint64')\n          ? 'bigInt'\n          : 'int';\n      let value = getNullable(\n        `faker.number.${intFunction}({min: ${item.exclusiveMinimum ?? item.minimum ?? mockOptions?.numberMin}, max: ${item.exclusiveMaximum ?? item.maximum ?? mockOptions?.numberMax}${isFakerV9 && item.multipleOf !== undefined ? `, multipleOf: ${item.multipleOf}` : ''}})`,\n        isNullable,\n      );\n      if (type === 'number') {\n        value = getNullable(\n          `faker.number.float({min: ${item.exclusiveMinimum ?? item.minimum ?? mockOptions?.numberMin}, max: ${item.exclusiveMaximum ?? item.maximum ?? mockOptions?.numberMax}${isFakerV9 && item.multipleOf !== undefined ? `, multipleOf: ${item.multipleOf}` : `, fractionDigits: ${mockOptions?.fractionDigits}`}})`,\n          isNullable,\n        );\n      }\n      const numberImports: GeneratorImport[] = [];\n\n      if (item.enum) {\n        value = getEnum(\n          item,\n          numberImports,\n          context,\n          existingReferencedProperties,\n          'number',\n        );\n      } else if ('const' in item) {\n        value = JSON.stringify(item.const);\n      }\n\n      return {\n        value,\n        enums: item.enum,\n        imports: numberImports,\n        name: item.name,\n      };\n    }\n\n    case 'boolean': {\n      let value = 'faker.datatype.boolean()';\n      if ('const' in item) {\n        value = JSON.stringify(item.const);\n      }\n      return {\n        value,\n        imports: [],\n        name: item.name,\n      };\n    }\n\n    case 'array': {\n      if (!item.items) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      if (\n        '$ref' in item.items &&\n        existingReferencedProperties.includes(\n          pascal(item.items.$ref.split('/').pop() ?? ''),\n        )\n      ) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      const {\n        value,\n        enums,\n        imports: resolvedImports,\n      } = resolveMockValue({\n        schema: {\n          ...item.items,\n          name: item.name,\n          path: item.path ? `${item.path}.[]` : '#.[]',\n        },\n        combine,\n        mockOptions,\n        operationId,\n        tags,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n      });\n\n      if (enums) {\n        return {\n          value,\n          imports: resolvedImports,\n          name: item.name,\n        };\n      }\n\n      let mapValue = value;\n\n      if (\n        combine &&\n        !value.startsWith('faker') &&\n        !value.startsWith('{') &&\n        !value.startsWith('Array.from')\n      ) {\n        mapValue = `{${value}}`;\n      }\n\n      return {\n        value:\n          `Array.from({ length: faker.number.int({ ` +\n          `min: ${item.minItems ?? mockOptions?.arrayMin}, ` +\n          `max: ${item.maxItems ?? mockOptions?.arrayMax} }) ` +\n          `}, (_, i) => i + 1).map(() => (${mapValue}))`,\n        imports: resolvedImports,\n        name: item.name,\n      };\n    }\n\n    case 'string': {\n      const length = `{length: {min: ${item.minLength ?? mockOptions?.stringMin}, max: ${item.maxLength ?? mockOptions?.stringMax}}}`;\n      let value = `faker.string.alpha(${length})`;\n      const stringImports: GeneratorImport[] = [];\n\n      if (item.enum) {\n        value = getEnum(\n          item,\n          stringImports,\n          context,\n          existingReferencedProperties,\n          'string',\n        );\n      } else if (item.pattern) {\n        value = `faker.helpers.fromRegExp('${item.pattern}')`;\n      } else if ('const' in item) {\n        value = JSON.stringify((item as OpenApiSchemaObject).const);\n      }\n\n      return {\n        value: getNullable(value, isNullable),\n        enums: item.enum,\n        name: item.name,\n        imports: stringImports,\n      };\n    }\n\n    case 'null': {\n      return {\n        value: 'null',\n        imports: [],\n        name: item.name,\n      };\n    }\n\n    default: {\n      if (item.enum) {\n        const enumImports: GeneratorImport[] = [];\n        const value = getEnum(\n          item,\n          enumImports,\n          context,\n          existingReferencedProperties,\n        );\n\n        return {\n          value,\n          enums: item.enum,\n          imports: enumImports,\n          name: item.name,\n        };\n      }\n\n      return getMockObject({\n        item,\n        mockOptions,\n        operationId,\n        tags,\n        combine: combine\n          ? {\n              separator: combine.separator,\n              includedProperties: [],\n            }\n          : undefined,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n        allowOverride,\n      });\n    }\n  }\n}\n\nfunction getItemType(item: MockSchemaObject) {\n  if (Array.isArray(item.type) && item.type.includes('null')) {\n    const typesWithoutNull = item.type.filter((x) => x !== 'null');\n    const itemType =\n      typesWithoutNull.length === 1 ? typesWithoutNull[0] : typesWithoutNull;\n\n    return itemType;\n  }\n\n  if (item.type) return item.type;\n  if (!item.enum) return;\n\n  const uniqTypes = new Set(item.enum.map((value) => typeof value));\n  if (uniqTypes.size > 1) return;\n\n  const type = [...uniqTypes.values()].at(0);\n  if (!type) return;\n  return ['string', 'number'].includes(type) ? type : undefined;\n}\n\nfunction getEnum(\n  item: MockSchemaObject,\n  imports: GeneratorImport[],\n  context: ContextSpec,\n  existingReferencedProperties: string[],\n  type?: 'string' | 'number',\n) {\n  if (!item.enum) return '';\n  const joinedEnumValues = item.enum\n    .filter((e) => e !== null) // TODO fix type, e can absolutely be null\n    .map((e) =>\n      type === 'string' || (type === undefined && typeof e === 'string')\n        ? `'${escape(e)}'`\n        : e,\n    )\n    .join(',');\n\n  let enumValue = `[${joinedEnumValues}]`;\n  if (context.output.override.enumGenerationType === EnumGeneration.ENUM) {\n    if (item.isRef || existingReferencedProperties.length === 0) {\n      enumValue += ` as ${item.name}${item.name.endsWith('[]') ? '' : '[]'}`;\n      imports.push({ name: item.name });\n    } else {\n      enumValue += ` as ${existingReferencedProperties[existingReferencedProperties.length - 1]}['${item.name}']`;\n      if (!item.path?.endsWith('[]')) enumValue += '[]';\n      imports.push({\n        name: existingReferencedProperties[\n          existingReferencedProperties.length - 1\n        ],\n      });\n    }\n  } else {\n    enumValue += ' as const';\n  }\n\n  // But if the value is a reference, we can use the object directly via the imports and using Object.values.\n  if (item.isRef && type === 'string') {\n    enumValue = `Object.values(${item.name})`;\n    imports.push({\n      name: item.name,\n      values: true,\n    });\n  }\n\n  return item.path?.endsWith('[]')\n    ? `faker.helpers.arrayElements(${enumValue})`\n    : `faker.helpers.arrayElement(${enumValue})`;\n}\n","import {\n  type ContextSpec,\n  type GeneratorImport,\n  getRefInfo,\n  isReference,\n  type MockOptions,\n  type OpenApiSchemaObject,\n  pascal,\n} from '@orval/core';\nimport { prop } from 'remeda';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { overrideVarName } from '../getters';\nimport { getMockScalar } from '../getters/scalar';\n\nfunction isRegex(key: string) {\n  return key.startsWith('/') && key.endsWith('/');\n}\n\nexport function resolveMockOverride(\n  properties: Record<string, unknown> | undefined = {},\n  item: OpenApiSchemaObject & { name: string; path?: string },\n) {\n  const path = item.path ?? `#.${item.name}`;\n  const property = Object.entries(properties).find(([key]) => {\n    if (isRegex(key)) {\n      const regex = new RegExp(key.slice(1, -1));\n      if (regex.test(item.name) || regex.test(path)) {\n        return true;\n      }\n    }\n\n    if (`#.${key}` === path) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (!property) {\n    return;\n  }\n\n  const isNullable = Array.isArray(item.type) && item.type.includes('null');\n\n  return {\n    value: getNullable(property[1] as string, isNullable),\n    imports: [],\n    name: item.name,\n    overrided: true,\n  };\n}\n\nexport function getNullable(value: string, nullable?: boolean) {\n  return nullable ? `faker.helpers.arrayElement([${value}, null])` : value;\n}\n\ninterface ResolveMockValueOptions {\n  schema: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpec;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  allowOverride?: boolean;\n}\n\nexport function resolveMockValue({\n  schema,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride,\n}: ResolveMockValueOptions): MockDefinition & { type?: string } {\n  if (isReference(schema)) {\n    const { originalName, refPaths } = getRefInfo(schema.$ref, context);\n\n    const schemaRef = Array.isArray(refPaths)\n      ? (prop(\n          context.spec,\n          // @ts-expect-error: [ts2556] refPaths are not guaranteed to be valid keys of the spec\n          ...refPaths,\n        ) as Partial<OpenApiSchemaObject>)\n      : undefined;\n\n    const newSchema = {\n      ...schemaRef,\n      name: pascal(originalName),\n      path: schema.path,\n      isRef: true,\n      required: [...(schemaRef?.required ?? []), ...(schema.required ?? [])],\n    };\n\n    const newSeparator = newSchema.allOf\n      ? 'allOf'\n      : newSchema.oneOf\n        ? 'oneOf'\n        : 'anyOf';\n\n    const scalar = getMockScalar({\n      item: newSchema,\n      mockOptions,\n      operationId,\n      tags,\n      combine: combine\n        ? {\n            separator:\n              combine.separator === 'anyOf' ? newSeparator : combine.separator,\n            includedProperties:\n              newSeparator === 'allOf' ? [] : combine.includedProperties,\n          }\n        : undefined,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n      allowOverride,\n    });\n    if (\n      scalar.value &&\n      (newSchema.type === 'object' || newSchema.allOf) &&\n      combine?.separator === 'oneOf'\n    ) {\n      const funcName = `get${pascal(operationId)}Response${pascal(newSchema.name)}Mock`;\n      if (\n        !splitMockImplementations.some((f) =>\n          f.includes(`export const ${funcName}`),\n        )\n      ) {\n        const discriminatedProperty = newSchema.discriminator?.propertyName;\n\n        let type = `Partial<${newSchema.name}>`;\n        if (discriminatedProperty) {\n          type = `Omit<${type}, '${discriminatedProperty}'>`;\n        }\n\n        const args = `${overrideVarName}: ${type} = {}`;\n        const func = `export const ${funcName} = (${args}): ${newSchema.name} => ({${scalar.value.startsWith('...') ? '' : '...'}${scalar.value}, ...${overrideVarName}});`;\n        splitMockImplementations.push(func);\n      }\n\n      scalar.value = newSchema.nullable\n        ? `${funcName}()`\n        : `{...${funcName}()}`;\n\n      scalar.imports.push({ name: newSchema.name });\n    }\n\n    return {\n      ...scalar,\n      type: getType(newSchema),\n    };\n  }\n\n  const scalar = getMockScalar({\n    item: schema,\n    mockOptions,\n    operationId,\n    tags,\n    combine,\n    context,\n    imports,\n    existingReferencedProperties,\n    splitMockImplementations,\n    allowOverride,\n  });\n  return {\n    ...scalar,\n    type: getType(schema),\n  };\n}\n\nfunction getType(schema: MockSchemaObject) {\n  return (\n    (schema.type as string | undefined) ??\n    (schema.properties ? 'object' : schema.items ? 'array' : undefined)\n  );\n}\n","import {\n  type ContextSpec,\n  type GeneratorImport,\n  isReference,\n  isSchema,\n  type MockOptions,\n  pascal,\n} from '@orval/core';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { resolveMockValue } from '../resolvers';\n\ninterface CombineSchemasMockOptions {\n  item: MockSchemaObject;\n  separator: 'allOf' | 'oneOf' | 'anyOf';\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpec;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n}\n\nexport function combineSchemasMock({\n  item,\n  separator,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n}: CombineSchemasMockOptions): MockDefinition {\n  const combineImports: GeneratorImport[] = [];\n  const includedProperties: string[] = [...(combine?.includedProperties ?? [])];\n\n  const isRefAndNotExisting =\n    isReference(item) && !existingReferencedProperties.includes(item.name);\n\n  const itemResolvedValue =\n    isRefAndNotExisting || item.properties\n      ? resolveMockValue({\n          schema: Object.fromEntries(\n            Object.entries(item).filter(([key]) => key !== separator),\n          ) as MockSchemaObject,\n          combine: {\n            separator: 'allOf',\n            includedProperties: [],\n          },\n          mockOptions,\n          operationId,\n          tags,\n          context,\n          imports,\n          existingReferencedProperties,\n          splitMockImplementations,\n        })\n      : undefined;\n\n  includedProperties.push(...(itemResolvedValue?.includedProperties ?? []));\n  combineImports.push(...(itemResolvedValue?.imports ?? []));\n  let containsOnlyPrimitiveValues = true;\n\n  const value = (item[separator] ?? []).reduce(\n    (acc, val, _, arr) => {\n      const refName =\n        '$ref' in val ? pascal(val.$ref.split('/').pop() ?? '') : '';\n      // For allOf: skip if refName is in existingRefs AND this is an inline schema (not a top-level ref)\n      // This allows top-level schemas (item.isRef=true) to get base properties from allOf\n      // while preventing circular allOf chains in inline property schemas\n      const shouldSkipRef =\n        separator === 'allOf'\n          ? refName &&\n            (refName === item.name ||\n              (existingReferencedProperties.includes(refName) && !item.isRef))\n          : refName && existingReferencedProperties.includes(refName);\n      if (shouldSkipRef) {\n        if (arr.length === 1) {\n          return 'undefined';\n        }\n\n        return acc;\n      }\n\n      // the required fields in this schema need to be considered\n      // in the sub schema under the allOf key\n      if (separator === 'allOf' && item.required) {\n        val =\n          isSchema(val) && val.required\n            ? { ...val, required: [...item.required, ...val.required] }\n            : { ...val, required: item.required };\n      }\n\n      const resolvedValue = resolveMockValue({\n        schema: {\n          ...val,\n          name: item.name,\n          path: item.path ?? '#',\n        },\n        combine: {\n          separator,\n          includedProperties:\n            separator === 'oneOf'\n              ? (itemResolvedValue?.includedProperties ?? [])\n              : includedProperties,\n        },\n        mockOptions,\n        operationId,\n        tags,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n      });\n\n      combineImports.push(...resolvedValue.imports);\n      includedProperties.push(...(resolvedValue.includedProperties ?? []));\n\n      if (resolvedValue.value === '{}') {\n        containsOnlyPrimitiveValues = false;\n        return acc;\n      }\n      if (separator === 'allOf') {\n        if (resolvedValue.value.startsWith('{') || !resolvedValue.type) {\n          containsOnlyPrimitiveValues = false;\n          return `${acc}...${resolvedValue.value},`;\n        } else if (resolvedValue.type === 'object') {\n          containsOnlyPrimitiveValues = false;\n          return resolvedValue.value.startsWith('faker')\n            ? `${acc}...${resolvedValue.value},`\n            : `${acc}...{${resolvedValue.value}},`;\n        }\n      }\n      return `${acc}${resolvedValue.value},`;\n    },\n    separator === 'allOf' ? '' : 'faker.helpers.arrayElement([',\n  );\n  let finalValue =\n    value === 'undefined'\n      ? value\n      : // containsOnlyPrimitiveValues isn't just true, it's being set to false inside the above reduce and the type system doesn't detect it\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        `${separator === 'allOf' && !containsOnlyPrimitiveValues ? '{' : ''}${value}${separator === 'allOf' ? (containsOnlyPrimitiveValues ? '' : '}') : '])'}`;\n  if (itemResolvedValue) {\n    finalValue = finalValue.startsWith('...')\n      ? `...{${finalValue}, ${itemResolvedValue.value}}`\n      : `{...${finalValue}, ${itemResolvedValue.value}}`;\n  }\n  if (finalValue.endsWith(',')) {\n    finalValue = finalValue.slice(0, Math.max(0, finalValue.length - 1));\n  }\n\n  return {\n    value: finalValue,\n    imports: combineImports,\n    name: item.name,\n    includedProperties,\n  };\n}\n","import { camel, sanitize } from '@orval/core';\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = /([^{]*){?([\\w*_-]*)}?(.*)/.exec(path);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(camel(matches[2]), {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  return hasParam(path) ? `${prev}:${param}${next}` : `${prev}${param}${next}`;\n};\n\nexport const getRouteMSW = (route: string, baseUrl = '*') => {\n  route = route.replaceAll(':', String.raw`\\:`);\n  const splittedRoute = route.split('/');\n\n  return splittedRoute.reduce((acc, path, i) => {\n    if (!path && !i) {\n      return acc;\n    }\n\n    if (!path.includes('{')) {\n      return `${acc}/${path}`;\n    }\n\n    return `${acc}/${getRoutePath(path)}`;\n  }, baseUrl);\n};\n","import {\n  type ContextSpec,\n  generalJSTypesWithArray,\n  type GeneratorImport,\n  type GlobalMockOptions,\n  isFunction,\n  type MockOptions,\n  type NormalizedOverrideOutput,\n  type OpenApiDocument,\n  type OpenApiSchemaObject,\n  resolveRef,\n  type ResReqTypesValue,\n  stringify,\n} from '@orval/core';\n\nimport { getMockScalar } from '../faker/getters';\n\nfunction getMockPropertiesWithoutFunc(properties: any, spec: OpenApiDocument) {\n  return Object.entries(\n    isFunction(properties) ? properties(spec) : properties,\n  ).reduce<Record<string, string>>((acc, [key, value]) => {\n    const implementation = isFunction(value)\n      ? `(${value})()`\n      : stringify(value as string)!;\n\n    acc[key] = implementation.replaceAll(\n      /import_faker\\.defaults|import_faker\\.faker|_faker\\.faker/g,\n      'faker',\n    );\n    return acc;\n  }, {});\n}\n\nfunction getMockWithoutFunc(\n  spec: OpenApiDocument,\n  override?: NormalizedOverrideOutput,\n): MockOptions {\n  return {\n    arrayMin: override?.mock?.arrayMin,\n    arrayMax: override?.mock?.arrayMax,\n    stringMin: override?.mock?.stringMin,\n    stringMax: override?.mock?.stringMax,\n    numberMin: override?.mock?.numberMin,\n    numberMax: override?.mock?.numberMax,\n    required: override?.mock?.required,\n    fractionDigits: override?.mock?.fractionDigits,\n    ...(override?.mock?.properties\n      ? {\n          properties: getMockPropertiesWithoutFunc(\n            override.mock.properties,\n            spec,\n          ),\n        }\n      : {}),\n    ...(override?.mock?.format\n      ? {\n          format: getMockPropertiesWithoutFunc(override.mock.format, spec),\n        }\n      : {}),\n    ...(override?.operations\n      ? {\n          operations: Object.entries(override.operations).reduce<\n            Exclude<MockOptions['operations'], undefined>\n          >((acc, [key, value]) => {\n            if (value?.mock?.properties) {\n              acc[key] = {\n                properties: getMockPropertiesWithoutFunc(\n                  value.mock.properties,\n                  spec,\n                ),\n              };\n            }\n\n            return acc;\n          }, {}),\n        }\n      : {}),\n    ...(override?.tags\n      ? {\n          tags: Object.entries(override.tags).reduce<\n            Exclude<MockOptions['tags'], undefined>\n          >((acc, [key, value]) => {\n            if (value?.mock?.properties) {\n              acc[key] = {\n                properties: getMockPropertiesWithoutFunc(\n                  value.mock.properties,\n                  spec,\n                ),\n              };\n            }\n\n            return acc;\n          }, {}),\n        }\n      : {}),\n  };\n}\n\nfunction getMockScalarJsTypes(\n  definition: string,\n  mockOptionsWithoutFunc: Record<string, unknown>,\n) {\n  const isArray = definition.endsWith('[]');\n  const type = isArray ? definition.slice(0, -2) : definition;\n\n  switch (type) {\n    case 'number': {\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc.arrayMin}, ` +\n            `max: ${mockOptionsWithoutFunc.arrayMax}}` +\n            `)}, () => faker.number.int())`\n        : 'faker.number.int()';\n    }\n    case 'string': {\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc?.arrayMin},` +\n            `max: ${mockOptionsWithoutFunc?.arrayMax}}` +\n            `)}, () => faker.word.sample())`\n        : 'faker.word.sample()';\n    }\n    default: {\n      return 'undefined';\n    }\n  }\n}\n\ninterface GetResponsesMockDefinitionOptions {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  mockOptionsWithoutFunc: Record<string, unknown>;\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpec;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}\n\nexport function getResponsesMockDefinition({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  mockOptionsWithoutFunc,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: GetResponsesMockDefinitionOptions) {\n  return responses.reduce(\n    (\n      acc,\n      { value: definition, originalSchema, example, examples, imports, isRef },\n    ) => {\n      if (\n        context.output.override.mock?.useExamples ||\n        mockOptions?.useExamples\n      ) {\n        let exampleValue =\n          example ??\n          originalSchema?.example ??\n          Object.values(examples ?? {})[0] ??\n          originalSchema?.examples?.[0];\n        exampleValue = exampleValue?.value ?? exampleValue;\n        if (exampleValue) {\n          acc.definitions.push(\n            transformer\n              ? transformer(exampleValue, returnType)\n              : JSON.stringify(exampleValue),\n          );\n          return acc;\n        }\n      }\n      if (!definition || generalJSTypesWithArray.includes(definition)) {\n        const value = getMockScalarJsTypes(definition, mockOptionsWithoutFunc);\n\n        acc.definitions.push(\n          transformer ? transformer(value, returnType) : value,\n        );\n\n        return acc;\n      }\n\n      if (!originalSchema && definition === 'Blob') {\n        originalSchema = { type: 'string', format: 'binary' };\n      } else if (!originalSchema) {\n        return acc;\n      }\n\n      const resolvedRef = resolveRef<OpenApiSchemaObject>(\n        originalSchema,\n        context,\n      );\n\n      const scalar = getMockScalar({\n        item: {\n          name: definition,\n          ...resolvedRef.schema,\n        },\n        imports,\n        mockOptions: mockOptionsWithoutFunc,\n        operationId,\n        tags,\n        context,\n        existingReferencedProperties: [],\n        splitMockImplementations,\n        allowOverride: true,\n      });\n\n      acc.imports.push(...scalar.imports);\n      acc.definitions.push(\n        transformer ? transformer(scalar.value, returnType) : scalar.value,\n      );\n\n      return acc;\n    },\n    {\n      definitions: [] as string[],\n      imports: [] as GeneratorImport[],\n    },\n  );\n}\n\ninterface GetMockDefinitionOptions {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  override: NormalizedOverrideOutput;\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpec;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}\n\nexport function getMockDefinition({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  override,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: GetMockDefinitionOptions) {\n  const mockOptionsWithoutFunc = getMockWithoutFunc(context.spec, override);\n\n  const { definitions, imports } = getResponsesMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    mockOptionsWithoutFunc,\n    transformer,\n    context,\n    mockOptions,\n    splitMockImplementations,\n  });\n\n  return {\n    definition: '[' + definitions.join(', ') + ']',\n    definitions,\n    imports,\n  };\n}\n\nexport function getMockOptionsDataOverride(\n  operationTags: string[],\n  operationId: string,\n  override: NormalizedOverrideOutput,\n) {\n  const responseOverride =\n    override.operations[operationId]?.mock?.data ??\n    operationTags\n      .map((operationTag) => override.tags[operationTag]?.mock?.data)\n      .find((e) => e !== undefined);\n  const implementation = isFunction(responseOverride)\n    ? `(${responseOverride})()`\n    : stringify(responseOverride);\n\n  return implementation?.replaceAll(\n    /import_faker\\.defaults|import_faker\\.faker|_faker\\.faker/g,\n    'faker',\n  );\n}\n","import {\n  type ClientMockGeneratorBuilder,\n  generateDependencyImports,\n  type GenerateMockImports,\n  type GeneratorDependency,\n  type GeneratorImport,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  type GlobalMockOptions,\n  isFunction,\n  isObject,\n  pascal,\n  type ResReqTypesValue,\n} from '@orval/core';\n\nimport { getDelay } from '../delay';\nimport { getRouteMSW, overrideVarName } from '../faker/getters';\nimport { getMockDefinition, getMockOptionsDataOverride } from './mocks';\n\nfunction getMSWDependencies(\n  options?: GlobalMockOptions,\n): GeneratorDependency[] {\n  const hasDelay = options?.delay !== false;\n  const locale = options?.locale;\n\n  const exports = [\n    { name: 'http', values: true },\n    { name: 'HttpResponse', values: true },\n    { name: 'RequestHandlerOptions', values: false },\n  ];\n\n  if (hasDelay) {\n    exports.push({ name: 'delay', values: true });\n  }\n\n  return [\n    { exports, dependency: 'msw' },\n    {\n      exports: [{ name: 'faker', values: true }],\n      dependency: locale\n        ? `@faker-js/faker/locale/${locale}`\n        : '@faker-js/faker',\n    },\n  ];\n}\n\nexport const generateMSWImports: GenerateMockImports = ({\n  implementation,\n  imports,\n  projectName,\n  hasSchemaDir,\n  isAllowSyntheticDefaultImports,\n  options,\n}) => {\n  return generateDependencyImports(\n    implementation,\n    [...getMSWDependencies(options), ...imports],\n    projectName,\n    hasSchemaDir,\n    isAllowSyntheticDefaultImports,\n  );\n};\n\nfunction generateDefinition(\n  name: string,\n  route: string,\n  getResponseMockFunctionNameBase: string,\n  handlerNameBase: string,\n  { operationId, response, verb, tags }: GeneratorVerbOptions,\n  { override, context, mock }: GeneratorOptions,\n  returnType: string,\n  status: string,\n  responseImports: GeneratorImport[],\n  responses: ResReqTypesValue[],\n  contentTypes: string[],\n  splitMockImplementations: string[],\n) {\n  const oldSplitMockImplementations = [...splitMockImplementations];\n  const { definitions, definition, imports } = getMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    override,\n    context,\n    mockOptions: isFunction(mock) ? undefined : mock,\n    splitMockImplementations,\n  });\n\n  const mockData = getMockOptionsDataOverride(tags, operationId, override);\n\n  let value = '';\n\n  if (mockData) {\n    value = mockData;\n  } else if (definitions.length > 1) {\n    value = `faker.helpers.arrayElement(${definition})`;\n  } else if (definitions[0]) {\n    value = definitions[0];\n  }\n\n  const isResponseOverridable = value.includes(overrideVarName);\n  const isTextPlain = contentTypes.includes('text/plain');\n  const isReturnHttpResponse = value && value !== 'undefined';\n\n  const getResponseMockFunctionName = `${getResponseMockFunctionNameBase}${pascal(\n    name,\n  )}`;\n  const handlerName = `${handlerNameBase}${pascal(name)}`;\n\n  const addedSplitMockImplementations = splitMockImplementations.slice(\n    oldSplitMockImplementations.length,\n  );\n  splitMockImplementations.push(...addedSplitMockImplementations);\n  const mockImplementations =\n    addedSplitMockImplementations.length > 0\n      ? `${addedSplitMockImplementations.join('\\n\\n')}\\n\\n`\n      : '';\n\n  const mockImplementation = isReturnHttpResponse\n    ? `${mockImplementations}export const ${getResponseMockFunctionName} = (${\n        isResponseOverridable\n          ? `overrideResponse: Partial< ${returnType} > = {}`\n          : ''\n      })${mockData ? '' : `: ${returnType}`} => (${value})\\n\\n`\n    : mockImplementations;\n\n  const delay = getDelay(override, isFunction(mock) ? undefined : mock);\n  const infoParam = 'info';\n  const overrideResponse = `overrideResponse !== undefined\n    ? (typeof overrideResponse === \"function\" ? await overrideResponse(${infoParam}) : overrideResponse)\n    : ${getResponseMockFunctionName}()`;\n  const handlerImplementation = `\nexport const ${handlerName} = (overrideResponse?: ${returnType} | ((${infoParam}: Parameters<Parameters<typeof http.${verb}>[1]>[0]) => Promise<${returnType}> | ${returnType}), options?: RequestHandlerOptions) => {\n  return http.${verb}('${route}', async (${infoParam}) => {${\n    delay === false\n      ? ''\n      : `await delay(${isFunction(delay) ? `(${delay})()` : delay});`\n  }\n  ${isReturnHttpResponse ? '' : `if (typeof overrideResponse === 'function') {await overrideResponse(info); }`}\n    return new HttpResponse(${\n      isReturnHttpResponse\n        ? isTextPlain\n          ? overrideResponse\n          : `JSON.stringify(${overrideResponse})`\n        : null\n    },\n      { status: ${status === 'default' ? 200 : status.replace(/XX$/, '00')},\n        ${\n          isReturnHttpResponse\n            ? `headers: { 'Content-Type': ${isTextPlain ? \"'text/plain'\" : \"'application/json'\"} }`\n            : ''\n        }\n      })\n  }, options)\n}\\n`;\n\n  const includeResponseImports = [\n    ...imports,\n    ...response.imports.filter((r) => {\n      // Only include imports which are actually used in mock.\n      const reg = new RegExp(String.raw`\\b${r.name}\\b`);\n      return reg.test(handlerImplementation) || reg.test(mockImplementation);\n    }),\n  ];\n\n  return {\n    implementation: {\n      function: mockImplementation,\n      handlerName: handlerName,\n      handler: handlerImplementation,\n    },\n    imports: includeResponseImports,\n  };\n}\n\nexport function generateMSW(\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: GeneratorOptions,\n): ClientMockGeneratorBuilder {\n  const { pathRoute, override, mock } = generatorOptions;\n  const { operationId, response } = generatorVerbOptions;\n\n  const route = getRouteMSW(\n    pathRoute,\n    override.mock?.baseUrl ?? (isFunction(mock) ? undefined : mock?.baseUrl),\n  );\n\n  const handlerName = `get${pascal(operationId)}MockHandler`;\n  const getResponseMockFunctionName = `get${pascal(operationId)}ResponseMock`;\n\n  const splitMockImplementations: string[] = [];\n\n  const baseDefinition = generateDefinition(\n    '',\n    route,\n    getResponseMockFunctionName,\n    handlerName,\n    generatorVerbOptions,\n    generatorOptions,\n    response.definition.success,\n    response.types.success[0]?.key ?? '200',\n    response.imports,\n    response.types.success,\n    response.contentTypes,\n    splitMockImplementations,\n  );\n\n  const mockImplementations = [baseDefinition.implementation.function];\n  const handlerImplementations = [baseDefinition.implementation.handler];\n  const imports = [...baseDefinition.imports];\n\n  if (\n    generatorOptions.mock &&\n    isObject(generatorOptions.mock) &&\n    generatorOptions.mock.generateEachHttpStatus\n  ) {\n    for (const statusResponse of [\n      ...response.types.success,\n      ...response.types.errors,\n    ]) {\n      const definition = generateDefinition(\n        statusResponse.key,\n        route,\n        getResponseMockFunctionName,\n        handlerName,\n        generatorVerbOptions,\n        generatorOptions,\n        statusResponse.value,\n        statusResponse.key,\n        response.imports,\n        [statusResponse],\n        [statusResponse.contentType],\n        splitMockImplementations,\n      );\n      mockImplementations.push(definition.implementation.function);\n      handlerImplementations.push(definition.implementation.handler);\n      imports.push(...definition.imports);\n    }\n  }\n\n  return {\n    implementation: {\n      function: mockImplementations.join('\\n'),\n      handlerName: handlerName,\n      handler: handlerImplementations.join('\\n'),\n    },\n    imports: imports,\n  };\n}\n","import type {\n  GenerateMockImports,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GlobalMockOptions,\n} from '@orval/core';\n\nimport { generateMSW, generateMSWImports } from './msw';\n\nexport const DEFAULT_MOCK_OPTIONS: GlobalMockOptions = {\n  type: 'msw',\n  useExamples: false,\n};\n\nexport const generateMockImports: GenerateMockImports = (importOptions) => {\n  switch (importOptions.options?.type) {\n    default: {\n      // case 'msw':\n      return generateMSWImports(importOptions);\n    }\n  }\n};\n\nexport function generateMock(\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: Omit<GeneratorOptions, 'mock'> & {\n    mock: GlobalMockOptions;\n  },\n) {\n  switch (generatorOptions.mock.type) {\n    default: {\n      // case 'msw':\n      return generateMSW(generatorVerbOptions, generatorOptions);\n    }\n  }\n}\n"],"x_google_ignoreList":[1],"mappings":"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"}