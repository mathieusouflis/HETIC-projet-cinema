{"version":3,"file":"index.mjs","names":["AXIOS_DEPENDENCIES: GeneratorDependency[]","ANGULAR_HTTP_DEPENDENCIES: GeneratorDependency[]","isVue","generateFetchRequestFunction","httpOptions: string[]","httpCall: string","isAngular","getQueryHeader: ClientHeaderBuilder","REACT_DEPENDENCIES: GeneratorDependency[]","PARAMS_SERIALIZER_DEPENDENCIES: GeneratorDependency[]","SVELTE_QUERY_DEPENDENCIES_V3: GeneratorDependency[]","SVELTE_QUERY_DEPENDENCIES: GeneratorDependency[]","getSvelteQueryDependencies: ClientDependenciesBuilder","REACT_QUERY_DEPENDENCIES_V3: GeneratorDependency[]","REACT_QUERY_DEPENDENCIES: GeneratorDependency[]","getReactQueryDependencies: ClientDependenciesBuilder","VUE_QUERY_DEPENDENCIES_V3: GeneratorDependency[]","VUE_QUERY_DEPENDENCIES: GeneratorDependency[]","SOLID_QUERY_DEPENDENCIES: GeneratorDependency[]","ANGULAR_QUERY_DEPENDENCIES: GeneratorDependency[]","getVueQueryDependencies: ClientDependenciesBuilder","getSolidQueryDependencies: ClientDependenciesBuilder","getAngularQueryDependencies: ClientDependenciesBuilder","prefix: string","name","type","mutators: GeneratorMutator[] | undefined","generateQueryHeader: ClientHeaderBuilder","generateQuery: ClientBuilder","dependenciesBuilder: Record<\n  | 'react-query'\n  | 'vue-query'\n  | 'svelte-query'\n  | 'angular-query'\n  | 'solid-query',\n  ClientDependenciesBuilder\n>","client: ClientBuilder"],"sources":["../src/utils.ts","../src/client.ts","../src/dependencies.ts","../src/query-options.ts","../src/return-types.ts","../src/mutation-generator.ts","../src/query-generator.ts","../src/index.ts"],"sourcesContent":["import {\n  type GetterProps,\n  GetterPropType,\n  isObject,\n  isString,\n  type Mutator,\n  type NormalizedMutator,\n  type NormalizedQueryOptions,\n  OutputClient,\n  type OutputClientFunc,\n  type QueryOptions,\n  TEMPLATE_TAG_REGEX,\n  upath,\n} from '@orval/core';\nimport chalk from 'chalk';\n\nexport const normalizeQueryOptions = (\n  queryOptions: QueryOptions = {},\n  outputWorkspace: string,\n): NormalizedQueryOptions => {\n  return {\n    ...(queryOptions.usePrefetch ? { usePrefetch: true } : {}),\n    ...(queryOptions.useInvalidate ? { useInvalidate: true } : {}),\n    ...(queryOptions.useQuery ? { useQuery: true } : {}),\n    ...(queryOptions.useInfinite ? { useInfinite: true } : {}),\n    ...(queryOptions.useInfiniteQueryParam\n      ? { useInfiniteQueryParam: queryOptions.useInfiniteQueryParam }\n      : {}),\n    ...(queryOptions.options ? { options: queryOptions.options } : {}),\n    ...(queryOptions.queryKey\n      ? {\n          queryKey: normalizeMutator(outputWorkspace, queryOptions.queryKey),\n        }\n      : {}),\n    ...(queryOptions.queryOptions\n      ? {\n          queryOptions: normalizeMutator(\n            outputWorkspace,\n            queryOptions.queryOptions,\n          ),\n        }\n      : {}),\n    ...(queryOptions.mutationOptions\n      ? {\n          mutationOptions: normalizeMutator(\n            outputWorkspace,\n            queryOptions.mutationOptions,\n          ),\n        }\n      : {}),\n    ...(queryOptions.signal ? { signal: true } : {}),\n    ...(queryOptions.shouldExportMutatorHooks\n      ? { shouldExportMutatorHooks: true }\n      : {}),\n    ...(queryOptions.shouldExportQueryKey\n      ? { shouldExportQueryKey: true }\n      : {}),\n    ...(queryOptions.shouldExportHttpClient\n      ? { shouldExportHttpClient: true }\n      : {}),\n    ...(queryOptions.shouldSplitQueryKey ? { shouldSplitQueryKey: true } : {}),\n    ...(queryOptions.useOperationIdAsQueryKey\n      ? { useOperationIdAsQueryKey: true }\n      : {}),\n  };\n};\n\n// Temporary duplicate code before next major release\nconst normalizeMutator = (\n  workspace: string,\n  mutator?: Mutator,\n): NormalizedMutator | undefined => {\n  if (isObject(mutator)) {\n    if (!mutator.path) {\n      throw new Error(chalk.red(`Mutator need a path`));\n    }\n\n    return {\n      ...mutator,\n      path: upath.resolve(workspace, mutator.path),\n      default: mutator.default ?? !mutator.name,\n    };\n  }\n\n  if (isString(mutator)) {\n    return {\n      path: upath.resolve(workspace, mutator),\n      default: true,\n    };\n  }\n\n  return mutator;\n};\n\nexport function vueWrapTypeWithMaybeRef(props: GetterProps): GetterProps {\n  return props.map((prop) => {\n    const [paramName, paramType] = prop.implementation.split(':');\n    if (!paramType) return prop;\n    const name =\n      prop.type === GetterPropType.NAMED_PATH_PARAMS ? prop.name : paramName;\n\n    const [type, defaultValue] = paramType.split('=');\n    return {\n      ...prop,\n      implementation: `${name}: MaybeRef<${type.trim()}>${\n        defaultValue ? ` = ${defaultValue}` : ''\n      }`,\n    };\n  });\n}\n\nexport const vueUnRefParams = (props: GetterProps): string => {\n  return props\n    .map((prop) => {\n      if (prop.type === GetterPropType.NAMED_PATH_PARAMS) {\n        return `const ${prop.destructured} = unref(${prop.name});`;\n      }\n      return `${prop.name} = unref(${prop.name});`;\n    })\n    .join('\\n');\n};\n\nexport const wrapRouteParameters = (\n  route: string,\n  prepend: string,\n  append: string,\n): string => route.replaceAll(TEMPLATE_TAG_REGEX, `\\${${prepend}$1${append}}`);\n\nexport const makeRouteSafe = (route: string): string =>\n  wrapRouteParameters(route, 'encodeURIComponent(String(', '))');\n\nexport const isVue = (client: OutputClient | OutputClientFunc) =>\n  OutputClient.VUE_QUERY === client;\n\nexport const isSolid = (client: OutputClient | OutputClientFunc) =>\n  OutputClient.SOLID_QUERY === client;\n\nexport const isAngular = (client: OutputClient | OutputClientFunc) =>\n  OutputClient.ANGULAR_QUERY === client;\n\nexport const isReact = (client: OutputClient | OutputClientFunc) =>\n  OutputClient.REACT_QUERY === client;\n\nexport const isSvelte = (client: OutputClient | OutputClientFunc) =>\n  OutputClient.SVELTE_QUERY === client;\n\nexport const getQueryTypeForFramework = (type: string): string => {\n  // Angular Query and Svelte Query don't have suspense variants, map them to regular queries\n  switch (type) {\n    case 'suspenseQuery': {\n      return 'query';\n    }\n    case 'suspenseInfiniteQuery': {\n      return 'infiniteQuery';\n    }\n    default: {\n      return type;\n    }\n  }\n};\n\nexport const getHasSignal = ({\n  overrideQuerySignal = false,\n}: {\n  overrideQuerySignal?: boolean;\n}) => overrideQuerySignal;\n","import {\n  type ClientHeaderBuilder,\n  generateFormDataAndUrlEncodedFunction,\n  generateMutatorConfig,\n  generateMutatorRequestOptions,\n  generateOptions,\n  type GeneratorDependency,\n  type GeneratorMutator,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  type GetterResponse,\n  isSyntheticDefaultImportsAllow,\n  OutputHttpClient,\n  pascal,\n  toObjectString,\n} from '@orval/core';\nimport {\n  generateFetchHeader,\n  generateRequestFunction as generateFetchRequestFunction,\n} from '@orval/fetch';\n\nimport {\n  getHasSignal,\n  makeRouteSafe,\n  vueUnRefParams,\n  vueWrapTypeWithMaybeRef,\n} from './utils';\n\nexport const AXIOS_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'axios',\n        default: true,\n        values: true,\n        syntheticDefaultImport: true,\n      },\n      { name: 'AxiosRequestConfig' },\n      { name: 'AxiosResponse' },\n      { name: 'AxiosError' },\n    ],\n    dependency: 'axios',\n  },\n];\n\nexport const ANGULAR_HTTP_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'HttpClient', values: true },\n      { name: 'HttpHeaders', values: true },\n      { name: 'HttpParams', values: true },\n      { name: 'HttpContext' },\n    ],\n    dependency: '@angular/common/http',\n  },\n  // Note: 'inject' from @angular/core is already in ANGULAR_QUERY_DEPENDENCIES\n  {\n    exports: [\n      { name: 'lastValueFrom', values: true },\n      { name: 'fromEvent', values: true },\n    ],\n    dependency: 'rxjs',\n  },\n  {\n    exports: [{ name: 'takeUntil', values: true }],\n    dependency: 'rxjs/operators',\n  },\n];\n\nexport const generateQueryRequestFunction = (\n  verbOptions: GeneratorVerbOptions,\n  options: GeneratorOptions,\n  isVue: boolean,\n  isAngularClient = false,\n) => {\n  if (\n    isAngularClient ||\n    options.context.output.httpClient === OutputHttpClient.ANGULAR\n  ) {\n    return generateAngularHttpRequestFunction(verbOptions, options);\n  }\n  return options.context.output.httpClient === OutputHttpClient.AXIOS\n    ? generateAxiosRequestFunction(verbOptions, options, isVue)\n    : generateFetchRequestFunction(verbOptions, options);\n};\n\nexport const generateAngularHttpRequestFunction = (\n  {\n    headers,\n    queryParams,\n    operationName,\n    response,\n    mutator,\n    body,\n    props,\n    verb,\n    formData,\n    formUrlEncoded,\n    override,\n  }: GeneratorVerbOptions,\n  { route, context }: GeneratorOptions,\n) => {\n  const isRequestOptions = override.requestOptions !== false;\n  const isFormData = !override.formData.disabled;\n  const isFormUrlEncoded = override.formUrlEncoded !== false;\n  const hasSignal = getHasSignal({\n    overrideQuerySignal: override.query.signal,\n  });\n  // Check if API has a param named \"signal\" to avoid conflict with AbortSignal\n  const hasSignalParam = props.some((prop) => prop.name === 'signal');\n\n  const bodyForm = generateFormDataAndUrlEncodedFunction({\n    formData,\n    formUrlEncoded,\n    body,\n    isFormData,\n    isFormUrlEncoded,\n  });\n\n  // Handle mutator case\n  if (mutator) {\n    const isExactOptionalPropertyTypes =\n      !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;\n\n    const mutatorConfig = generateMutatorConfig({\n      route,\n      body,\n      headers,\n      queryParams,\n      response,\n      verb,\n      isFormData,\n      isFormUrlEncoded,\n      hasSignal,\n      hasSignalParam,\n      isExactOptionalPropertyTypes,\n      isVue: false,\n    });\n\n    const requestOptions = isRequestOptions\n      ? generateMutatorRequestOptions(\n          override.requestOptions,\n          mutator.hasSecondArg,\n        )\n      : '';\n\n    const propsImplementation = toObjectString(props, 'implementation');\n\n    return `${override.query.shouldExportHttpClient ? 'export ' : ''}const ${operationName} = (\\n    ${propsImplementation}\\n ${\n      isRequestOptions && mutator.hasSecondArg\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: SecondParameter<typeof ${mutator.name}>,`\n        : ''\n    } ${getSignalDefinition({ hasSignal, hasSignalParam })}) => {\n      ${bodyForm}\n      return ${mutator.name}<${response.definition.success || 'unknown'}>(\n      ${mutatorConfig},\n      ${requestOptions});\n    }\n  `;\n  }\n\n  // Generate native Angular HttpClient implementation\n  const queryProps = toObjectString(props, 'implementation').replace(\n    /,\\s*$/,\n    '',\n  );\n  const dataType = response.definition.success || 'unknown';\n\n  // Build URL with query params - use httpParams to avoid shadowing the 'params' variable\n  const hasQueryParams = queryParams?.schema.name;\n  // The queryParams variable from function props is always named 'params'\n  const urlConstruction = hasQueryParams\n    ? `const httpParams = params ? new HttpParams({ fromObject: params as Record<string, string> }) : undefined;\n    const url = \\`${route}\\`;`\n    : `const url = \\`${route}\\`;`;\n\n  // Build request options\n  const httpOptions: string[] = [];\n  if (hasQueryParams) {\n    httpOptions.push('params: httpParams');\n  }\n  if (headers) {\n    httpOptions.push('headers: new HttpHeaders(headers)');\n  }\n\n  const optionsStr =\n    httpOptions.length > 0 ? `, { ${httpOptions.join(', ')} }` : '';\n\n  // Build the HTTP method call\n  let httpCall: string;\n  const bodyArg = body.definition\n    ? toObjectString([body], 'implementation').replace(/,\\s*$/, '')\n    : '';\n\n  switch (verb) {\n    case 'get':\n    case 'head': {\n      httpCall = `http.${verb}<${dataType}>(url${optionsStr})`;\n      break;\n    }\n    case 'delete': {\n      httpCall = bodyArg\n        ? `http.${verb}<${dataType}>(url, { ${httpOptions.length > 0 ? httpOptions.join(', ') + ', ' : ''}body: ${bodyArg} })`\n        : `http.${verb}<${dataType}>(url${optionsStr})`;\n      break;\n    }\n    default: {\n      // post, put, patch\n      httpCall = `http.${verb}<${dataType}>(url, ${bodyArg || 'undefined'}${optionsStr})`;\n      break;\n    }\n  }\n\n  // For Angular, we use takeUntil with fromEvent to handle AbortSignal cancellation\n  // This follows the pattern from TanStack Query Angular documentation\n  // Note: signal can be null (from RequestInit), so we accept null | undefined\n  const optionsParam = hasSignal\n    ? 'options?: { signal?: AbortSignal | null }'\n    : '';\n\n  // Build additional params after http, handling empty queryProps properly\n  const additionalParams = [queryProps, optionsParam]\n    .filter(Boolean)\n    .join(', ');\n\n  // Note: http parameter is passed from the inject* function which has injection context\n  return `${override.query.shouldExportHttpClient ? 'export ' : ''}const ${operationName} = (\n    http: HttpClient${additionalParams ? `,\\n    ${additionalParams}` : ''}\n  ): Promise<${dataType}> => {\n    ${bodyForm}\n    ${urlConstruction}\n    const request$ = ${httpCall};\n    if (options?.signal) {\n      return lastValueFrom(request$.pipe(takeUntil(fromEvent(options.signal, 'abort'))));\n    }\n    return lastValueFrom(request$);\n  }\n`;\n};\n\nexport const generateAxiosRequestFunction = (\n  {\n    headers,\n    queryParams,\n    operationName,\n    response,\n    mutator,\n    body,\n    props: _props,\n    verb,\n    formData,\n    formUrlEncoded,\n    override,\n    paramsSerializer,\n  }: GeneratorVerbOptions,\n  { route: _route, context }: GeneratorOptions,\n  isVue: boolean,\n) => {\n  let props = _props;\n  let route = _route;\n\n  if (isVue) {\n    props = vueWrapTypeWithMaybeRef(_props);\n  }\n\n  if (context.output.urlEncodeParameters) {\n    route = makeRouteSafe(route);\n  }\n\n  const isRequestOptions = override.requestOptions !== false;\n  const isFormData = !override.formData.disabled;\n  const isFormUrlEncoded = override.formUrlEncoded !== false;\n  const hasSignal = getHasSignal({\n    overrideQuerySignal: override.query.signal,\n  });\n  // Check if API has a param named \"signal\" to avoid conflict with AbortSignal\n  const hasSignalParam = _props.some((prop) => prop.name === 'signal');\n\n  const isExactOptionalPropertyTypes =\n    !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;\n\n  const bodyForm = generateFormDataAndUrlEncodedFunction({\n    formData,\n    formUrlEncoded,\n    body,\n    isFormData,\n    isFormUrlEncoded,\n  });\n\n  if (mutator) {\n    const mutatorConfig = generateMutatorConfig({\n      route,\n      body,\n      headers,\n      queryParams,\n      response,\n      verb,\n      isFormData,\n      isFormUrlEncoded,\n      hasSignal,\n      hasSignalParam,\n      isExactOptionalPropertyTypes,\n      isVue,\n    });\n\n    const bodyDefinition = body.definition.replace('[]', String.raw`\\[\\]`);\n    const propsImplementation =\n      mutator.bodyTypeName && body.definition\n        ? toObjectString(props, 'implementation').replace(\n            new RegExp(String.raw`(\\w*):\\s?${bodyDefinition}`),\n            `$1: ${mutator.bodyTypeName}<${body.definition}>`,\n          )\n        : toObjectString(props, 'implementation');\n\n    const requestOptions = isRequestOptions\n      ? generateMutatorRequestOptions(\n          override.requestOptions,\n          mutator.hasSecondArg,\n        )\n      : '';\n\n    if (mutator.isHook) {\n      const ret = `${\n        override.query.shouldExportMutatorHooks ? 'export ' : ''\n      }const use${pascal(operationName)}Hook = () => {\n        const ${operationName} = ${mutator.name}<${\n          response.definition.success || 'unknown'\n        }>();\n\n        return useCallback((\\n    ${propsImplementation}\\n ${\n          isRequestOptions && mutator.hasSecondArg\n            ? `options${context.output.optionsParamRequired ? '' : '?'}: SecondParameter<ReturnType<typeof ${mutator.name}>>,`\n            : ''\n        }${getSignalDefinition({ hasSignal, hasSignalParam })}) => {${bodyForm}\n        return ${operationName}(\n          ${mutatorConfig},\n          ${requestOptions});\n        }, [${operationName}])\n      }\n    `;\n\n      const vueRet = `${\n        override.query.shouldExportMutatorHooks ? 'export ' : ''\n      }const use${pascal(operationName)}Hook = () => {\n        const ${operationName} = ${mutator.name}<${\n          response.definition.success || 'unknown'\n        }>();\n\n        return (\\n    ${propsImplementation}\\n ${\n          isRequestOptions && mutator.hasSecondArg\n            ? `options${context.output.optionsParamRequired ? '' : '?'}: SecondParameter<ReturnType<typeof ${mutator.name}>>,`\n            : ''\n        }${getSignalDefinition({ hasSignal, hasSignalParam })}) => {${bodyForm}\n        return ${operationName}(\n          ${mutatorConfig},\n          ${requestOptions});\n        }\n      }\n    `;\n\n      return isVue ? vueRet : ret;\n    }\n\n    return `${override.query.shouldExportHttpClient ? 'export ' : ''}const ${operationName} = (\\n    ${propsImplementation}\\n ${\n      isRequestOptions && mutator.hasSecondArg\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: SecondParameter<typeof ${mutator.name}>,`\n        : ''\n    }${getSignalDefinition({ hasSignal, hasSignalParam })}) => {\n      ${isVue ? vueUnRefParams(props) : ''}\n      ${bodyForm}\n      return ${mutator.name}<${response.definition.success || 'unknown'}>(\n      ${mutatorConfig},\n      ${requestOptions});\n    }\n  `;\n  }\n\n  const isSyntheticDefaultImportsAllowed = isSyntheticDefaultImportsAllow(\n    context.output.tsconfig,\n  );\n\n  const options = generateOptions({\n    route,\n    body,\n    headers,\n    queryParams,\n    response,\n    verb,\n    requestOptions: override.requestOptions,\n    isFormData,\n    isFormUrlEncoded,\n    paramsSerializer,\n    paramsSerializerOptions: override.paramsSerializerOptions,\n    isExactOptionalPropertyTypes,\n    hasSignal,\n    hasSignalParam,\n    isVue: isVue,\n  });\n\n  const optionsArgs = generateRequestOptionsArguments({\n    isRequestOptions,\n    hasSignal,\n    hasSignalParam,\n  });\n\n  const queryProps = toObjectString(props, 'implementation');\n\n  const httpRequestFunctionImplementation = `${override.query.shouldExportHttpClient ? 'export ' : ''}const ${operationName} = (\\n    ${queryProps} ${optionsArgs} ): Promise<AxiosResponse<${\n    response.definition.success || 'unknown'\n  }>> => {\n    ${isVue ? vueUnRefParams(props) : ''}\n    ${bodyForm}\n    return axios${\n      isSyntheticDefaultImportsAllowed ? '' : '.default'\n    }.${verb}(${options});\n  }\n`;\n\n  return httpRequestFunctionImplementation;\n};\n\nexport const generateRequestOptionsArguments = ({\n  isRequestOptions,\n  hasSignal,\n  hasSignalParam = false,\n}: {\n  isRequestOptions: boolean;\n  hasSignal: boolean;\n  hasSignalParam?: boolean;\n}) => {\n  if (isRequestOptions) {\n    return 'options?: AxiosRequestConfig\\n';\n  }\n\n  return getSignalDefinition({ hasSignal, hasSignalParam });\n};\n\nexport const getSignalDefinition = ({\n  hasSignal,\n  hasSignalParam = false,\n}: {\n  hasSignal: boolean;\n  hasSignalParam?: boolean;\n}): string => {\n  if (!hasSignal) {\n    return '';\n  }\n  const signalVar = hasSignalParam ? 'querySignal' : 'signal';\n  return `${signalVar}?: AbortSignal\\n`;\n};\n\nexport const getQueryArgumentsRequestType = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? `axios?: AxiosRequestConfig`\n      : 'fetch?: RequestInit';\n  }\n\n  if (mutator.hasSecondArg && !mutator.isHook) {\n    return `request?: SecondParameter<typeof ${mutator.name}>`;\n  }\n\n  if (mutator.hasSecondArg && mutator.isHook) {\n    return `request?: SecondParameter<ReturnType<typeof ${mutator.name}>>`;\n  }\n\n  return '';\n};\n\nexport const getQueryOptions = ({\n  isRequestOptions,\n  mutator,\n  isExactOptionalPropertyTypes,\n  hasSignal,\n  httpClient,\n  hasSignalParam = false,\n}: {\n  isRequestOptions: boolean;\n  mutator?: GeneratorMutator;\n  isExactOptionalPropertyTypes: boolean;\n  hasSignal: boolean;\n  httpClient: OutputHttpClient;\n  hasSignalParam?: boolean;\n}) => {\n  // Use querySignal if API has a param named \"signal\" to avoid conflict\n  const signalVar = hasSignalParam ? 'querySignal' : 'signal';\n  // Only use explicit `signal: querySignal` when there's a naming conflict\n  const signalProp = hasSignalParam ? `signal: ${signalVar}` : 'signal';\n\n  if (!mutator && isRequestOptions) {\n    const options =\n      httpClient === OutputHttpClient.AXIOS ? 'axiosOptions' : 'fetchOptions';\n\n    if (!hasSignal) {\n      return options;\n    }\n\n    return `{ ${\n      isExactOptionalPropertyTypes\n        ? `...(${signalVar} ? { ${signalProp} } : {})`\n        : signalProp\n    }, ...${options} }`;\n  }\n\n  // For Angular mutators with hasSecondArg, pass http through options parameter\n  // http is injected in the queryOptionsFn and passed here as the second arg to the mutator\n  if (mutator?.hasSecondArg && httpClient === OutputHttpClient.ANGULAR) {\n    if (!hasSignal) {\n      return 'http';\n    }\n    return `http, ${signalVar}`;\n  }\n\n  if (mutator?.hasSecondArg && isRequestOptions) {\n    if (!hasSignal) {\n      return 'requestOptions';\n    }\n\n    // Axios and Angular mutators: signal is a separate argument\n    // Fetch mutators: signal is wrapped in options object\n    return httpClient === OutputHttpClient.AXIOS ||\n      httpClient === OutputHttpClient.ANGULAR\n      ? `requestOptions, ${signalVar}`\n      : `{ ${signalProp}, ...requestOptions }`;\n  }\n\n  if (hasSignal) {\n    // Axios: signal is always separate\n    // Angular with mutator: signal is separate (mutator pattern)\n    // Angular without mutator: signal is wrapped (native pattern)\n    // Fetch/other: signal is wrapped\n    if (httpClient === OutputHttpClient.AXIOS) {\n      return signalVar;\n    }\n    if (httpClient === OutputHttpClient.ANGULAR && mutator) {\n      return signalVar;\n    }\n    return `{ ${signalProp} }`;\n  }\n\n  return '';\n};\n\nexport const getHookOptions = ({\n  isRequestOptions,\n  httpClient,\n  mutator,\n}: {\n  isRequestOptions: boolean;\n  httpClient: OutputHttpClient;\n  mutator?: GeneratorMutator;\n}) => {\n  if (!isRequestOptions) {\n    return '';\n  }\n\n  let value = 'const {query: queryOptions';\n\n  if (!mutator) {\n    const options =\n      httpClient === OutputHttpClient.AXIOS\n        ? ', axios: axiosOptions'\n        : ', fetch: fetchOptions';\n\n    value += options;\n  }\n\n  if (mutator?.hasSecondArg) {\n    value += ', request: requestOptions';\n  }\n\n  value += '} = options ?? {};';\n\n  return value;\n};\n\n// Helper to deduplicate union type string: \"A | B | B\" -> \"A | B\"\nconst dedupeUnionTypes = (types: string): string => {\n  if (!types) return types;\n  // Split by '|', trim spaces, filter out empty, and dedupe using a Set\n  const unique = [\n    ...new Set(\n      types\n        .split('|')\n        .map((t) => t.trim())\n        .filter(Boolean),\n    ),\n  ];\n  return unique.join(' | ');\n};\n\nexport const getQueryErrorType = (\n  operationName: string,\n  response: GetterResponse,\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  const errorsType = dedupeUnionTypes(response.definition.errors || 'unknown');\n\n  if (mutator) {\n    return mutator.hasErrorType\n      ? `${mutator.default ? pascal(operationName) : ''}ErrorType<${errorsType}>`\n      : errorsType;\n  } else {\n    return httpClient === OutputHttpClient.AXIOS\n      ? `AxiosError<${errorsType}>`\n      : errorsType;\n  }\n};\n\nexport const getHooksOptionImplementation = (\n  isRequestOptions: boolean,\n  httpClient: OutputHttpClient,\n  operationName: string,\n  mutator?: GeneratorMutator,\n) => {\n  const options =\n    httpClient === OutputHttpClient.AXIOS\n      ? ', axios: axiosOptions'\n      : ', fetch: fetchOptions';\n\n  return isRequestOptions\n    ? `const mutationKey = ['${operationName}'];\nconst {mutation: mutationOptions${\n        mutator\n          ? mutator.hasSecondArg\n            ? ', request: requestOptions'\n            : ''\n          : options\n      }} = options ?\n      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?\n      options\n      : {...options, mutation: {...options.mutation, mutationKey}}\n      : {mutation: { mutationKey, }${mutator?.hasSecondArg ? ', request: undefined' : ''}${mutator ? '' : httpClient === OutputHttpClient.AXIOS ? ', axios: undefined' : ', fetch: undefined'}};`\n    : '';\n};\n\nexport const getMutationRequestArgs = (\n  isRequestOptions: boolean,\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  const options =\n    httpClient === OutputHttpClient.AXIOS ? 'axiosOptions' : 'fetchOptions';\n\n  // For Angular mutators with hasSecondArg, pass http (which is injected in inject* fn)\n  // http is required as first param so no assertion needed\n  if (mutator?.hasSecondArg && httpClient === OutputHttpClient.ANGULAR) {\n    return 'http';\n  }\n\n  return isRequestOptions\n    ? mutator\n      ? mutator.hasSecondArg\n        ? 'requestOptions'\n        : ''\n      : options\n    : '';\n};\n\nexport const getHttpFunctionQueryProps = (\n  isVue: boolean,\n  httpClient: OutputHttpClient,\n  queryProperties: string,\n  isAngular = false,\n  hasMutator = false,\n) => {\n  const result =\n    isVue && httpClient === OutputHttpClient.FETCH && queryProperties\n      ? queryProperties\n          .split(',')\n          .map((prop) => `unref(${prop})`)\n          .join(',')\n      : queryProperties;\n\n  // For Angular, prefix with http since request functions take HttpClient as first param\n  // Skip when custom mutator is used - mutator handles HTTP client internally\n  // http is required as first param so no assertion needed\n  if ((isAngular || httpClient === OutputHttpClient.ANGULAR) && !hasMutator) {\n    return result ? `http, ${result}` : 'http';\n  }\n\n  return result;\n};\n\nexport const getQueryHeader: ClientHeaderBuilder = (params) => {\n  return params.output.httpClient === OutputHttpClient.FETCH\n    ? generateFetchHeader(params)\n    : '';\n};\n","import {\n  type ClientDependenciesBuilder,\n  compareVersions,\n  type GeneratorDependency,\n  OutputHttpClient,\n  type PackageJson,\n} from '@orval/core';\n\nimport { ANGULAR_HTTP_DEPENDENCIES, AXIOS_DEPENDENCIES } from './client';\n\nexport const REACT_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'useCallback',\n        values: true,\n      },\n    ],\n    dependency: 'react',\n  },\n];\n\nexport const PARAMS_SERIALIZER_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'qs',\n        default: true,\n        values: true,\n        syntheticDefaultImport: true,\n      },\n    ],\n    dependency: 'qs',\n  },\n];\n\nconst SVELTE_QUERY_DEPENDENCIES_V3: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useQuery', values: true },\n      { name: 'useInfiniteQuery', values: true },\n      { name: 'useMutation', values: true },\n      { name: 'useQueryClient', values: true },\n      { name: 'UseQueryOptions' },\n      {\n        name: 'UseInfiniteQueryOptions',\n      },\n      { name: 'UseMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'UseQueryStoreResult' },\n      { name: 'UseInfiniteQueryStoreResult' },\n      { name: 'QueryKey' },\n      { name: 'CreateMutationResult' },\n      { name: 'InvalidateOptions' },\n    ],\n    dependency: '@sveltestack/svelte-query',\n  },\n];\nconst SVELTE_QUERY_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'createQuery', values: true },\n      { name: 'createInfiniteQuery', values: true },\n      { name: 'createMutation', values: true },\n      { name: 'useQueryClient', values: true },\n      { name: 'CreateQueryOptions' },\n      {\n        name: 'CreateInfiniteQueryOptions',\n      },\n      { name: 'MutationFunctionContext' },\n      { name: 'CreateMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'CreateQueryResult' },\n      { name: 'CreateInfiniteQueryResult' },\n      { name: 'QueryKey' },\n      { name: 'InfiniteData' },\n      { name: 'CreateMutationResult' },\n      { name: 'DataTag' },\n      { name: 'QueryClient' },\n      { name: 'InvalidateOptions' },\n    ],\n    dependency: '@tanstack/svelte-query',\n  },\n];\n\nexport const isSvelteQueryV3 = (packageJson: PackageJson | undefined) => {\n  const hasSvelteQuery =\n    packageJson?.dependencies?.['@sveltestack/svelte-query'] ??\n    packageJson?.devDependencies?.['@sveltestack/svelte-query'] ??\n    packageJson?.peerDependencies?.['@sveltestack/svelte-query'];\n  const hasSvelteQueryV4 =\n    packageJson?.dependencies?.['@tanstack/svelte-query'] ??\n    packageJson?.devDependencies?.['@tanstack/svelte-query'] ??\n    packageJson?.peerDependencies?.['@tanstack/svelte-query'];\n\n  return !!hasSvelteQuery && !hasSvelteQueryV4;\n};\n\nexport const isSvelteQueryV6 = (packageJson: PackageJson | undefined) => {\n  return isQueryV6(packageJson, 'svelte-query');\n};\n\nexport const getSvelteQueryDependencies: ClientDependenciesBuilder = (\n  hasGlobalMutator,\n  hasParamsSerializerOptions,\n  packageJson,\n  httpClient?: OutputHttpClient,\n) => {\n  const hasSvelteQueryV3 = isSvelteQueryV3(packageJson);\n\n  return [\n    ...(!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS\n      ? AXIOS_DEPENDENCIES\n      : []),\n    ...(hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : []),\n    ...(hasSvelteQueryV3\n      ? SVELTE_QUERY_DEPENDENCIES_V3\n      : SVELTE_QUERY_DEPENDENCIES),\n  ];\n};\n\nconst REACT_QUERY_DEPENDENCIES_V3: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useQuery', values: true },\n      { name: 'useInfiniteQuery', values: true },\n      { name: 'useMutation', values: true },\n      { name: 'useQueryClient', values: true },\n      { name: 'UseQueryOptions' },\n      { name: 'UseInfiniteQueryOptions' },\n      { name: 'UseMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'UseQueryResult' },\n      { name: 'UseInfiniteQueryResult' },\n      { name: 'QueryKey' },\n      { name: 'QueryClient' },\n      { name: 'UseMutationResult' },\n      { name: 'InvalidateOptions' },\n    ],\n    dependency: 'react-query',\n  },\n];\nconst REACT_QUERY_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useQuery', values: true },\n      { name: 'useSuspenseQuery', values: true },\n      { name: 'useInfiniteQuery', values: true },\n      { name: 'useSuspenseInfiniteQuery', values: true },\n      { name: 'useMutation', values: true },\n      { name: 'useQueryClient', values: true },\n      { name: 'UseQueryOptions' },\n      { name: 'DefinedInitialDataOptions' },\n      { name: 'UndefinedInitialDataOptions' },\n      { name: 'UseSuspenseQueryOptions' },\n      { name: 'UseInfiniteQueryOptions' },\n      { name: 'UseSuspenseInfiniteQueryOptions' },\n      { name: 'UseMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'UseQueryResult' },\n      { name: 'DefinedUseQueryResult' },\n      { name: 'UseSuspenseQueryResult' },\n      { name: 'UseInfiniteQueryResult' },\n      { name: 'DefinedUseInfiniteQueryResult' },\n      { name: 'UseSuspenseInfiniteQueryResult' },\n      { name: 'QueryKey' },\n      { name: 'QueryClient' },\n      { name: 'InfiniteData' },\n      { name: 'UseMutationResult' },\n      { name: 'DataTag' },\n      { name: 'InvalidateOptions' },\n    ],\n    dependency: '@tanstack/react-query',\n  },\n];\n\nexport const getReactQueryDependencies: ClientDependenciesBuilder = (\n  hasGlobalMutator,\n  hasParamsSerializerOptions,\n  packageJson,\n  httpClient,\n  hasTagsMutator,\n  override,\n) => {\n  const hasReactQuery =\n    packageJson?.dependencies?.['react-query'] ??\n    packageJson?.devDependencies?.['react-query'] ??\n    packageJson?.peerDependencies?.['react-query'];\n  const hasReactQueryV4 =\n    packageJson?.dependencies?.['@tanstack/react-query'] ??\n    packageJson?.devDependencies?.['@tanstack/react-query'] ??\n    packageJson?.peerDependencies?.['@tanstack/react-query'];\n\n  const useReactQueryV3 =\n    override.query.version === undefined\n      ? hasReactQuery && !hasReactQueryV4\n      : override.query.version <= 3;\n\n  return [\n    ...(hasGlobalMutator || hasTagsMutator ? REACT_DEPENDENCIES : []),\n    ...(!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS\n      ? AXIOS_DEPENDENCIES\n      : []),\n    ...(hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : []),\n    ...(useReactQueryV3\n      ? REACT_QUERY_DEPENDENCIES_V3\n      : REACT_QUERY_DEPENDENCIES),\n  ];\n};\n\nconst VUE_QUERY_DEPENDENCIES_V3: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useQuery', values: true },\n      { name: 'useInfiniteQuery', values: true },\n      { name: 'useMutation', values: true },\n    ],\n    dependency: 'vue-query',\n  },\n  {\n    exports: [\n      { name: 'UseQueryOptions' },\n      { name: 'UseInfiniteQueryOptions' },\n      { name: 'UseMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'UseQueryResult' },\n      { name: 'UseInfiniteQueryResult' },\n      { name: 'QueryKey' },\n      { name: 'UseMutationReturnType' },\n      { name: 'InvalidateOptions' },\n    ],\n    dependency: 'vue-query/types',\n  },\n  {\n    exports: [\n      { name: 'unref', values: true },\n      { name: 'computed', values: true },\n    ],\n    dependency: 'vue',\n  },\n  {\n    exports: [{ name: 'UseQueryReturnType' }],\n    dependency: 'vue-query/lib/vue/useBaseQuery',\n  },\n];\n\nconst VUE_QUERY_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useQuery', values: true },\n      { name: 'useInfiniteQuery', values: true },\n      { name: 'useMutation', values: true },\n      { name: 'UseQueryOptions' },\n      { name: 'UseInfiniteQueryOptions' },\n      { name: 'UseMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'QueryKey' },\n      { name: 'UseQueryReturnType' },\n      { name: 'UseInfiniteQueryReturnType' },\n      { name: 'InfiniteData' },\n      { name: 'UseMutationReturnType' },\n      { name: 'DataTag' },\n      { name: 'QueryClient' },\n      { name: 'InvalidateOptions' },\n    ],\n    dependency: '@tanstack/vue-query',\n  },\n  {\n    exports: [\n      { name: 'unref', values: true },\n      { name: 'MaybeRef' },\n      { name: 'computed', values: true },\n    ],\n    dependency: 'vue',\n  },\n];\n\nconst SOLID_QUERY_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'createQuery', values: true },\n      { name: 'createInfiniteQuery', values: true },\n      { name: 'createMutation', values: true },\n      { name: 'CreateQueryOptions' },\n      { name: 'CreateInfiniteQueryOptions' },\n      { name: 'CreateMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'CreateQueryResult' },\n      { name: 'CreateInfiniteQueryResult' },\n      { name: 'QueryKey' },\n      { name: 'InfiniteData' },\n      { name: 'CreateMutationResult' },\n      { name: 'DataTag' },\n      { name: 'QueryClient' },\n      { name: 'InvalidateOptions' },\n    ],\n    dependency: '@tanstack/solid-query',\n  },\n];\n\nconst ANGULAR_QUERY_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'injectQuery', values: true },\n      { name: 'injectInfiniteQuery', values: true },\n      { name: 'injectMutation', values: true },\n      { name: 'InjectQueryOptions' },\n      { name: 'InjectMutationOptions' },\n      { name: 'CreateQueryOptions' },\n      { name: 'CreateInfiniteQueryOptions' },\n      { name: 'CreateMutationOptions' },\n      { name: 'QueryFunction' },\n      { name: 'MutationFunction' },\n      { name: 'QueryKey' },\n      { name: 'CreateQueryResult' },\n      { name: 'CreateInfiniteQueryResult' },\n      { name: 'InfiniteData' },\n      { name: 'CreateMutationResult' },\n      { name: 'DataTag' },\n      { name: 'QueryClient', values: true },\n      { name: 'InvalidateOptions' },\n      { name: 'MutationFunctionContext' },\n    ],\n    dependency: '@tanstack/angular-query-experimental',\n  },\n  {\n    exports: [\n      { name: 'inject', values: true },\n      { name: 'Signal' },\n      { name: 'computed', values: true },\n    ],\n    dependency: '@angular/core',\n  },\n];\n\nexport const isVueQueryV3 = (packageJson: PackageJson | undefined) => {\n  const hasVueQuery =\n    packageJson?.dependencies?.['vue-query'] ??\n    packageJson?.devDependencies?.['vue-query'] ??\n    packageJson?.peerDependencies?.['vue-query'];\n  const hasVueQueryV4 =\n    packageJson?.dependencies?.['@tanstack/vue-query'] ??\n    packageJson?.devDependencies?.['@tanstack/vue-query'] ??\n    packageJson?.peerDependencies?.['@tanstack/vue-query'];\n\n  return !!hasVueQuery && !hasVueQueryV4;\n};\n\nexport const getVueQueryDependencies: ClientDependenciesBuilder = (\n  hasGlobalMutator: boolean,\n  hasParamsSerializerOptions: boolean,\n  packageJson,\n  httpClient?: OutputHttpClient,\n) => {\n  const hasVueQueryV3 = isVueQueryV3(packageJson);\n\n  return [\n    ...(!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS\n      ? AXIOS_DEPENDENCIES\n      : []),\n    ...(hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : []),\n    ...(hasVueQueryV3 ? VUE_QUERY_DEPENDENCIES_V3 : VUE_QUERY_DEPENDENCIES),\n  ];\n};\n\nexport const getSolidQueryDependencies: ClientDependenciesBuilder = (\n  hasGlobalMutator: boolean,\n  hasParamsSerializerOptions: boolean,\n  packageJson,\n  httpClient?: OutputHttpClient,\n) => {\n  return [\n    ...(!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS\n      ? AXIOS_DEPENDENCIES\n      : []),\n    ...(hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : []),\n    ...SOLID_QUERY_DEPENDENCIES,\n  ];\n};\n\nexport const getAngularQueryDependencies: ClientDependenciesBuilder = (\n  hasGlobalMutator: boolean,\n  hasParamsSerializerOptions: boolean,\n  packageJson,\n  httpClient?: OutputHttpClient,\n) => {\n  // Always use Angular HTTP dependencies for Angular httpClient\n  // Previously skipped for mutators, but we now inject http everywhere\n  const useAngularHttp = httpClient === OutputHttpClient.ANGULAR;\n  const useAxios = !hasGlobalMutator && httpClient === OutputHttpClient.AXIOS;\n\n  return [\n    ...(useAngularHttp ? ANGULAR_HTTP_DEPENDENCIES : []),\n    ...(useAxios ? AXIOS_DEPENDENCIES : []),\n    ...(hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : []),\n    ...ANGULAR_QUERY_DEPENDENCIES,\n  ];\n};\n\nexport const isQueryV5 = (\n  packageJson: PackageJson | undefined,\n  queryClient:\n    | 'react-query'\n    | 'vue-query'\n    | 'svelte-query'\n    | 'angular-query'\n    | 'solid-query',\n) => {\n  // Angular Query is v5 only\n  if (queryClient === 'angular-query') {\n    return true;\n  }\n\n  const version = getPackageByQueryClient(packageJson, queryClient);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '5.0.0');\n};\n\nconst isQueryV6 = (\n  packageJson: PackageJson | undefined,\n  queryClient: 'react-query' | 'vue-query' | 'svelte-query' | 'solid-query',\n) => {\n  const version = getPackageByQueryClient(packageJson, queryClient);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '6.0.0');\n};\n\nexport const isQueryV5WithDataTagError = (\n  packageJson: PackageJson | undefined,\n  queryClient:\n    | 'react-query'\n    | 'vue-query'\n    | 'svelte-query'\n    | 'angular-query'\n    | 'solid-query',\n) => {\n  // Angular Query is v5 only and supports DataTag\n  if (queryClient === 'angular-query') {\n    return true;\n  }\n\n  const version = getPackageByQueryClient(packageJson, queryClient);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '5.62.0');\n};\n\nexport const isQueryV5WithInfiniteQueryOptionsError = (\n  packageJson: PackageJson | undefined,\n  queryClient:\n    | 'react-query'\n    | 'vue-query'\n    | 'svelte-query'\n    | 'angular-query'\n    | 'solid-query',\n) => {\n  // Angular Query is v5 only and supports infinite query options\n  if (queryClient === 'angular-query') {\n    return true;\n  }\n\n  const version = getPackageByQueryClient(packageJson, queryClient);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '5.80.0');\n};\n\nconst getPackageByQueryClient = (\n  packageJson: PackageJson | undefined,\n  queryClient:\n    | 'react-query'\n    | 'vue-query'\n    | 'svelte-query'\n    | 'angular-query'\n    | 'solid-query',\n) => {\n  switch (queryClient) {\n    case 'react-query': {\n      return (\n        packageJson?.dependencies?.['@tanstack/react-query'] ??\n        packageJson?.devDependencies?.['@tanstack/react-query'] ??\n        packageJson?.peerDependencies?.['@tanstack/react-query']\n      );\n    }\n    case 'svelte-query': {\n      return (\n        packageJson?.dependencies?.['@tanstack/svelte-query'] ??\n        packageJson?.devDependencies?.['@tanstack/svelte-query'] ??\n        packageJson?.peerDependencies?.['@tanstack/svelte-query']\n      );\n    }\n    case 'vue-query': {\n      return (\n        packageJson?.dependencies?.['@tanstack/vue-query'] ??\n        packageJson?.devDependencies?.['@tanstack/vue-query'] ??\n        packageJson?.peerDependencies?.['@tanstack/vue-query']\n      );\n    }\n    case 'angular-query': {\n      return (\n        packageJson?.dependencies?.['@tanstack/angular-query-experimental'] ??\n        packageJson?.devDependencies?.[\n          '@tanstack/angular-query-experimental'\n        ] ??\n        packageJson?.peerDependencies?.['@tanstack/angular-query-experimental']\n      );\n    }\n    case 'solid-query': {\n      return (\n        packageJson?.dependencies?.['@tanstack/solid-query'] ??\n        packageJson?.devDependencies?.['@tanstack/solid-query'] ??\n        packageJson?.peerDependencies?.['@tanstack/solid-query']\n      );\n    }\n  }\n};\n","import {\n  type GeneratorMutator,\n  type GetterParams,\n  type GetterQueryParam,\n  isObject,\n  OutputClient,\n  type OutputClientFunc,\n  OutputHttpClient,\n  pascal,\n  stringify,\n} from '@orval/core';\nimport { omitBy } from 'remeda';\n\nimport { getQueryArgumentsRequestType } from './client';\nimport { isVue } from './utils';\n\ntype QueryType = 'infiniteQuery' | 'query';\n\nexport const QueryType = {\n  INFINITE: 'infiniteQuery' as QueryType,\n  QUERY: 'query' as QueryType,\n  SUSPENSE_QUERY: 'suspenseQuery' as QueryType,\n  SUSPENSE_INFINITE: 'suspenseInfiniteQuery' as QueryType,\n};\n\nconst INFINITE_QUERY_PROPERTIES = new Set([\n  'getNextPageParam',\n  'getPreviousPageParam',\n]);\n\nexport const generateQueryOptions = ({\n  params,\n  options,\n  type,\n  outputClient,\n}: {\n  params: GetterParams;\n  options?: object | boolean;\n  type: QueryType;\n  outputClient: OutputClient | OutputClientFunc;\n}) => {\n  if (options === false) {\n    return '';\n  }\n\n  const queryConfig = isObject(options)\n    ? ` ${stringify(\n        omitBy(\n          options,\n          (_, key) =>\n            type !== QueryType.INFINITE &&\n            type !== QueryType.SUSPENSE_INFINITE &&\n            INFINITE_QUERY_PROPERTIES.has(key),\n        ),\n      )?.slice(1, -1)}`\n    : '';\n\n  if (params.length === 0 || isSuspenseQuery(type)) {\n    if (options) {\n      return `${queryConfig} ...queryOptions`;\n    }\n\n    return '...queryOptions';\n  }\n\n  return `${\n    !isObject(options) || !Object.hasOwn(options, 'enabled')\n      ? isVue(outputClient)\n        ? `enabled: computed(() => !!(${params\n            .map(({ name }) => `unref(${name})`)\n            .join(' && ')})),`\n        : `enabled: !!(${params.map(({ name }) => name).join(' && ')}),`\n      : ''\n  }${queryConfig} ...queryOptions`;\n};\n\nexport const isSuspenseQuery = (type: QueryType) => {\n  return [QueryType.SUSPENSE_INFINITE, QueryType.SUSPENSE_QUERY].includes(type);\n};\n\nexport const getQueryOptionsDefinition = ({\n  operationName,\n  mutator,\n  definitions,\n  type,\n  hasSvelteQueryV4,\n  hasQueryV5,\n  hasQueryV5WithInfiniteQueryOptionsError,\n  queryParams,\n  queryParam,\n  isReturnType,\n  initialData,\n  isAngularClient,\n}: {\n  operationName: string;\n  mutator?: GeneratorMutator;\n  definitions: string;\n  type?: QueryType;\n  hasSvelteQueryV4: boolean;\n  hasQueryV5: boolean;\n  hasQueryV5WithInfiniteQueryOptionsError: boolean;\n  queryParams?: GetterQueryParam;\n  queryParam?: string;\n  isReturnType: boolean;\n  initialData?: 'defined' | 'undefined';\n  isAngularClient: boolean;\n}) => {\n  const isMutatorHook = mutator?.isHook;\n  const prefix = !hasSvelteQueryV4 && !isAngularClient ? 'Use' : 'Create';\n  const partialOptions = !isReturnType && hasQueryV5;\n\n  if (type) {\n    const funcReturnType = `Awaited<ReturnType<${\n      isMutatorHook\n        ? `ReturnType<typeof use${pascal(operationName)}Hook>`\n        : `typeof ${operationName}`\n    }>>`;\n\n    const optionTypeInitialDataPostfix =\n      initialData && !isSuspenseQuery(type)\n        ? ` & Pick<\n        ${pascal(initialData)}InitialDataOptions<\n          ${funcReturnType},\n          TError,\n          ${funcReturnType}${\n            hasQueryV5 &&\n            (type === QueryType.INFINITE ||\n              type === QueryType.SUSPENSE_INFINITE) &&\n            queryParam &&\n            queryParams\n              ? `, QueryKey`\n              : ''\n          }\n        > , 'initialData'\n      >`\n        : '';\n    const optionType = `${prefix}${pascal(type)}Options<${funcReturnType}, TError, TData${\n      hasQueryV5 &&\n      (type === QueryType.INFINITE || type === QueryType.SUSPENSE_INFINITE) &&\n      queryParam &&\n      queryParams\n        ? hasQueryV5WithInfiniteQueryOptionsError\n          ? `, QueryKey, ${queryParams.schema.name}['${queryParam}']`\n          : `, ${funcReturnType}, QueryKey, ${queryParams.schema.name}['${queryParam}']`\n        : ''\n    }>`;\n    return `${partialOptions ? 'Partial<' : ''}${optionType}${\n      partialOptions ? '>' : ''\n    }${optionTypeInitialDataPostfix}`;\n  }\n\n  return `${prefix}MutationOptions<Awaited<ReturnType<${\n    isMutatorHook\n      ? `ReturnType<typeof use${pascal(operationName)}Hook>`\n      : `typeof ${operationName}`\n  }>>, TError,${definitions ? `{${definitions}}` : 'void'}, TContext>`;\n};\n\nexport const generateQueryArguments = ({\n  operationName,\n  definitions,\n  mutator,\n  isRequestOptions,\n  type,\n  hasSvelteQueryV4,\n  hasSvelteQueryV6,\n  hasQueryV5,\n  hasQueryV5WithInfiniteQueryOptionsError,\n  queryParams,\n  queryParam,\n  initialData,\n  httpClient,\n  isAngularClient,\n  forQueryOptions = false,\n  forAngularInject = false,\n}: {\n  operationName: string;\n  definitions: string;\n  mutator?: GeneratorMutator;\n  isRequestOptions: boolean;\n  type?: QueryType;\n  hasSvelteQueryV4: boolean;\n  hasSvelteQueryV6: boolean;\n  hasQueryV5: boolean;\n  hasQueryV5WithInfiniteQueryOptionsError: boolean;\n  queryParams?: GetterQueryParam;\n  queryParam?: string;\n  initialData?: 'defined' | 'undefined';\n  httpClient: OutputHttpClient;\n  isAngularClient: boolean;\n  /** When true, don't make options an Accessor for svelte-query v6 */\n  forQueryOptions?: boolean;\n  /** When true, wrap options type in getter alternative for Angular reactive support. */\n  forAngularInject?: boolean;\n}) => {\n  const definition = getQueryOptionsDefinition({\n    operationName,\n    mutator,\n    definitions,\n    type,\n    hasSvelteQueryV4,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    queryParams,\n    queryParam,\n    isReturnType: false,\n    initialData,\n    isAngularClient,\n  });\n\n  // Note: For Angular Query, http: HttpClient is added as the FIRST parameter\n  // directly in the query-generator.ts/mutation-generator.ts templates,\n  // not here, so that http comes before any optional params (avoiding TS1016).\n\n  if (!isRequestOptions) {\n    return `${type ? 'queryOptions' : 'mutationOptions'}${\n      initialData === 'defined' ? '' : '?'\n    }: ${definition}`;\n  }\n\n  const requestType = getQueryArgumentsRequestType(httpClient, mutator);\n\n  const isQueryRequired = initialData === 'defined';\n  const optionsType = `{ ${\n    type ? 'query' : 'mutation'\n  }${isQueryRequired ? '' : '?'}:${definition}, ${requestType}}`;\n\n  // For Angular inject* functions, allow options to be a getter for reactivity\n  if (forAngularInject) {\n    return `options${isQueryRequired ? '' : '?'}: ${optionsType} | (() => ${optionsType})\\n`;\n  }\n\n  return `options${isQueryRequired ? '' : '?'}: ${hasSvelteQueryV6 && !forQueryOptions ? '() => ' : ''}${optionsType}\\n`;\n};\n","import { OutputClient, type OutputClientFunc, pascal } from '@orval/core';\n\nimport { isSuspenseQuery, QueryType } from './query-options';\nimport { isAngular, isVue } from './utils';\n\nexport const generateQueryReturnType = ({\n  outputClient,\n  type,\n  isMutatorHook,\n  operationName,\n  hasVueQueryV4,\n  hasSvelteQueryV4,\n  hasQueryV5,\n  hasQueryV5WithDataTagError,\n  isInitialDataDefined,\n}: {\n  outputClient: OutputClient | OutputClientFunc;\n  type: (typeof QueryType)[keyof typeof QueryType];\n  isMutatorHook?: boolean;\n  operationName: string;\n  hasVueQueryV4: boolean;\n  hasSvelteQueryV4: boolean;\n  hasQueryV5: boolean;\n  hasQueryV5WithDataTagError: boolean;\n  isInitialDataDefined?: boolean;\n}) => {\n  switch (outputClient) {\n    case OutputClient.ANGULAR_QUERY: {\n      if (type !== QueryType.INFINITE && type !== QueryType.SUSPENSE_INFINITE) {\n        return `CreateQueryResult<TData, TError>`;\n      }\n      return `CreateInfiniteQueryResult<TData, TError>`;\n    }\n    case OutputClient.SOLID_QUERY: {\n      if (type !== QueryType.INFINITE && type !== QueryType.SUSPENSE_INFINITE) {\n        return `CreateQueryResult<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>` : 'QueryKey'} }`;\n      }\n      return `CreateInfiniteQueryResult<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>` : 'QueryKey'} }`;\n    }\n    case OutputClient.SVELTE_QUERY: {\n      if (!hasSvelteQueryV4) {\n        return `Use${pascal(type)}StoreResult<Awaited<ReturnType<${\n          isMutatorHook\n            ? `ReturnType<typeof use${pascal(operationName)}Hook>`\n            : `typeof ${operationName}`\n        }>>, TError, TData, QueryKey> & { queryKey: QueryKey }`;\n      }\n\n      return `Create${pascal(\n        type,\n      )}Result<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>` : 'QueryKey'} }`;\n    }\n    case OutputClient.VUE_QUERY: {\n      if (!hasVueQueryV4) {\n        return ` UseQueryReturnType<TData, TError, Use${pascal(\n          type,\n        )}Result<TData, TError>> & { queryKey: QueryKey }`;\n      }\n\n      if (type !== QueryType.INFINITE && type !== QueryType.SUSPENSE_INFINITE) {\n        return `UseQueryReturnType<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>` : 'QueryKey'} }`;\n      }\n\n      return `UseInfiniteQueryReturnType<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>` : 'QueryKey'} }`;\n    }\n    default: {\n      return ` ${\n        isInitialDataDefined && !isSuspenseQuery(type) ? 'Defined' : ''\n      }Use${pascal(type)}Result<TData, TError> & { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>` : 'QueryKey'} }`;\n    }\n  }\n};\n\nexport const generateMutatorReturnType = ({\n  outputClient,\n  dataType,\n  variableType,\n}: {\n  outputClient: OutputClient | OutputClientFunc;\n  dataType: string;\n  variableType: string;\n}) => {\n  if (outputClient === OutputClient.ANGULAR_QUERY) {\n    return `: CreateMutationResult<\n        Awaited<ReturnType<${dataType}>>,\n        TError,\n        ${variableType},\n        TContext\n      >`;\n  }\n  if (outputClient === OutputClient.REACT_QUERY) {\n    return `: UseMutationResult<\n        Awaited<ReturnType<${dataType}>>,\n        TError,\n        ${variableType},\n        TContext\n      >`;\n  }\n  if (outputClient === OutputClient.SOLID_QUERY) {\n    return `: CreateMutationResult<\n        Awaited<ReturnType<${dataType}>>,\n        TError,\n        ${variableType},\n        TContext\n      >`;\n  }\n  if (outputClient === OutputClient.SVELTE_QUERY) {\n    return `: CreateMutationResult<\n        Awaited<ReturnType<${dataType}>>,\n        TError,\n        ${variableType},\n        TContext\n      >`;\n  }\n  if (outputClient === OutputClient.VUE_QUERY) {\n    return `: UseMutationReturnType<\n        Awaited<ReturnType<${dataType}>>,\n        TError,\n        ${variableType},\n        TContext\n      >`;\n  }\n  return '';\n};\n\nexport const getQueryFnArguments = ({\n  hasQueryParam,\n  hasSignal,\n  hasSignalParam = false,\n}: {\n  hasQueryParam: boolean;\n  hasSignal: boolean;\n  hasSignalParam?: boolean;\n}) => {\n  if (!hasQueryParam && !hasSignal) {\n    return '';\n  }\n\n  // Rename AbortSignal if API has a param named \"signal\" to avoid conflict\n  const signalDestructure = hasSignalParam ? 'signal: querySignal' : 'signal';\n\n  if (hasQueryParam) {\n    if (hasSignal) {\n      return `{ ${signalDestructure}, pageParam }`;\n    }\n\n    return '{ pageParam }';\n  }\n\n  return `{ ${signalDestructure} }`;\n};\n\nexport const getQueryReturnStatement = ({\n  outputClient,\n  hasSvelteQueryV4,\n  hasSvelteQueryV6,\n  hasQueryV5,\n  hasQueryV5WithDataTagError,\n  queryResultVarName,\n  queryOptionsVarName,\n}: {\n  outputClient: OutputClient | OutputClientFunc;\n  hasSvelteQueryV4: boolean;\n  hasSvelteQueryV6: boolean;\n  hasQueryV5: boolean;\n  hasQueryV5WithDataTagError: boolean;\n  queryResultVarName: string;\n  queryOptionsVarName: string;\n}): string => {\n  if (isAngular(outputClient)) {\n    return `return ${queryResultVarName};`;\n  }\n\n  if (isVue(outputClient)) {\n    const queryKeyType = hasQueryV5\n      ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>`\n      : 'QueryKey';\n    return `${queryResultVarName}.queryKey = unref(${queryOptionsVarName}).queryKey as ${queryKeyType};\n\n  return ${queryResultVarName};`;\n  }\n\n  if (hasSvelteQueryV6) {\n    return `return ${queryResultVarName}`;\n  }\n  if (hasSvelteQueryV4) {\n    return `${queryResultVarName}.queryKey = ${queryOptionsVarName}.queryKey;\n\n  return ${queryResultVarName};`;\n  }\n\n  return `return { ...${queryResultVarName}, queryKey: ${queryOptionsVarName}.queryKey };`;\n};\n","import {\n  camel,\n  generateMutator,\n  type GeneratorMutator,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  GetterPropType,\n  type InvalidateTarget,\n  OutputClient,\n  type OutputClientFunc,\n  OutputHttpClient,\n  pascal,\n} from '@orval/core';\n\nimport {\n  getHooksOptionImplementation,\n  getMutationRequestArgs,\n  getQueryErrorType,\n} from './client';\nimport { getFrameworkPrefix } from './query-generator';\nimport {\n  generateQueryArguments,\n  getQueryOptionsDefinition,\n} from './query-options';\nimport { generateMutatorReturnType } from './return-types';\nimport { isAngular, isReact, isSolid, isSvelte } from './utils';\n\ntype NormalizedTarget = {\n  query: string;\n  params?: string[] | Record<string, string>;\n};\n\nconst normalizeTarget = (target: InvalidateTarget): NormalizedTarget =>\n  typeof target === 'string' ? { query: target } : target;\n\nconst serializeTarget = (target: NormalizedTarget): string =>\n  JSON.stringify({ query: target.query, params: target.params ?? [] });\n\nconst generateVariableRef = (varName: string): string => {\n  const parts = varName.split('.');\n  if (parts.length === 1) {\n    return `variables.${varName}`;\n  }\n  return `variables.${parts[0]}?.${parts.slice(1).join('?.')}`;\n};\n\nconst generateParamArgs = (\n  params: string[] | Record<string, string>,\n): string => {\n  if (Array.isArray(params)) {\n    return params.map((v) => generateVariableRef(v)).join(', ');\n  }\n  return Object.values(params)\n    .map((v) => generateVariableRef(v))\n    .join(', ');\n};\n\nconst generateInvalidateCall = (target: NormalizedTarget): string => {\n  const queryKeyFn = camel(`get-${target.query}-query-key`);\n  const args = target.params ? generateParamArgs(target.params) : '';\n  return `    queryClient.invalidateQueries({ queryKey: ${queryKeyFn}(${args}) });`;\n};\n\nexport interface MutationHookContext {\n  verbOptions: GeneratorVerbOptions;\n  options: GeneratorOptions;\n  outputClient: OutputClient | OutputClientFunc;\n  hasQueryV5: boolean;\n  hasQueryV5WithInfiniteQueryOptionsError: boolean;\n  hasSvelteQueryV4: boolean;\n  hasSvelteQueryV6: boolean;\n  isRequestOptions: boolean;\n  httpClient: OutputHttpClient;\n  doc: string;\n  isAngularHttp: boolean;\n}\n\nexport const generateMutationHook = async ({\n  verbOptions,\n  options,\n  outputClient,\n  hasQueryV5,\n  hasQueryV5WithInfiniteQueryOptionsError,\n  hasSvelteQueryV4,\n  hasSvelteQueryV6,\n  isRequestOptions,\n  httpClient,\n  doc,\n  isAngularHttp,\n}: MutationHookContext): Promise<{\n  implementation: string;\n  mutators: GeneratorMutator[] | undefined;\n}> => {\n  const {\n    operationName,\n    body,\n    props,\n    mutator,\n    response,\n    operationId,\n    override,\n  } = verbOptions;\n  const { route, context, output } = options;\n  const query = override.query;\n\n  const mutationOptionsMutator = query.mutationOptions\n    ? await generateMutator({\n        output,\n        mutator: query.mutationOptions,\n        name: `${operationName}MutationOptions`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const definitions = props\n    .map(({ definition, type }) =>\n      type === GetterPropType.BODY\n        ? mutator?.bodyTypeName\n          ? `data: ${mutator.bodyTypeName}<${body.definition}>`\n          : `data: ${body.definition}`\n        : definition,\n    )\n    .join(';');\n\n  const properties = props\n    .map(({ name, type }) => (type === GetterPropType.BODY ? 'data' : name))\n    .join(',');\n\n  const errorType = getQueryErrorType(\n    operationName,\n    response,\n    httpClient,\n    mutator,\n  );\n\n  const dataType = mutator?.isHook\n    ? `ReturnType<typeof use${pascal(operationName)}Hook>`\n    : `typeof ${operationName}`;\n\n  const isAngularClient = isAngular(outputClient);\n\n  const mutationOptionFnReturnType = getQueryOptionsDefinition({\n    operationName,\n    mutator,\n    definitions,\n    hasSvelteQueryV4,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    isReturnType: true,\n    isAngularClient,\n  });\n\n  const mutationArguments = generateQueryArguments({\n    operationName,\n    definitions,\n    mutator,\n    isRequestOptions,\n    hasSvelteQueryV4,\n    hasSvelteQueryV6,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    httpClient,\n    isAngularClient,\n  });\n\n  // Separate arguments for getMutationOptions function (includes http: HttpClient param for Angular)\n  const mutationArgumentsForOptions = generateQueryArguments({\n    operationName,\n    definitions,\n    mutator,\n    isRequestOptions,\n    hasSvelteQueryV4,\n    hasSvelteQueryV6,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    httpClient,\n    isAngularClient,\n    forQueryOptions: true,\n  });\n\n  const mutationOptionsFnName = camel(\n    mutationOptionsMutator || mutator?.isHook\n      ? `use-${operationName}-mutationOptions`\n      : `get-${operationName}-mutationOptions`,\n  );\n\n  const hooksOptionImplementation = getHooksOptionImplementation(\n    isRequestOptions,\n    httpClient,\n    camel(operationName),\n    mutator,\n  );\n\n  const invalidatesConfig = (query.mutationInvalidates ?? [])\n    .filter((rule) => rule.onMutations.includes(operationName))\n    .flatMap((rule) => rule.invalidates)\n    .map((t) => normalizeTarget(t));\n  const seenTargets = new Set<string>();\n  const uniqueInvalidates = invalidatesConfig.filter((target) => {\n    const key = serializeTarget(target);\n    if (seenTargets.has(key)) return false;\n    seenTargets.add(key);\n    return true;\n  });\n  const hasInvalidation =\n    uniqueInvalidates.length > 0 &&\n    (isAngularClient || isReact(outputClient) || isSvelte(outputClient));\n\n  // For Angular, add http: HttpClient as FIRST param (required, before optional params)\n  // This avoids TS1016 \"required param cannot follow optional param\"\n  const httpFirstParam =\n    isAngularHttp && (!mutator || mutator.hasSecondArg)\n      ? 'http: HttpClient, '\n      : '';\n\n  // For Angular/React mutations with invalidation, add queryClient as second required param\n  const queryClientParam = hasInvalidation ? 'queryClient: QueryClient, ' : '';\n\n  const mutationOptionsFn = `export const ${mutationOptionsFnName} = <TError = ${errorType},\n    TContext = unknown>(${httpFirstParam}${queryClientParam}${mutationArgumentsForOptions}): ${mutationOptionFnReturnType} => {\n\n${hooksOptionImplementation}\n\n      ${\n        mutator?.isHook\n          ? `const ${operationName} =  use${pascal(operationName)}Hook()`\n          : ''\n      }\n\n\n      const mutationFn: MutationFunction<Awaited<ReturnType<${dataType}>>, ${\n        definitions ? `{${definitions}}` : 'void'\n      }> = (${properties ? 'props' : ''}) => {\n          ${properties ? `const {${properties}} = props ?? {};` : ''}\n\n          return  ${operationName}(${isAngularHttp && !mutator ? 'http, ' : ''}${properties}${\n            properties ? ',' : ''\n          }${getMutationRequestArgs(isRequestOptions, httpClient, mutator)})\n        }\n\n${\n  hasInvalidation\n    ? isAngular(outputClient)\n      ? `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : 'void'}, onMutateResult: TContext, context: MutationFunctionContext) => {\n${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join('\\n')}\n    mutationOptions?.onSuccess?.(data, variables, onMutateResult, context);\n  };`\n      : isReact(outputClient)\n        ? `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : 'void'}, context: TContext) => {\n${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join('\\n')}\n    mutationOptions?.onSuccess?.(data, variables, context);\n  };`\n        : isSvelte(outputClient)\n          ? hasSvelteQueryV6\n            ? `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : 'void'}, onMutateResult: TContext, context: MutationFunctionContext) => {\n${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join('\\n')}\n    mutationOptions?.onSuccess?.(data, variables, onMutateResult, context);\n  };`\n            : `  const onSuccess = (data: Awaited<ReturnType<typeof ${operationName}>>, variables: ${definitions ? `{${definitions}}` : 'void'}, context: TContext | undefined) => {\n${uniqueInvalidates.map((t) => generateInvalidateCall(t)).join('\\n')}\n    mutationOptions?.onSuccess?.(data, variables, context);\n  };`\n          : ''\n    : ''\n}\n\n        ${\n          mutationOptionsMutator\n            ? `const customOptions = ${\n                mutationOptionsMutator.name\n              }({...mutationOptions, mutationFn}${\n                mutationOptionsMutator.hasSecondArg\n                  ? `, { url: \\`${route.replaceAll('/${', '/{')}\\` }`\n                  : ''\n              }${\n                mutationOptionsMutator.hasThirdArg\n                  ? `, { operationId: '${operationId}', operationName: '${operationName}' }`\n                  : ''\n              });`\n            : ''\n        }\n\n\n  return  ${\n    mutationOptionsMutator\n      ? 'customOptions'\n      : hasInvalidation\n        ? '{ mutationFn, onSuccess, ...mutationOptions }'\n        : '{ mutationFn, ...mutationOptions }'\n  }}`;\n\n  const operationPrefix = getFrameworkPrefix(\n    hasSvelteQueryV4,\n    isAngular(outputClient),\n    isSolid(outputClient),\n  );\n  const optionalQueryClientArgument = hasSvelteQueryV6\n    ? ', queryClient?: () => QueryClient'\n    : (hasQueryV5 || (isSvelte(outputClient) && hasInvalidation)) &&\n        !isAngular(outputClient)\n      ? ', queryClient?: QueryClient'\n      : '';\n\n  const mutationImplementation = `${mutationOptionsFnName}(${hasInvalidation ? (hasSvelteQueryV6 ? 'backupQueryClient, ' : `queryClient${isReact(outputClient) || isSvelte(outputClient) ? ' ?? backupQueryClient' : ''}, `) : ''}${\n    isRequestOptions ? 'options' : 'mutationOptions'\n  }${hasSvelteQueryV6 ? '?.()' : ''})`;\n\n  const mutationOptionsVarName = camel(`${operationName}-mutation-options`);\n\n  const implementation = `\n${mutationOptionsFn}\n\n    export type ${pascal(\n      operationName,\n    )}MutationResult = NonNullable<Awaited<ReturnType<${dataType}>>>\n    ${\n      body.definition\n        ? `export type ${pascal(operationName)}MutationBody = ${\n            mutator?.bodyTypeName\n              ? `${mutator.bodyTypeName}<${body.definition}>`\n              : body.definition\n          }`\n        : ''\n    }\n    export type ${pascal(operationName)}MutationError = ${errorType}\n\n    ${doc}export const ${camel(\n      `${operationPrefix}-${operationName}`,\n    )} = <TError = ${errorType},\n    TContext = unknown>(${mutationArguments} ${optionalQueryClientArgument})${generateMutatorReturnType(\n      {\n        outputClient,\n        dataType,\n        variableType: definitions ? `{${definitions}}` : 'void',\n      },\n    )} => {\n${\n  isAngular(outputClient)\n    ? isAngularHttp && (!mutator || mutator.hasSecondArg)\n      ? `      const http = inject(HttpClient);${hasInvalidation ? '\\n      const queryClient = inject(QueryClient);' : ''}\n      const ${mutationOptionsVarName} = ${mutationOptionsFnName}(http${hasInvalidation ? ', queryClient' : ''}${isRequestOptions ? ', options' : ', mutationOptions'});\n\n      return ${operationPrefix}Mutation(() => ${mutationOptionsVarName});`\n      : `      const ${mutationOptionsVarName} = ${mutationImplementation};\n\n      return ${operationPrefix}Mutation(() => ${mutationOptionsVarName});`\n    : `      ${(isReact(outputClient) || isSvelte(outputClient)) && hasInvalidation ? `const backupQueryClient = useQueryClient(${hasSvelteQueryV6 && optionalQueryClientArgument ? 'queryClient?.()' : ''});\\n      ` : ''}return ${operationPrefix}Mutation(${\n        hasSvelteQueryV6\n          ? `() => ({ ...${mutationImplementation} })${optionalQueryClientArgument ? `, queryClient` : ''}`\n          : isSvelte(outputClient)\n            ? mutationImplementation\n            : `${mutationImplementation}${optionalQueryClientArgument ? `, queryClient` : ''}`\n      });`\n}\n    }\n    `;\n\n  const mutators = mutationOptionsMutator\n    ? [mutationOptionsMutator]\n    : undefined;\n\n  return {\n    implementation,\n    mutators,\n  };\n};\n","import {\n  camel,\n  generateMutator,\n  type GeneratorMutator,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  getRouteAsArray,\n  type GetterParams,\n  type GetterProp,\n  type GetterProps,\n  GetterPropType,\n  type GetterQueryParam,\n  type GetterResponse,\n  jsDoc,\n  OutputClient,\n  type OutputClientFunc,\n  OutputHttpClient,\n  pascal,\n  toObjectString,\n  Verbs,\n} from '@orval/core';\n\nimport {\n  getHookOptions,\n  getHttpFunctionQueryProps,\n  getQueryErrorType,\n  getQueryOptions,\n} from './client';\nimport {\n  isQueryV5,\n  isQueryV5WithDataTagError,\n  isQueryV5WithInfiniteQueryOptionsError,\n  isSvelteQueryV3,\n  isSvelteQueryV6,\n  isVueQueryV3,\n} from './dependencies';\nimport { generateMutationHook } from './mutation-generator';\nimport {\n  generateQueryArguments,\n  generateQueryOptions,\n  getQueryOptionsDefinition,\n  QueryType,\n} from './query-options';\nimport {\n  generateQueryReturnType,\n  getQueryFnArguments,\n  getQueryReturnStatement,\n} from './return-types';\nimport {\n  getHasSignal,\n  getQueryTypeForFramework,\n  isAngular,\n  isSolid,\n  isVue,\n  vueUnRefParams,\n  vueWrapTypeWithMaybeRef,\n} from './utils';\n\n/**\n * Get framework-aware prefix for hook names and type definitions\n * @param hasSvelteQueryV4 - Whether using Svelte Query v4\n * @param isAngularClient - Whether using Angular client\n * @param isSolidClient - Whether using Solid Query client\n * @param capitalize - Whether to capitalize the prefix (for type definitions)\n * @returns The appropriate prefix string\n */\nexport const getFrameworkPrefix = (\n  hasSvelteQueryV4: boolean,\n  isAngularClient: boolean,\n  isSolidClient: boolean,\n  capitalize = false,\n): string => {\n  let prefix: string;\n\n  if (hasSvelteQueryV4 || isSolidClient) {\n    prefix = 'create';\n  } else if (isAngularClient) {\n    prefix = 'inject';\n  } else {\n    prefix = 'use';\n  }\n\n  return capitalize ? prefix.charAt(0).toUpperCase() + prefix.slice(1) : prefix;\n};\n\nconst generatePrefetch = ({\n  usePrefetch,\n  type,\n  useQuery,\n  useInfinite,\n  operationName,\n  mutator,\n  doc,\n  queryProps,\n  dataType,\n  errorType,\n  queryArguments,\n  queryOptionsVarName,\n  queryOptionsFnName,\n  queryProperties,\n  isRequestOptions,\n}: {\n  operationName: string;\n  mutator?: GeneratorMutator;\n  type: (typeof QueryType)[keyof typeof QueryType];\n  usePrefetch?: boolean;\n  useQuery?: boolean;\n  useInfinite?: boolean;\n  doc?: string;\n  queryProps: string;\n  dataType: string;\n  errorType: string;\n  queryArguments: string;\n  queryOptionsVarName: string;\n  queryOptionsFnName: string;\n  queryProperties: string;\n  isRequestOptions: boolean;\n}) => {\n  const shouldGeneratePrefetch =\n    usePrefetch &&\n    (type === QueryType.QUERY ||\n      type === QueryType.INFINITE ||\n      (type === QueryType.SUSPENSE_QUERY && !useQuery) ||\n      (type === QueryType.SUSPENSE_INFINITE && !useInfinite));\n\n  if (!shouldGeneratePrefetch) {\n    return '';\n  }\n\n  const prefetchType =\n    type === QueryType.QUERY || type === QueryType.SUSPENSE_QUERY\n      ? 'query'\n      : 'infinite-query';\n  const prefetchFnName = camel(`prefetch-${prefetchType}`);\n\n  if (mutator?.isHook) {\n    const prefetchVarName = camel(\n      `use-prefetch-${operationName}-${prefetchType}`,\n    );\n    return `${doc}export const ${prefetchVarName} = <TData = Awaited<ReturnType<${dataType}>>, TError = ${errorType}>(${queryProps} ${queryArguments}) => {\n  const queryClient = useQueryClient();\n  const ${queryOptionsVarName} = ${queryOptionsFnName}(${queryProperties}${\n    queryProperties ? ',' : ''\n  }${isRequestOptions ? 'options' : 'queryOptions'})\n  return useCallback(async (): Promise<QueryClient> => {\n    await queryClient.${prefetchFnName}(${queryOptionsVarName})\n    return queryClient;\n  },[queryClient, ${queryOptionsVarName}]);\n};\\n`;\n  } else {\n    const prefetchVarName = camel(`prefetch-${operationName}-${prefetchType}`);\n    return `${doc}export const ${prefetchVarName} = async <TData = Awaited<ReturnType<${dataType}>>, TError = ${errorType}>(\\n queryClient: QueryClient, ${queryProps} ${queryArguments}\\n  ): Promise<QueryClient> => {\n\n  const ${queryOptionsVarName} = ${queryOptionsFnName}(${queryProperties}${\n    queryProperties ? ',' : ''\n  }${isRequestOptions ? 'options' : 'queryOptions'})\n\n  await queryClient.${prefetchFnName}(${queryOptionsVarName});\n\n  return queryClient;\n}\\n`;\n  }\n};\n\nconst generateQueryImplementation = ({\n  queryOption: { name, queryParam, options, type, queryKeyFnName },\n  operationName,\n  queryProperties,\n  queryKeyProperties,\n  queryParams,\n  params,\n  props,\n  mutator,\n  queryOptionsMutator,\n  queryKeyMutator,\n  isRequestOptions,\n  response,\n  outputClient,\n  httpClient,\n  isExactOptionalPropertyTypes,\n  hasSignal,\n  route,\n  hasVueQueryV4,\n  hasSvelteQueryV4,\n  hasSvelteQueryV6,\n  hasQueryV5,\n  hasQueryV5WithDataTagError,\n  hasQueryV5WithInfiniteQueryOptionsError,\n  doc,\n  usePrefetch,\n  useQuery,\n  useInfinite,\n  useInvalidate,\n}: {\n  queryOption: {\n    name: string;\n    options?: object | boolean;\n    type: (typeof QueryType)[keyof typeof QueryType];\n    queryParam?: string;\n    queryKeyFnName: string;\n  };\n  isRequestOptions: boolean;\n  operationName: string;\n  queryProperties: string;\n  queryKeyProperties: string;\n  params: GetterParams;\n  props: GetterProps;\n  response: GetterResponse;\n  queryParams?: GetterQueryParam;\n  mutator?: GeneratorMutator;\n  queryOptionsMutator?: GeneratorMutator;\n  queryKeyMutator?: GeneratorMutator;\n  outputClient: OutputClient | OutputClientFunc;\n  httpClient: OutputHttpClient;\n  isExactOptionalPropertyTypes: boolean;\n  hasSignal: boolean;\n  route: string;\n  hasVueQueryV4: boolean;\n  hasSvelteQueryV4: boolean;\n  hasSvelteQueryV6: boolean;\n  hasQueryV5: boolean;\n  hasQueryV5WithDataTagError: boolean;\n  hasQueryV5WithInfiniteQueryOptionsError: boolean;\n  doc?: string;\n  usePrefetch?: boolean;\n  useQuery?: boolean;\n  useInfinite?: boolean;\n  useInvalidate?: boolean;\n}) => {\n  // Check if API has a param named \"signal\" to avoid conflict with AbortSignal\n  const hasSignalParam = props.some(\n    (prop: GetterProp) => prop.name === 'signal',\n  );\n\n  const queryPropDefinitions = toObjectString(props, 'definition');\n  const definedInitialDataQueryPropsDefinitions = toObjectString(\n    props.map((prop) => {\n      const regex = new RegExp(String.raw`^${prop.name}\\s*\\?:`);\n\n      if (!regex.test(prop.definition)) {\n        return prop;\n      }\n\n      const definitionWithUndefined = prop.definition.replace(\n        regex,\n        `${prop.name}: undefined | `,\n      );\n      return {\n        ...prop,\n        definition: definitionWithUndefined,\n      };\n    }),\n    'definition',\n  );\n  const queryProps = toObjectString(props, 'implementation');\n\n  // For Angular, allow params to be a getter function for reactive signal support\n  // E.g., injectListPets(() => ({ limit: this.rows() }))\n  const angularQueryPropsDefinitions = toObjectString(\n    props.map((prop) => {\n      // Add getter alternative: T becomes T | (() => T)\n      const getterType = prop.definition.replace(\n        /^(\\w+)(\\??): (.+)$/,\n        (\n          _match: string,\n          name: string,\n          optional: string,\n          type: string,\n        ): string =>\n          `${name}${optional}: ${type} | (() => ${type.replace(' | undefined', '')}${optional ? ' | undefined' : ''})`,\n      );\n      return { ...prop, definition: getterType };\n    }),\n    'definition',\n  );\n\n  const hasInfiniteQueryParam = queryParam && queryParams?.schema.name;\n\n  const isAngularHttp =\n    isAngular(outputClient) || httpClient === OutputHttpClient.ANGULAR;\n\n  let httpFunctionProps = queryParam\n    ? props\n        .map((param) => {\n          if (\n            param.type === GetterPropType.NAMED_PATH_PARAMS &&\n            !isVue(outputClient)\n          )\n            return param.destructured;\n          return param.name === 'params'\n            ? `{...${\n                isVue(outputClient) ? `unref(params)` : 'params'\n              }, '${queryParam}': pageParam || ${\n                isVue(outputClient)\n                  ? `unref(params)?.['${queryParam}']`\n                  : `params?.['${queryParam}']`\n              }}`\n            : param.name;\n        })\n        .join(',')\n    : getHttpFunctionQueryProps(\n        isVue(outputClient),\n        httpClient,\n        queryProperties,\n        isAngularHttp,\n        !!mutator,\n      );\n\n  // For Angular with infinite queries, we need to prefix with http\n  // Skip when custom mutator is used - mutator handles HTTP client internally\n  // http is required as first param so no assertion needed\n  if (queryParam && isAngularHttp && !mutator) {\n    httpFunctionProps = httpFunctionProps\n      ? `http, ${httpFunctionProps}`\n      : 'http';\n  }\n\n  const definedInitialDataReturnType = generateQueryReturnType({\n    outputClient,\n    type,\n    isMutatorHook: mutator?.isHook,\n    operationName,\n    hasVueQueryV4,\n    hasSvelteQueryV4,\n    hasQueryV5,\n    hasQueryV5WithDataTagError,\n    isInitialDataDefined: true,\n  });\n  const returnType = generateQueryReturnType({\n    outputClient,\n    type,\n    isMutatorHook: mutator?.isHook,\n    operationName,\n    hasVueQueryV4,\n    hasSvelteQueryV4,\n    hasQueryV5,\n    hasQueryV5WithDataTagError,\n  });\n\n  const errorType = getQueryErrorType(\n    operationName,\n    response,\n    httpClient,\n    mutator,\n  );\n\n  const dataType = mutator?.isHook\n    ? `ReturnType<typeof use${pascal(operationName)}Hook>`\n    : `typeof ${operationName}`;\n\n  const definedInitialDataQueryArguments = generateQueryArguments({\n    operationName,\n    mutator,\n    definitions: '',\n    isRequestOptions,\n    type,\n    hasSvelteQueryV4,\n    hasSvelteQueryV6,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    queryParams,\n    queryParam,\n    initialData: 'defined',\n    httpClient,\n    isAngularClient: isAngular(outputClient),\n  });\n  const undefinedInitialDataQueryArguments = generateQueryArguments({\n    operationName,\n    definitions: '',\n    mutator,\n    isRequestOptions,\n    type,\n    hasSvelteQueryV4,\n    hasSvelteQueryV6,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    queryParams,\n    queryParam,\n    initialData: 'undefined',\n    httpClient,\n    isAngularClient: isAngular(outputClient),\n  });\n  const queryArguments = generateQueryArguments({\n    operationName,\n    definitions: '',\n    mutator,\n    isRequestOptions,\n    type,\n    hasSvelteQueryV4,\n    hasSvelteQueryV6,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    queryParams,\n    queryParam,\n    httpClient,\n    isAngularClient: isAngular(outputClient),\n    forAngularInject: isAngular(outputClient),\n  });\n\n  // Separate arguments for getQueryOptions function (includes http: HttpClient param for Angular)\n  const queryArgumentsForOptions = generateQueryArguments({\n    operationName,\n    definitions: '',\n    mutator,\n    isRequestOptions,\n    type,\n    hasSvelteQueryV4,\n    hasSvelteQueryV6,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    queryParams,\n    queryParam,\n    httpClient,\n    isAngularClient: isAngular(outputClient),\n    forQueryOptions: true,\n  });\n\n  const queryOptions = getQueryOptions({\n    isRequestOptions,\n    isExactOptionalPropertyTypes,\n    mutator,\n    hasSignal,\n    httpClient,\n    hasSignalParam,\n  });\n\n  const hookOptions = getHookOptions({\n    isRequestOptions,\n    httpClient,\n    mutator,\n  });\n\n  const queryFnArguments = getQueryFnArguments({\n    hasQueryParam:\n      !!queryParam && props.some(({ type }) => type === 'queryParam'),\n    hasSignal,\n    hasSignalParam,\n  });\n\n  const queryOptionFnReturnType = getQueryOptionsDefinition({\n    operationName,\n    mutator,\n    definitions: '',\n    type,\n    hasSvelteQueryV4,\n    hasQueryV5,\n    hasQueryV5WithInfiniteQueryOptionsError,\n    queryParams,\n    queryParam,\n    isReturnType: true,\n    isAngularClient: isAngular(outputClient),\n  });\n\n  const queryOptionsImp = generateQueryOptions({\n    params,\n    options,\n    type,\n    outputClient,\n  });\n\n  const queryOptionsFnName = camel(\n    queryKeyMutator || queryOptionsMutator || mutator?.isHook\n      ? `use-${name}-queryOptions`\n      : `get-${name}-queryOptions`,\n  );\n\n  const queryOptionsVarName = isRequestOptions ? 'queryOptions' : 'options';\n\n  const hasParamReservedWord = props.some(\n    (prop: GetterProp) => prop.name === 'query',\n  );\n  const queryResultVarName = hasParamReservedWord ? '_query' : 'query';\n\n  const infiniteParam =\n    queryParams && queryParam\n      ? `, ${queryParams.schema.name}['${queryParam}']`\n      : '';\n  const TData =\n    hasQueryV5 &&\n    (type === QueryType.INFINITE || type === QueryType.SUSPENSE_INFINITE)\n      ? `InfiniteData<Awaited<ReturnType<${dataType}>>${infiniteParam}>`\n      : `Awaited<ReturnType<${dataType}>>`;\n\n  // For Angular, add http: HttpClient as FIRST param (required, before optional params)\n  // This avoids TS1016 \"required param cannot follow optional param\"\n  const httpFirstParam =\n    isAngularHttp && (!mutator || mutator.hasSecondArg)\n      ? 'http: HttpClient, '\n      : '';\n\n  const queryOptionsFn = `export const ${queryOptionsFnName} = <TData = ${TData}, TError = ${errorType}>(${httpFirstParam}${queryProps} ${queryArgumentsForOptions}) => {\n\n${hookOptions}\n\n  const queryKey =  ${\n    queryKeyMutator\n      ? `${queryKeyMutator.name}({ ${queryProperties} }${\n          queryKeyMutator.hasSecondArg\n            ? `, { url: \\`${route}\\`, queryOptions }`\n            : ''\n        });`\n      : `${\n          hasVueQueryV4 ? '' : 'queryOptions?.queryKey ?? '\n        }${queryKeyFnName}(${queryKeyProperties});`\n  }\n\n  ${\n    mutator?.isHook\n      ? `const ${operationName} =  use${pascal(operationName)}Hook();`\n      : ''\n  }\n\n    const queryFn: QueryFunction<Awaited<ReturnType<${\n      mutator?.isHook\n        ? `ReturnType<typeof use${pascal(operationName)}Hook>`\n        : `typeof ${operationName}`\n    }>>${\n      hasQueryV5 && hasInfiniteQueryParam\n        ? `, QueryKey, ${queryParams.schema.name}['${queryParam}']`\n        : ''\n    }> = (${queryFnArguments}) => ${operationName}(${httpFunctionProps}${\n      httpFunctionProps ? ', ' : ''\n    }${queryOptions});\n\n      ${\n        isVue(outputClient)\n          ? vueUnRefParams(\n              props.filter(\n                (prop) => prop.type === GetterPropType.NAMED_PATH_PARAMS,\n              ),\n            )\n          : ''\n      }\n\n      ${\n        queryOptionsMutator\n          ? `const customOptions = ${\n              queryOptionsMutator.name\n            }({...queryOptions, queryKey, queryFn}${\n              queryOptionsMutator.hasSecondArg ? `, { ${queryProperties} }` : ''\n            }${\n              queryOptionsMutator.hasThirdArg ? `, { url: \\`${route}\\` }` : ''\n            });`\n          : ''\n      }\n\n   return  ${\n     queryOptionsMutator\n       ? 'customOptions'\n       : `{ queryKey, queryFn, ${queryOptionsImp}}`\n   } as ${queryOptionFnReturnType} ${\n     isVue(outputClient) || isAngular(outputClient)\n       ? ''\n       : `& { queryKey: ${hasQueryV5 ? `DataTag<QueryKey, TData${hasQueryV5WithDataTagError ? ', TError' : ''}>` : 'QueryKey'} }`\n   }\n}`;\n  const operationPrefix = getFrameworkPrefix(\n    hasSvelteQueryV4,\n    isAngular(outputClient),\n    isSolid(outputClient),\n  );\n  const optionalQueryClientArgument = hasSvelteQueryV6\n    ? `, queryClient?: () => QueryClient`\n    : hasQueryV5 && !isAngular(outputClient)\n      ? ', queryClient?: QueryClient'\n      : '';\n\n  const queryHookName = camel(`${operationPrefix}-${name}`);\n\n  const overrideTypes = `\nexport function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\\n ${definedInitialDataQueryPropsDefinitions} ${definedInitialDataQueryArguments} ${optionalQueryClientArgument}\\n  ): ${definedInitialDataReturnType}\nexport function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\\n ${queryPropDefinitions} ${undefinedInitialDataQueryArguments} ${optionalQueryClientArgument}\\n  ): ${returnType}\nexport function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\\n ${queryPropDefinitions} ${queryArguments} ${optionalQueryClientArgument}\\n  ): ${returnType}`;\n\n  const prefetch = generatePrefetch({\n    usePrefetch,\n    type,\n    useQuery,\n    useInfinite,\n    operationName,\n    mutator,\n    queryProps,\n    dataType,\n    errorType,\n    queryArguments: queryArgumentsForOptions,\n    queryOptionsVarName,\n    queryOptionsFnName,\n    queryProperties,\n    isRequestOptions,\n    doc,\n  });\n\n  const shouldGenerateInvalidate =\n    useInvalidate &&\n    (type === QueryType.QUERY ||\n      type === QueryType.INFINITE ||\n      (type === QueryType.SUSPENSE_QUERY && !useQuery) ||\n      (type === QueryType.SUSPENSE_INFINITE && !useInfinite));\n  const invalidateFnName = camel(`invalidate-${name}`);\n\n  return `\n${queryOptionsFn}\n\nexport type ${pascal(\n    name,\n  )}QueryResult = NonNullable<Awaited<ReturnType<${dataType}>>>\nexport type ${pascal(name)}QueryError = ${errorType}\n\n${hasQueryV5 && OutputClient.REACT_QUERY === outputClient ? overrideTypes : ''}\n${doc}\nexport function ${queryHookName}<TData = ${TData}, TError = ${errorType}>(\\n ${\n    hasSvelteQueryV6\n      ? toObjectString(\n          props.map((p) => ({\n            ...p,\n            definition: p.definition.replace(':', ': () => '),\n          })),\n          'definition',\n        )\n      : isAngular(outputClient)\n        ? angularQueryPropsDefinitions\n        : queryProps\n  } ${queryArguments} ${optionalQueryClientArgument} \\n ): ${returnType} {\n\n  ${\n    hasSvelteQueryV6\n      ? ''\n      : isAngular(outputClient) && (!mutator || mutator.hasSecondArg)\n        ? `const http = inject(HttpClient);`\n        : isAngular(outputClient)\n          ? ''\n          : `const ${queryOptionsVarName} = ${queryOptionsFnName}(${queryProperties}${\n              queryProperties ? ',' : ''\n            }${isRequestOptions ? 'options' : 'queryOptions'})`\n  }\n\n  const ${queryResultVarName} = ${camel(\n    `${operationPrefix}-${isAngular(outputClient) || hasSvelteQueryV4 ? getQueryTypeForFramework(type) : type}`,\n  )}(${\n    isAngular(outputClient)\n      ? `() => {${\n          props.length > 0\n            ? `\n    // Resolve params if getter function (for signal reactivity)\n    ${props.map((p) => `const _${p.name} = typeof ${p.name} === 'function' ? ${p.name}() : ${p.name};`).join('\\n    ')}`\n            : ''\n        }\n    // Resolve options if getter function (for signal reactivity)\n    const _options = typeof ${isRequestOptions ? 'options' : 'queryOptions'} === 'function' ? ${isRequestOptions ? 'options' : 'queryOptions'}() : ${isRequestOptions ? 'options' : 'queryOptions'};\n    return ${queryOptionsFnName}(${!mutator || mutator.hasSecondArg ? 'http' : ''}${props.length > 0 ? `${!mutator || mutator.hasSecondArg ? ', ' : ''}${props.map((p) => `_${p.name}`).join(', ')}` : ''}, _options);\n  }`\n      : hasSvelteQueryV6\n        ? `() => ${queryOptionsFnName}(${toObjectString(\n            props.map((p) => ({\n              ...p,\n              name: p.default || !p.required ? `${p.name}?.()` : `${p.name}()`,\n            })),\n            'name',\n          )}${isRequestOptions ? 'options?.()' : 'queryOptions?.()'})`\n        : `${queryOptionsVarName}${!isAngular(outputClient) && optionalQueryClientArgument ? ', queryClient' : ''}`\n  }${hasSvelteQueryV6 ? `, queryClient` : ''}) as ${returnType};\n\n  ${getQueryReturnStatement({\n    outputClient,\n    hasSvelteQueryV4,\n    hasSvelteQueryV6,\n    hasQueryV5,\n    hasQueryV5WithDataTagError,\n    queryResultVarName,\n    queryOptionsVarName,\n  })}\n}\\n\n${prefetch}\n${\n  shouldGenerateInvalidate\n    ? `${doc}export const ${invalidateFnName} = async (\\n queryClient: QueryClient, ${queryProps} options?: InvalidateOptions\\n  ): Promise<QueryClient> => {\n\n  await queryClient.invalidateQueries({ queryKey: ${queryKeyFnName}(${queryKeyProperties}) }, options);\n\n  return queryClient;\n}\\n`\n    : ''\n}\n`;\n};\n\nexport const generateQueryHook = async (\n  verbOptions: GeneratorVerbOptions,\n  options: GeneratorOptions,\n  outputClient: OutputClient | OutputClientFunc,\n) => {\n  const {\n    queryParams,\n    operationName,\n    body,\n    props: _props,\n    verb,\n    params,\n    override,\n    mutator,\n    response,\n    operationId,\n    summary,\n    deprecated,\n  } = verbOptions;\n  const {\n    route,\n    override: { operations },\n    context,\n    output,\n  } = options;\n  let props = _props;\n  if (isVue(outputClient)) {\n    props = vueWrapTypeWithMaybeRef(_props);\n  }\n  const query = override.query;\n  const isRequestOptions = override.requestOptions !== false;\n  const operationQueryOptions = operations[operationId]?.query;\n  const isExactOptionalPropertyTypes =\n    !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;\n  const queryVersion = query.version;\n\n  const hasVueQueryV4 =\n    OutputClient.VUE_QUERY === outputClient &&\n    (!isVueQueryV3(context.output.packageJson) || queryVersion === 4);\n  const hasSvelteQueryV4 =\n    OutputClient.SVELTE_QUERY === outputClient &&\n    (!isSvelteQueryV3(context.output.packageJson) || queryVersion === 4);\n  const hasSvelteQueryV6 =\n    OutputClient.SVELTE_QUERY === outputClient &&\n    isSvelteQueryV6(context.output.packageJson);\n\n  const hasQueryV5 =\n    queryVersion === 5 ||\n    isQueryV5(\n      context.output.packageJson,\n      outputClient as\n        | 'react-query'\n        | 'vue-query'\n        | 'svelte-query'\n        | 'angular-query',\n    );\n\n  const hasQueryV5WithDataTagError =\n    queryVersion === 5 ||\n    isQueryV5WithDataTagError(\n      context.output.packageJson,\n      outputClient as\n        | 'react-query'\n        | 'vue-query'\n        | 'svelte-query'\n        | 'angular-query',\n    );\n\n  const hasQueryV5WithInfiniteQueryOptionsError =\n    queryVersion === 5 ||\n    isQueryV5WithInfiniteQueryOptionsError(\n      context.output.packageJson,\n      outputClient as\n        | 'react-query'\n        | 'vue-query'\n        | 'svelte-query'\n        | 'angular-query',\n    );\n\n  const httpClient = context.output.httpClient;\n  const isAngularHttp =\n    isAngular(outputClient) || httpClient === OutputHttpClient.ANGULAR;\n  const doc = jsDoc({ summary, deprecated });\n\n  let implementation = '';\n  let mutators: GeneratorMutator[] | undefined;\n\n  // Allows operationQueryOptions (which is the Orval config override for the operationId)\n  // to override non-GET verbs\n  const hasOperationQueryOption = [\n    operationQueryOptions?.useQuery,\n    operationQueryOptions?.useSuspenseQuery,\n    operationQueryOptions?.useInfinite,\n    operationQueryOptions?.useSuspenseInfiniteQuery,\n  ].some(Boolean);\n\n  let isQuery =\n    (Verbs.GET === verb &&\n      [\n        override.query.useQuery,\n        override.query.useSuspenseQuery,\n        override.query.useInfinite,\n        override.query.useSuspenseInfiniteQuery,\n      ].some(Boolean)) ||\n    hasOperationQueryOption;\n\n  let isMutation = override.query.useMutation && verb !== Verbs.GET;\n\n  if (operationQueryOptions?.useMutation !== undefined) {\n    isMutation = operationQueryOptions.useMutation;\n  }\n\n  // If both query and mutation are true for a non-GET operation, prioritize query\n  if (verb !== Verbs.GET && isQuery) {\n    isMutation = false;\n  }\n\n  // If both query and mutation are true for a GET operation, prioritize mutation\n  if (verb === Verbs.GET && isMutation) {\n    isQuery = false;\n  }\n\n  if (isQuery) {\n    const queryKeyMutator = query.queryKey\n      ? await generateMutator({\n          output,\n          mutator: query.queryKey,\n          name: `${operationName}QueryKey`,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n    const queryOptionsMutator = query.queryOptions\n      ? await generateMutator({\n          output,\n          mutator: query.queryOptions,\n          name: `${operationName}QueryOptions`,\n          workspace: context.workspace,\n          tsconfig: context.output.tsconfig,\n        })\n      : undefined;\n\n    const queryProperties = props\n      .map((param) => {\n        if (\n          param.type === GetterPropType.NAMED_PATH_PARAMS &&\n          !isVue(outputClient)\n        )\n          return param.destructured;\n        return param.type === GetterPropType.BODY\n          ? body.implementation\n          : param.name;\n      })\n      .join(',');\n\n    const queryKeyProperties = props\n      .filter((prop) => prop.type !== GetterPropType.HEADER)\n      .map((param) => {\n        if (\n          param.type === GetterPropType.NAMED_PATH_PARAMS &&\n          !isVue(outputClient)\n        )\n          return param.destructured;\n        return param.type === GetterPropType.BODY\n          ? body.implementation\n          : param.name;\n      })\n      .join(',');\n\n    const queries = [\n      ...(query.useInfinite || operationQueryOptions?.useInfinite\n        ? [\n            {\n              name: camel(`${operationName}-infinite`),\n              options: query.options,\n              type: QueryType.INFINITE,\n              queryParam: query.useInfiniteQueryParam,\n              queryKeyFnName: camel(`get-${operationName}-infinite-query-key`),\n            },\n          ]\n        : []),\n      ...(query.useQuery || operationQueryOptions?.useQuery\n        ? [\n            {\n              name: operationName,\n              options: query.options,\n              type: QueryType.QUERY,\n              queryKeyFnName: camel(`get-${operationName}-query-key`),\n            },\n          ]\n        : []),\n      ...(query.useSuspenseQuery || operationQueryOptions?.useSuspenseQuery\n        ? [\n            {\n              name: camel(`${operationName}-suspense`),\n              options: query.options,\n              type: QueryType.SUSPENSE_QUERY,\n              queryKeyFnName: camel(`get-${operationName}-query-key`),\n            },\n          ]\n        : []),\n      ...(query.useSuspenseInfiniteQuery ||\n      operationQueryOptions?.useSuspenseInfiniteQuery\n        ? [\n            {\n              name: camel(`${operationName}-suspense-infinite`),\n              options: query.options,\n              type: QueryType.SUSPENSE_INFINITE,\n              queryParam: query.useInfiniteQueryParam,\n              queryKeyFnName: camel(`get-${operationName}-infinite-query-key`),\n            },\n          ]\n        : []),\n    ];\n\n    const uniqueQueryOptionsByKeys = queries.filter(\n      (obj, index, self) =>\n        index ===\n        self.findIndex((t) => t.queryKeyFnName === obj.queryKeyFnName),\n    );\n\n    implementation += `\n${\n  queryKeyMutator\n    ? ''\n    : uniqueQueryOptionsByKeys.reduce((acc, queryOption) => {\n        const makeOptionalParam = (impl: string) => {\n          if (impl.includes('=')) return impl;\n          return impl.replace(/^(\\w+):\\s*/, '$1?: ');\n        };\n\n        const queryKeyProps = toObjectString(\n          props\n            .filter((prop) => prop.type !== GetterPropType.HEADER)\n            .map((prop) => ({\n              ...prop,\n              implementation:\n                prop.type === GetterPropType.PARAM ||\n                prop.type === GetterPropType.NAMED_PATH_PARAMS\n                  ? prop.implementation\n                  : makeOptionalParam(prop.implementation),\n            })),\n          'implementation',\n        );\n\n        const routeString =\n          isVue(outputClient) || override.query.shouldSplitQueryKey\n            ? getRouteAsArray(route) // Note: this is required for reactivity to work, we will lose it if route params are converted into string, only as array they will be tracked // TODO: add tests for this\n            : `\\`${route}\\``;\n\n        // Use operation ID as query key if enabled, otherwise use route string\n        const queryKeyIdentifier = override.query.useOperationIdAsQueryKey\n          ? `\"${operationName}\"`\n          : routeString;\n\n        // Use all params in query key when useOperationIdAsQueryKey=true, otherwise use only query param\n        // All params sorted by required first\n        const queryKeyParams = props\n          .filter((p) =>\n            override.query.useOperationIdAsQueryKey\n              ? true\n              : p.type === GetterPropType.QUERY_PARAM,\n          )\n          .toSorted((a) => (a.required ? -1 : 1))\n          .map((p) => `...(${p.name} ? [${p.name}] : [])`)\n          .join(', ');\n\n        // Note: do not unref() params in Vue - this will make key lose reactivity\n        const queryKeyFn = `\n${override.query.shouldExportQueryKey ? 'export ' : ''}const ${queryOption.queryKeyFnName} = (${queryKeyProps}) => {\n    return [\n    ${[\n      queryOption.type === QueryType.INFINITE ||\n      queryOption.type === QueryType.SUSPENSE_INFINITE\n        ? `'infinite'`\n        : '',\n      queryKeyIdentifier,\n      queryKeyParams,\n      body.implementation,\n    ]\n      .filter((x) => !!x)\n      .join(', ')}\n    ] as const;\n    }\n`;\n        return acc + queryKeyFn;\n      }, '')\n}`;\n\n    implementation += `\n    ${queries.reduce((acc, queryOption) => {\n      return (\n        acc +\n        generateQueryImplementation({\n          queryOption,\n          operationName,\n          queryProperties,\n          queryKeyProperties,\n          params,\n          props,\n          mutator,\n          isRequestOptions,\n          queryParams,\n          response,\n          outputClient,\n          httpClient,\n          isExactOptionalPropertyTypes,\n          hasSignal: getHasSignal({\n            overrideQuerySignal: override.query.signal,\n          }),\n          queryOptionsMutator,\n          queryKeyMutator,\n          route,\n          hasVueQueryV4,\n          hasSvelteQueryV4,\n          hasSvelteQueryV6,\n          hasQueryV5,\n          hasQueryV5WithDataTagError,\n          hasQueryV5WithInfiniteQueryOptionsError,\n          doc,\n          usePrefetch: query.usePrefetch,\n          useQuery: query.useQuery,\n          useInfinite: query.useInfinite,\n          useInvalidate: query.useInvalidate,\n        })\n      );\n    }, '')}\n`;\n\n    mutators =\n      queryOptionsMutator || queryKeyMutator\n        ? [\n            ...(queryOptionsMutator ? [queryOptionsMutator] : []),\n            ...(queryKeyMutator ? [queryKeyMutator] : []),\n          ]\n        : undefined;\n  }\n\n  if (isMutation) {\n    const mutationResult = await generateMutationHook({\n      verbOptions: { ...verbOptions, props },\n      options,\n      outputClient,\n      hasQueryV5,\n      hasQueryV5WithInfiniteQueryOptionsError,\n      hasSvelteQueryV4,\n      hasSvelteQueryV6,\n      isRequestOptions,\n      httpClient,\n      doc,\n      isAngularHttp,\n    });\n\n    implementation += mutationResult.implementation;\n    mutators = mutationResult.mutators\n      ? [...(mutators ?? []), ...mutationResult.mutators]\n      : mutators;\n  }\n\n  return {\n    implementation,\n    mutators,\n  };\n};\n","import {\n  type ClientBuilder,\n  type ClientDependenciesBuilder,\n  type ClientHeaderBuilder,\n  generateVerbImports,\n  mergeDeep,\n  type NormalizedOutputOptions,\n  type QueryOptions,\n} from '@orval/core';\n\nimport { generateQueryRequestFunction, getQueryHeader } from './client';\nimport {\n  getAngularQueryDependencies,\n  getReactQueryDependencies,\n  getSolidQueryDependencies,\n  getSvelteQueryDependencies,\n  getVueQueryDependencies,\n} from './dependencies';\nimport { generateQueryHook } from './query-generator';\nimport { isVue, normalizeQueryOptions } from './utils';\n\nexport {\n  getAngularQueryDependencies,\n  getReactQueryDependencies,\n  getSolidQueryDependencies,\n  getSvelteQueryDependencies,\n  getVueQueryDependencies,\n} from './dependencies';\n\nexport const generateQueryHeader: ClientHeaderBuilder = (params) => {\n  return `${\n    params.hasAwaitedType\n      ? ''\n      : `type AwaitedInput<T> = PromiseLike<T> | T;\\n\n      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;\\n\\n`\n  }\n${\n  params.isRequestOptions && params.isMutator\n    ? `type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\\n\\n`\n    : ''\n}\n${getQueryHeader(params)}\n`;\n};\n\nexport const generateQuery: ClientBuilder = async (\n  verbOptions,\n  options,\n  outputClient,\n) => {\n  const imports = generateVerbImports(verbOptions);\n  const functionImplementation = generateQueryRequestFunction(\n    verbOptions,\n    options,\n    isVue(outputClient),\n  );\n  const { implementation: hookImplementation, mutators } =\n    await generateQueryHook(verbOptions, options, outputClient);\n\n  return {\n    implementation: `${functionImplementation}\\n\\n${hookImplementation}`,\n    imports,\n    mutators,\n  };\n};\n\nconst dependenciesBuilder: Record<\n  | 'react-query'\n  | 'vue-query'\n  | 'svelte-query'\n  | 'angular-query'\n  | 'solid-query',\n  ClientDependenciesBuilder\n> = {\n  'react-query': getReactQueryDependencies,\n  'vue-query': getVueQueryDependencies,\n  'svelte-query': getSvelteQueryDependencies,\n  'angular-query': getAngularQueryDependencies,\n  'solid-query': getSolidQueryDependencies,\n};\n\nexport const builder =\n  ({\n    type = 'react-query',\n    options: queryOptions,\n    output,\n  }: {\n    type?:\n      | 'react-query'\n      | 'vue-query'\n      | 'svelte-query'\n      | 'angular-query'\n      | 'solid-query';\n    options?: QueryOptions;\n    output?: NormalizedOutputOptions;\n  } = {}) =>\n  () => {\n    const client: ClientBuilder = (verbOptions, options, outputClient) => {\n      if (\n        options.override.useNamedParameters &&\n        (type === 'vue-query' || outputClient === 'vue-query')\n      ) {\n        throw new Error(\n          `vue-query client does not support named parameters, and had broken reactivity previously, please set useNamedParameters to false; See for context: https://github.com/orval-labs/orval/pull/931#issuecomment-1752355686`,\n        );\n      }\n\n      if (queryOptions) {\n        const normalizedQueryOptions = normalizeQueryOptions(\n          queryOptions,\n          options.context.workspace,\n        );\n        verbOptions.override.query = mergeDeep(\n          normalizedQueryOptions,\n          verbOptions.override.query,\n        );\n        options.override.query = mergeDeep(\n          normalizedQueryOptions,\n          verbOptions.override.query,\n        );\n      }\n      return generateQuery(verbOptions, options, outputClient, output);\n    };\n\n    return {\n      client: client,\n      header: generateQueryHeader,\n      dependencies: dependenciesBuilder[type],\n    };\n  };\n\nexport default builder;\n"],"mappings":"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Aa,GAAG,kBAAkB,SACzC,KAAK,WAAW,kBACf,MAAM,aAAa,GACf,oBAAoB,WAAW,MAC/B,aAAa,WAAW,IAC7B,KACD,MAAM;GACV,CACD,KAAK,IAAI,GACZ,0BACE,MAAM,aAAa,EACnB,YACA,iBACA,eACA,CAAC,CAAC,QACH;AAKL,KAAI,cAAc,iBAAiB,CAAC,QAClC,qBAAoB,oBAChB,SAAS,sBACT;CAGN,MAAM,+BAA+B,wBAAwB;EAC3D;EACA;EACA,eAAe,SAAS;EACxB;EACA;EACA;EACA;EACA;EACA,sBAAsB;EACvB,CAAC;CACF,MAAM,aAAa,wBAAwB;EACzC;EACA;EACA,eAAe,SAAS;EACxB;EACA;EACA;EACA;EACA;EACD,CAAC;CAEF,MAAM,YAAY,kBAChB,eACA,UACA,YACA,QACD;CAED,MAAM,WAAW,SAAS,SACtB,wBAAwB,OAAO,cAAc,CAAC,SAC9C,UAAU;CAEd,MAAM,mCAAmC,uBAAuB;EAC9D;EACA;EACA,aAAa;EACb;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,aAAa;EACb;EACA,iBAAiB,UAAU,aAAa;EACzC,CAAC;CACF,MAAM,qCAAqC,uBAAuB;EAChE;EACA,aAAa;EACb;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,aAAa;EACb;EACA,iBAAiB,UAAU,aAAa;EACzC,CAAC;CACF,MAAM,iBAAiB,uBAAuB;EAC5C;EACA,aAAa;EACb;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,iBAAiB,UAAU,aAAa;EACxC,kBAAkB,UAAU,aAAa;EAC1C,CAAC;CAGF,MAAM,2BAA2B,uBAAuB;EACtD;EACA,aAAa;EACb;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,iBAAiB,UAAU,aAAa;EACxC,iBAAiB;EAClB,CAAC;CAEF,MAAM,eAAe,gBAAgB;EACnC;EACA;EACA;EACA;EACA;EACA;EACD,CAAC;CAEF,MAAM,cAAc,eAAe;EACjC;EACA;EACA;EACD,CAAC;CAEF,MAAM,mBAAmB,oBAAoB;EAC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"}