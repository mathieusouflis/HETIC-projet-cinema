{"version":3,"file":"index.mjs","names":["HONO_DEPENDENCIES: GeneratorDependency[]","ret: string","getHonoHeader: ClientHeaderBuilder","handlers: string","tag","getHonoFooter: ClientFooterBuilder","generateHono: ClientBuilder","grouped: Record<string, GeneratorVerbOptions[]>","handlerPath","imports: GeneratorImport[]","path","zods","content","zodPath","context","ImportHandlersImplementation: string","generateExtraFiles: ClientExtraFilesBuilder","schemaModule: string","honoClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/route.ts","../src/index.ts"],"sourcesContent":["import { sanitize } from '@orval/core';\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = /([^{]*){?([\\w*_-]*)}?(.*)/.exec(path);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(matches[2], {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  return hasParam(path) ? `${prev}:${param}${next}` : `${prev}${param}${next}`;\n};\n\nexport const getRoute = (route: string) => {\n  const splittedRoute = route.split('/');\n\n  let acc = '';\n  for (const [i, path] of splittedRoute.entries()) {\n    if (!path && i === 0) continue;\n\n    acc += path.includes('{') ? `/${getRoutePath(path)}` : `/${path}`;\n  }\n\n  return acc;\n};\n","import {\n  camel,\n  type ClientBuilder,\n  type ClientExtraFilesBuilder,\n  type ClientFooterBuilder,\n  type ClientGeneratorsBuilder,\n  type ClientHeaderBuilder,\n  type ContextSpec,\n  generateMutatorImports,\n  type GeneratorDependency,\n  type GeneratorImport,\n  type GeneratorVerbOptions,\n  getFileInfo,\n  getOrvalGeneratedTypes,\n  getParamsInPath,\n  isObject,\n  jsDoc,\n  kebab,\n  type NormalizedMutator,\n  type NormalizedOutputOptions,\n  type OpenApiInfoObject,\n  pascal,\n  sanitize,\n  upath,\n} from '@orval/core';\nimport { generateZod } from '@orval/zod';\nimport fs from 'fs-extra';\n\nimport { getRoute } from './route';\n\nconst ZVALIDATOR_SOURCE = fs\n  .readFileSync(upath.join(import.meta.dirname, 'zValidator.ts'))\n  .toString('utf8');\n\nconst HONO_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'Hono',\n        values: true,\n      },\n      {\n        name: 'Context',\n      },\n      {\n        name: 'Env',\n      },\n    ],\n    dependency: 'hono',\n  },\n];\n\n/**\n * generateModuleSpecifier generates the specifier that _from_ would use to\n * import _to_. This is syntactical and does not validate the paths.\n *\n * @param from The filesystem path to the importer.\n * @param to If a filesystem path, it and _from_ must be use the same frame of\n * reference, such as process.cwd() or both be absolute. If only one is\n * absolute, the other must be relative to process.cwd().\n *\n * Otherwise, treated as a package name and returned directly.\n *\n * @return A module specifier that can be used at _from_ to import _to_. It is\n * extensionless to conform with the rest of orval.\n */\nconst generateModuleSpecifier = (from: string, to: string) => {\n  if (to.startsWith('.') || upath.isAbsolute(to)) {\n    // One of \"/foo/bar\", \"./foo/bar\", \"../foo/bar\", etc.\n    let ret: string;\n    ret = upath.relativeSafe(upath.dirname(from), to);\n    ret = ret.replace(/\\.ts$/, '');\n    ret = ret.replaceAll(upath.separator, '/');\n    return ret;\n  }\n\n  // Not a relative or absolute file path. Import as-is.\n  return to;\n};\n\nexport const getHonoDependencies = () => HONO_DEPENDENCIES;\n\nexport const getHonoHeader: ClientHeaderBuilder = ({\n  verbOptions,\n  output,\n  tag,\n  clientImplementation,\n}) => {\n  const targetInfo = getFileInfo(output.target);\n\n  let handlers: string;\n\n  const importHandlers = Object.values(verbOptions).filter((verbOption) =>\n    clientImplementation.includes(`${verbOption.operationName}Handlers`),\n  );\n\n  if (output.override.hono.handlers) {\n    const handlerFileInfo = getFileInfo(output.override.hono.handlers);\n    handlers = importHandlers\n      .map((verbOption) => {\n        const isTagMode =\n          output.mode === 'tags' || output.mode === 'tags-split';\n        const tag = kebab(verbOption.tags[0] ?? 'default');\n\n        const handlersPath = upath.relativeSafe(\n          upath.join(targetInfo.dirname, isTagMode ? tag : ''),\n          upath.join(handlerFileInfo.dirname, `./${verbOption.operationName}`),\n        );\n\n        return `import { ${verbOption.operationName}Handlers } from '${handlersPath}';`;\n      })\n      .join('\\n');\n  } else {\n    const importHandlerNames = importHandlers\n      .map((verbOption) => ` ${verbOption.operationName}Handlers`)\n      .join(`, \\n`);\n\n    handlers = `import {\\n${importHandlerNames}\\n} from './${tag ?? targetInfo.filename}.handlers';`;\n  }\n\n  return `${handlers}\\n\\n\nconst app = new Hono()\\n\\n`;\n};\n\nexport const getHonoFooter: ClientFooterBuilder = () => 'export default app';\n\nconst generateHonoRoute = (\n  { operationName, verb }: GeneratorVerbOptions,\n  pathRoute: string,\n) => {\n  const path = getRoute(pathRoute);\n\n  return `\napp.${verb.toLowerCase()}('${path}',...${operationName}Handlers)`;\n};\n\nexport const generateHono: ClientBuilder = (verbOptions, options) => {\n  if (options.override.hono.compositeRoute) {\n    return {\n      implementation: '',\n      imports: [],\n    };\n  }\n\n  const routeImplementation = generateHonoRoute(verbOptions, options.pathRoute);\n\n  return {\n    implementation: routeImplementation ? `${routeImplementation}\\n\\n` : '',\n    imports: [\n      ...verbOptions.params.flatMap((param) => param.imports),\n      ...verbOptions.body.imports,\n      ...(verbOptions.queryParams\n        ? [\n            {\n              name: verbOptions.queryParams.schema.name,\n            },\n          ]\n        : []),\n    ],\n  };\n};\n\n/**\n * getHonoHandlers generates TypeScript code for the given verbs and reports\n * whether the code requires zValidator.\n */\nconst getHonoHandlers = (\n  ...opts: {\n    handlerName: string;\n    contextTypeName: string;\n    verbOption: GeneratorVerbOptions;\n    validator: boolean | 'hono' | NormalizedMutator;\n  }[]\n): [\n  /** The combined TypeScript handler code snippets. */\n  handlerCode: string,\n  /** Whether any of the handler code snippets requires importing zValidator. */\n  hasZValidator: boolean,\n] => {\n  let code = '';\n  let hasZValidator = false;\n\n  for (const { handlerName, contextTypeName, verbOption, validator } of opts) {\n    let currentValidator = '';\n\n    if (validator) {\n      const pascalOperationName = pascal(verbOption.operationName);\n\n      if (verbOption.headers) {\n        currentValidator += `zValidator('header', ${pascalOperationName}Header),\\n`;\n      }\n      if (verbOption.params.length > 0) {\n        currentValidator += `zValidator('param', ${pascalOperationName}Params),\\n`;\n      }\n      if (verbOption.queryParams) {\n        currentValidator += `zValidator('query', ${pascalOperationName}QueryParams),\\n`;\n      }\n      if (verbOption.body.definition) {\n        currentValidator += `zValidator('json', ${pascalOperationName}Body),\\n`;\n      }\n      if (\n        validator !== 'hono' &&\n        verbOption.response.originalSchema?.['200']?.content?.[\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          'application/json'\n        ]\n      ) {\n        currentValidator += `zValidator('response', ${pascalOperationName}Response),\\n`;\n      }\n    }\n\n    code += `\nexport const ${handlerName} = factory.createHandlers(\n${currentValidator}async (c: ${contextTypeName}) => {\n\n  },\n);`;\n\n    hasZValidator ||= currentValidator !== '';\n  }\n\n  return [code, hasZValidator];\n};\n\nconst getZvalidatorImports = (\n  verbOptions: GeneratorVerbOptions[],\n  importPath: string,\n  isHonoValidator: boolean,\n) => {\n  const specifiers = [];\n\n  for (const {\n    operationName,\n    headers,\n    params,\n    queryParams,\n    body,\n    response,\n  } of verbOptions) {\n    const pascalOperationName = pascal(operationName);\n\n    if (headers) {\n      specifiers.push(`${pascalOperationName}Header`);\n    }\n\n    if (params.length > 0) {\n      specifiers.push(`${pascalOperationName}Params`);\n    }\n\n    if (queryParams) {\n      specifiers.push(`${pascalOperationName}QueryParams`);\n    }\n\n    if (body.definition) {\n      specifiers.push(`${pascalOperationName}Body`);\n    }\n\n    if (\n      !isHonoValidator &&\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      response.originalSchema?.['200']?.content?.['application/json'] !=\n        undefined\n    ) {\n      specifiers.push(`${pascalOperationName}Response`);\n    }\n  }\n\n  return specifiers.length === 0\n    ? ''\n    : `import {\\n${specifiers.join(',\\n')}\\n} from '${importPath}'`;\n};\n\nconst getVerbOptionGroupByTag = (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n) => {\n  const grouped: Record<string, GeneratorVerbOptions[]> = {};\n\n  for (const value of Object.values(verbOptions)) {\n    const tag = value.tags[0];\n    // this is not always false\n    // TODO look into types\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!grouped[tag]) {\n      grouped[tag] = [];\n    }\n    grouped[tag].push(value);\n  }\n\n  return grouped;\n};\n\nconst generateHandlerFile = async ({\n  verbs,\n  path,\n  validatorModule,\n  zodModule,\n  contextModule,\n}: {\n  verbs: GeneratorVerbOptions[];\n  path: string;\n  validatorModule?: string;\n  zodModule: string;\n  contextModule: string;\n}) => {\n  const validator =\n    validatorModule === '@hono/zod-validator'\n      ? ('hono' as const)\n      : validatorModule != undefined;\n\n  const isExist = fs.existsSync(path);\n\n  if (isExist) {\n    const rawFile = await fs.readFile(path, 'utf8');\n    let content = rawFile;\n\n    for (const verbOption of Object.values(verbs)) {\n      const handlerName = `${verbOption.operationName}Handlers`;\n      const contextTypeName = `${pascal(verbOption.operationName)}Context`;\n\n      if (!rawFile.includes(handlerName)) {\n        content += getHonoHandlers({\n          handlerName,\n          contextTypeName,\n          verbOption,\n          validator,\n        })[0];\n      }\n    }\n\n    return content;\n  }\n\n  const [handlerCode, hasZValidator] = getHonoHandlers(\n    ...Object.values(verbs).map((verbOption) => ({\n      handlerName: `${verbOption.operationName}Handlers`,\n      contextTypeName: `${pascal(verbOption.operationName)}Context`,\n      verbOption,\n      validator,\n    })),\n  );\n\n  const imports = [\"import { createFactory } from 'hono/factory';\"];\n\n  if (hasZValidator && validatorModule != undefined) {\n    imports.push(\n      `import { zValidator } from '${generateModuleSpecifier(path, validatorModule)}';`,\n    );\n  }\n\n  imports.push(\n    `import { ${Object.values(verbs)\n      .map((verb) => `${pascal(verb.operationName)}Context`)\n      .join(',\\n')} } from '${generateModuleSpecifier(path, contextModule)}';`,\n  );\n\n  if (hasZValidator) {\n    imports.push(\n      getZvalidatorImports(\n        Object.values(verbs),\n        generateModuleSpecifier(path, zodModule),\n        validatorModule === '@hono/zod-validator',\n      ),\n    );\n  }\n\n  return `${imports.filter((imp) => imp !== '').join('\\n')}\n\nconst factory = createFactory();${handlerCode}`;\n};\n\nconst generateHandlerFiles = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  validatorModule: string,\n) => {\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  // This function _does not control_ where the .zod and .context modules land.\n  // That determination is made elsewhere and this function must implement the\n  // same conventions.\n\n  if (output.override.hono.handlers) {\n    // One file per operation in the user-provided directory.\n    return Promise.all(\n      Object.values(verbOptions).map(async (verbOption) => {\n        const tag = kebab(verbOption.tags[0] ?? 'default');\n\n        const path = upath.join(\n          output.override.hono.handlers ?? '',\n          `./${verbOption.operationName}` + extension,\n        );\n\n        return {\n          content: await generateHandlerFile({\n            path,\n            verbs: [verbOption],\n            validatorModule,\n            zodModule:\n              output.mode === 'tags'\n                ? upath.join(dirname, `${kebab(tag)}.zod`)\n                : upath.join(dirname, tag, tag + '.zod'),\n            contextModule:\n              output.mode === 'tags'\n                ? upath.join(dirname, `${kebab(tag)}.context`)\n                : upath.join(dirname, tag, tag + '.context'),\n          }),\n          path,\n        };\n      }),\n    );\n  }\n\n  if (output.mode === 'tags' || output.mode === 'tags-split') {\n    // One file per operation _tag_ under dirname.\n    const groupByTags = getVerbOptionGroupByTag(verbOptions);\n\n    return Promise.all(\n      Object.entries(groupByTags).map(async ([tag, verbs]) => {\n        const handlerPath =\n          output.mode === 'tags'\n            ? upath.join(dirname, `${kebab(tag)}.handlers${extension}`)\n            : upath.join(dirname, tag, tag + '.handlers' + extension);\n\n        return {\n          content: await generateHandlerFile({\n            path: handlerPath,\n            verbs,\n            validatorModule,\n            zodModule:\n              output.mode === 'tags'\n                ? upath.join(dirname, `${kebab(tag)}.zod`)\n                : upath.join(dirname, tag, tag + '.zod'),\n            contextModule:\n              output.mode === 'tags'\n                ? upath.join(dirname, `${kebab(tag)}.context`)\n                : upath.join(dirname, tag, tag + '.context'),\n          }),\n          path: handlerPath,\n        };\n      }),\n    );\n  }\n\n  // One file with all operations.\n  const handlerPath = upath.join(dirname, `${filename}.handlers${extension}`);\n\n  return [\n    {\n      content: await generateHandlerFile({\n        path: handlerPath,\n        verbs: Object.values(verbOptions),\n        validatorModule,\n        zodModule: upath.join(dirname, `${filename}.zod`),\n        contextModule: upath.join(dirname, `${filename}.context`),\n      }),\n      path: handlerPath,\n    },\n  ];\n};\n\nconst getContext = (verbOption: GeneratorVerbOptions) => {\n  let paramType = '';\n  if (verbOption.params.length > 0) {\n    const params = getParamsInPath(verbOption.pathRoute).map((name) => {\n      const param = verbOption.params.find(\n        (p) => p.name === sanitize(camel(name), { es5keyword: true }),\n      );\n      const definition = param?.definition.split(':')[1];\n      const required = param?.required ?? false;\n      return {\n        definition: `${name}${required ? '' : '?'}:${definition}`,\n      };\n    });\n    paramType = `param: {\\n ${params\n      .map((property) => property.definition)\n      .join(',\\n    ')},\\n },`;\n  }\n\n  const queryType = verbOption.queryParams\n    ? `query: ${verbOption.queryParams.schema.name},`\n    : '';\n  const bodyType = verbOption.body.definition\n    ? `json: ${verbOption.body.definition},`\n    : '';\n  const hasIn = !!paramType || !!queryType || !!bodyType;\n\n  return `export type ${pascal(\n    verbOption.operationName,\n  )}Context<E extends Env = any> = Context<E, '${getRoute(\n    verbOption.pathRoute,\n  )}'${\n    hasIn\n      ? `, { in: { ${paramType}${queryType}${bodyType} }, out: { ${paramType}${queryType}${bodyType} } }`\n      : ''\n  }>`;\n};\n\nconst getHeader = (\n  option: false | ((info: OpenApiInfoObject) => string | string[]),\n  info: OpenApiInfoObject,\n): string => {\n  if (!option) {\n    return '';\n  }\n\n  const header = option(info);\n\n  return Array.isArray(header) ? jsDoc({ description: header }) : header;\n};\n\nconst generateContextFile = ({\n  path,\n  verbs,\n  schemaModule,\n}: {\n  path: string;\n  verbs: GeneratorVerbOptions[];\n  schemaModule: string;\n}) => {\n  let content = `import type { Context, Env } from 'hono';\\n\\n`;\n\n  const contexts = verbs.map((verb) => getContext(verb));\n\n  const imps = new Set(\n    verbs\n      .flatMap((verb) => {\n        const imports: GeneratorImport[] = [];\n        if (verb.params.length > 0) {\n          imports.push(...verb.params.flatMap((param) => param.imports));\n        }\n\n        if (verb.queryParams) {\n          imports.push({\n            name: verb.queryParams.schema.name,\n          });\n        }\n\n        if (verb.body.definition) {\n          imports.push(...verb.body.imports);\n        }\n\n        return imports;\n      })\n      .map((imp) => imp.name)\n      .filter((imp) => contexts.some((context) => context.includes(imp))),\n  );\n\n  if (contexts.some((context) => context.includes('NonReadonly<'))) {\n    content += getOrvalGeneratedTypes();\n    content += '\\n';\n  }\n\n  if (imps.size > 0) {\n    content += `import type {\\n${[...imps]\n      .toSorted()\n      .join(\n        ',\\n  ',\n      )}\\n} from '${generateModuleSpecifier(path, schemaModule)}';\\n\\n`;\n  }\n\n  content += contexts.join('\\n');\n\n  return content;\n};\n\nconst generateContextFiles = (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n  schemaModule: string,\n) => {\n  const header = getHeader(output.override.header, context.spec.info);\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  if (output.mode === 'tags' || output.mode === 'tags-split') {\n    const groupByTags = getVerbOptionGroupByTag(verbOptions);\n\n    return Object.entries(groupByTags).map(([tag, verbs]) => {\n      const path =\n        output.mode === 'tags'\n          ? upath.join(dirname, `${kebab(tag)}.context${extension}`)\n          : upath.join(dirname, tag, tag + '.context' + extension);\n      const code = generateContextFile({\n        verbs,\n        path,\n        schemaModule: schemaModule,\n      });\n      return { content: `${header}${code}`, path };\n    });\n  }\n\n  const path = upath.join(dirname, `${filename}.context${extension}`);\n  const code = generateContextFile({\n    verbs: Object.values(verbOptions),\n    path,\n    schemaModule: schemaModule,\n  });\n\n  return [\n    {\n      content: `${header}${code}`,\n      path,\n    },\n  ];\n};\n\nconst generateZodFiles = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) => {\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  const header = getHeader(output.override.header, context.spec.info);\n\n  if (output.mode === 'tags' || output.mode === 'tags-split') {\n    const groupByTags = getVerbOptionGroupByTag(verbOptions);\n\n    const builderContexts = await Promise.all(\n      Object.entries(groupByTags).map(async ([tag, verbs]) => {\n        const zods = await Promise.all(\n          verbs.map(async (verbOption) =>\n            generateZod(\n              verbOption,\n              {\n                route: verbOption.route,\n                pathRoute: verbOption.pathRoute,\n                override: output.override,\n                context,\n                mock: output.mock,\n                output: output.target,\n              },\n              output.client,\n            ),\n          ),\n        );\n\n        if (zods.every((z) => z.implementation === '')) {\n          return {\n            content: '',\n            path: '',\n          };\n        }\n\n        const allMutators = new Map(\n          zods.flatMap((z) => z.mutators ?? []).map((m) => [m.name, m]),\n        )\n          .values()\n          .toArray();\n\n        const mutatorsImports = generateMutatorImports({\n          mutators: allMutators,\n        });\n\n        let content = `${header}import { z as zod } from 'zod';\\n${mutatorsImports}\\n`;\n\n        const zodPath =\n          output.mode === 'tags'\n            ? upath.join(dirname, `${kebab(tag)}.zod${extension}`)\n            : upath.join(dirname, tag, tag + '.zod' + extension);\n\n        content += zods.map((zod) => zod.implementation).join('\\n');\n\n        return {\n          content,\n          path: zodPath,\n        };\n      }),\n    );\n\n    return builderContexts.filter((context) => context.content !== '');\n  }\n\n  const zods = await Promise.all(\n    Object.values(verbOptions).map(async (verbOption) =>\n      generateZod(\n        verbOption,\n        {\n          route: verbOption.route,\n          pathRoute: verbOption.pathRoute,\n          override: output.override,\n          context,\n          mock: output.mock,\n          output: output.target,\n        },\n        output.client,\n      ),\n    ),\n  );\n\n  const allMutators = new Map(\n    zods.flatMap((z) => z.mutators ?? []).map((m) => [m.name, m]),\n  )\n    .values()\n    .toArray();\n\n  const mutatorsImports = generateMutatorImports({\n    mutators: allMutators,\n  });\n\n  let content = `${header}import { z as zod } from 'zod';\\n${mutatorsImports}\\n`;\n\n  const zodPath = upath.join(dirname, `${filename}.zod${extension}`);\n\n  content += zods.map((zod) => zod.implementation).join('\\n');\n\n  return [\n    {\n      content,\n      path: zodPath,\n    },\n  ];\n};\n\nconst generateZvalidator = (\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) => {\n  const header = getHeader(output.override.header, context.spec.info);\n\n  let validatorPath = output.override.hono.validatorOutputPath;\n  if (!output.override.hono.validatorOutputPath) {\n    const { extension, dirname, filename } = getFileInfo(output.target);\n\n    validatorPath = upath.join(dirname, `${filename}.validator${extension}`);\n  }\n\n  return {\n    content: `${header}${ZVALIDATOR_SOURCE}`,\n    path: validatorPath,\n  };\n};\n\nconst generateCompositeRoutes = (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) => {\n  const targetInfo = getFileInfo(output.target);\n  const compositeRouteInfo = getFileInfo(output.override.hono.compositeRoute);\n\n  const header = getHeader(output.override.header, context.spec.info);\n\n  const routes = Object.values(verbOptions)\n    .map((verbOption) => {\n      return generateHonoRoute(verbOption, verbOption.pathRoute);\n    })\n    .join(';');\n\n  const importHandlers = Object.values(verbOptions);\n\n  let ImportHandlersImplementation: string;\n  if (output.override.hono.handlers) {\n    const handlerFileInfo = getFileInfo(output.override.hono.handlers);\n    const operationNames = importHandlers.map(\n      (verbOption) => verbOption.operationName,\n    );\n\n    ImportHandlersImplementation = operationNames\n      .map((operationName) => {\n        const importHandlerName = `${operationName}Handlers`;\n\n        const handlersPath = generateModuleSpecifier(\n          compositeRouteInfo.path,\n          upath.join(handlerFileInfo.dirname, `./${operationName}`),\n        );\n\n        return `import { ${importHandlerName} } from '${handlersPath}';`;\n      })\n      .join('\\n');\n  } else {\n    const tags = importHandlers.map((verbOption) =>\n      kebab(verbOption.tags[0] ?? 'default'),\n    );\n    const uniqueTags = tags.filter((t, i) => tags.indexOf(t) === i);\n\n    ImportHandlersImplementation = uniqueTags\n      .map((tag) => {\n        const importHandlerNames = importHandlers\n          .filter((verbOption) => verbOption.tags[0] === tag)\n          .map((verbOption) => ` ${verbOption.operationName}Handlers`)\n          .join(`, \\n`);\n\n        const handlersPath = generateModuleSpecifier(\n          compositeRouteInfo.path,\n          upath.join(targetInfo.dirname, tag),\n        );\n\n        return `import {\\n${importHandlerNames}\\n} from '${handlersPath}/${tag}.handlers';`;\n      })\n      .join('\\n');\n  }\n\n  const honoImport = `import { Hono } from 'hono';`;\n  const honoInitialization = `\\nconst app = new Hono()`;\n  const honoAppExport = `\\nexport default app`;\n\n  const content = `${header}${honoImport}\n${ImportHandlersImplementation}\n${honoInitialization}\n${routes}\n${honoAppExport}\n`;\n\n  return [\n    {\n      content,\n      path: output.override.hono.compositeRoute || '',\n    },\n  ];\n};\n\nexport const generateExtraFiles: ClientExtraFilesBuilder = async (\n  verbOptions,\n  output,\n  context,\n) => {\n  const { path, pathWithoutExtension } = getFileInfo(output.target);\n  const validator = generateZvalidator(output, context);\n  let schemaModule: string;\n  const isZodSchemaOutput =\n    isObject(output.schemas) && output.schemas.type === 'zod';\n\n  if (output.schemas != undefined) {\n    const schemasPath = isObject(output.schemas)\n      ? output.schemas.path\n      : output.schemas;\n    const basePath = getFileInfo(schemasPath).dirname;\n    schemaModule =\n      isZodSchemaOutput && output.indexFiles\n        ? upath.joinSafe(basePath, 'index.zod')\n        : basePath;\n  } else if (output.mode === 'single') {\n    schemaModule = path;\n  } else {\n    schemaModule = `${pathWithoutExtension}.schemas`;\n  }\n\n  const contexts = generateContextFiles(\n    verbOptions,\n    output,\n    context,\n    schemaModule,\n  );\n  const compositeRoutes = output.override.hono.compositeRoute\n    ? generateCompositeRoutes(verbOptions, output, context)\n    : [];\n  const [handlers, zods] = await Promise.all([\n    generateHandlerFiles(verbOptions, output, validator.path),\n    generateZodFiles(verbOptions, output, context),\n  ]);\n\n  return [\n    ...handlers,\n    ...contexts,\n    ...zods,\n    ...(output.override.hono.validator &&\n    output.override.hono.validator !== 'hono'\n      ? [validator]\n      : []),\n    ...compositeRoutes,\n  ];\n};\n\nconst honoClientBuilder: ClientGeneratorsBuilder = {\n  client: generateHono,\n  dependencies: getHonoDependencies,\n  header: getHonoHeader,\n  footer: getHonoFooter,\n  extraFiles: generateExtraFiles,\n};\n\nexport const builder = () => () => honoClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}