{"version":3,"file":"index.mjs","names":["getMcpHeader: ClientHeaderBuilder","generateMcp: ClientBuilder","generateExtraFiles: ClientExtraFilesBuilder","mcpClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/index.ts"],"sourcesContent":["import {\n  camel,\n  type ClientBuilder,\n  type ClientExtraFilesBuilder,\n  type ClientGeneratorsBuilder,\n  type ClientHeaderBuilder,\n  type ContextSpec,\n  generateMutatorImports,\n  type GeneratorVerbOptions,\n  getFileInfo,\n  getFullRoute,\n  isObject,\n  jsDoc,\n  jsStringEscape,\n  type NormalizedOutputOptions,\n  type OpenApiInfoObject,\n  pascal,\n  upath,\n} from '@orval/core';\nimport { generateClient, generateFetchHeader } from '@orval/fetch';\nimport { generateZod } from '@orval/zod';\n\nconst getHeader = (\n  option: false | ((info: OpenApiInfoObject) => string | string[]),\n  info: OpenApiInfoObject,\n): string => {\n  if (!option) {\n    return '';\n  }\n\n  const header = option(info);\n\n  return Array.isArray(header) ? jsDoc({ description: header }) : header;\n};\n\nexport const getMcpHeader: ClientHeaderBuilder = ({ verbOptions, output }) => {\n  const targetInfo = getFileInfo(output.target);\n  const schemasPath = isObject(output.schemas)\n    ? output.schemas.path\n    : output.schemas;\n  const schemaInfo = schemasPath ? getFileInfo(schemasPath) : undefined;\n\n  const isZodSchemaOutput =\n    isObject(output.schemas) && output.schemas.type === 'zod';\n  const basePath = schemaInfo?.dirname;\n  const relativeSchemaImportPath = basePath\n    ? isZodSchemaOutput && output.indexFiles\n      ? upath.relativeSafe(\n          targetInfo.dirname,\n          upath.joinSafe(basePath, 'index.zod'),\n        )\n      : upath.relativeSafe(targetInfo.dirname, basePath)\n    : './' + targetInfo.filename + '.schemas';\n\n  const importSchemaNames = new Set(\n    Object.values(verbOptions).flatMap((verbOption) => {\n      const imports = [];\n      const pascalOperationName = pascal(verbOption.operationName);\n\n      if (verbOption.queryParams) {\n        imports.push(`${pascalOperationName}Params`);\n      }\n\n      if (verbOption.body.imports[0]?.name) {\n        imports.push(verbOption.body.imports[0]?.name);\n      }\n\n      return imports;\n    }),\n  )\n    .values()\n    .toArray();\n\n  const importSchemasImplementation = `import {\\n  ${importSchemaNames.join(\n    ',\\n  ',\n  )}\\n} from '${relativeSchemaImportPath}';\n`;\n\n  const relativeFetchClientPath = './http-client';\n  const importFetchClientNames = new Set(\n    Object.values(verbOptions).flatMap(\n      (verbOption) => verbOption.operationName,\n    ),\n  )\n    .values()\n    .toArray();\n\n  const importFetchClientImplementation = `import {\\n  ${importFetchClientNames.join(\n    ',\\n  ',\n  )}\\n} from '${relativeFetchClientPath}';\n  `;\n\n  const content = [\n    importSchemasImplementation,\n    importFetchClientImplementation,\n  ].join('\\n');\n\n  return content + '\\n';\n};\n\nexport const generateMcp: ClientBuilder = (verbOptions) => {\n  const handlerArgsTypes = [];\n  const pathParamsType = verbOptions.params\n    .map((param) => {\n      const paramName = param.name.split(': ')[0];\n      const paramType = param.implementation.split(': ')[1];\n      return `    ${paramName}: ${paramType}`;\n    })\n    .join(',\\n');\n  if (pathParamsType) {\n    handlerArgsTypes.push(`  pathParams: {\\n${pathParamsType}\\n  };`);\n  }\n  if (verbOptions.queryParams) {\n    handlerArgsTypes.push(\n      `  queryParams: ${verbOptions.queryParams.schema.name};`,\n    );\n  }\n  if (verbOptions.body.definition) {\n    handlerArgsTypes.push(`  bodyParams: ${verbOptions.body.definition};`);\n  }\n\n  const handlerArgsName = `${verbOptions.operationName}Args`;\n  const handlerArgsImplementation =\n    handlerArgsTypes.length > 0\n      ? `\nexport type ${handlerArgsName} = {\n${handlerArgsTypes.join('\\n')}\n}\n`\n      : '';\n\n  const fetchParams = [];\n  if (verbOptions.params.length > 0) {\n    const pathParamsArgs = verbOptions.params\n      .map((param) => {\n        const paramName = param.name.split(': ')[0];\n\n        return `args.pathParams.${paramName}`;\n      })\n      .join(', ');\n\n    fetchParams.push(pathParamsArgs);\n  }\n  if (verbOptions.body.definition) fetchParams.push(`args.bodyParams`);\n  if (verbOptions.queryParams) fetchParams.push(`args.queryParams`);\n\n  const handlerName = `${verbOptions.operationName}Handler`;\n  const handlerImplementation = `\nexport const ${handlerName} = async (${handlerArgsTypes.length > 0 ? `args: ${handlerArgsName}` : ''}) => {\n  const res = await ${verbOptions.operationName}(${fetchParams.join(', ')});\n\n  return {\n    content: [\n      {\n        type: 'text' as const,\n        text: JSON.stringify(res),\n      },\n    ],\n  };\n};`;\n\n  const handlersImplementation = [\n    handlerArgsImplementation,\n    handlerImplementation,\n  ].join('');\n\n  return {\n    implementation: handlersImplementation ? `${handlersImplementation}\\n` : '',\n    imports: [],\n  };\n};\n\nexport const generateServer = (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) => {\n  const info = context.spec.info;\n  const { extension, dirname } = getFileInfo(output.target);\n  const serverPath = upath.join(dirname, `server${extension}`);\n  const header = getHeader(output.override.header, info);\n\n  const toolImplementations = Object.values(verbOptions)\n    .map((verbOption) => {\n      const pascalOperationName = pascal(verbOption.operationName);\n      const inputSchemaTypes = [];\n      if (verbOption.params.length > 0)\n        inputSchemaTypes.push(`  pathParams: ${pascalOperationName}Params`);\n      if (verbOption.queryParams)\n        inputSchemaTypes.push(\n          `  queryParams: ${pascalOperationName}QueryParams`,\n        );\n      if (verbOption.body.definition)\n        inputSchemaTypes.push(`  bodyParams: ${pascalOperationName}Body`);\n\n      const inputSchemaImplementation =\n        inputSchemaTypes.length > 0\n          ? `  {\n  ${inputSchemaTypes.join(',\\n  ')}\n  },`\n          : '';\n\n      const toolImplementation = `\nserver.tool(\n  '${jsStringEscape(verbOption.operationName)}',\n  '${jsStringEscape(verbOption.summary)}',${inputSchemaImplementation ? `\\n${inputSchemaImplementation}` : ''}\n  ${jsStringEscape(verbOption.operationName)}Handler\n);`;\n\n      return toolImplementation;\n    })\n    .join('\\n');\n\n  const importToolSchemas = Object.values(verbOptions)\n    .flatMap((verbOption) => {\n      const imports = [];\n\n      const pascalOperationName = pascal(verbOption.operationName);\n\n      if (verbOption.headers) imports.push(`  ${pascalOperationName}Header`);\n      if (verbOption.params.length > 0)\n        imports.push(`  ${pascalOperationName}Params`);\n      if (verbOption.queryParams)\n        imports.push(`  ${pascalOperationName}QueryParams`);\n      if (verbOption.body.definition)\n        imports.push(`  ${pascalOperationName}Body`);\n\n      return imports;\n    })\n    .join(',\\n');\n  const importToolSchemasImplementation = `import {\\n${importToolSchemas}\\n} from './tool-schemas.zod';`;\n\n  const importHandlers = Object.values(verbOptions)\n    .filter((verbOption) =>\n      toolImplementations.includes(`${verbOption.operationName}Handler`),\n    )\n    .map((verbOption) => `  ${verbOption.operationName}Handler`)\n    .join(`,\\n`);\n  const importHandlersImplementation = `import {\\n${importHandlers}\\n} from './handlers';`;\n\n  const importDependenciesImplementation = `import {\n  McpServer\n} from '@modelcontextprotocol/sdk/server/mcp.js';\n  \nimport {\n  StdioServerTransport\n} from '@modelcontextprotocol/sdk/server/stdio.js';  \n`;\n  const newMcpServerImplementation = `\nconst server = new McpServer({\n  name: '${camel(info.title)}Server',\n  version: '1.0.0',\n});\n`;\n  const serverConnectImplementation = `\nconst transport = new StdioServerTransport();\n\nserver.connect(transport).then(() => {\n  console.error('MCP server running on stdio');\n}).catch(console.error);\n`;\n\n  const content = [\n    header,\n    importDependenciesImplementation,\n    importHandlersImplementation,\n    importToolSchemasImplementation,\n    newMcpServerImplementation,\n    toolImplementations,\n    serverConnectImplementation,\n  ].join('\\n');\n\n  return [\n    {\n      content,\n      path: serverPath,\n    },\n  ];\n};\n\nconst generateZodFiles = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) => {\n  const { extension, dirname } = getFileInfo(output.target);\n\n  const header = getHeader(output.override.header, context.spec.info);\n\n  const zods = await Promise.all(\n    Object.values(verbOptions).map(async (verbOption) =>\n      generateZod(\n        verbOption,\n        {\n          route: verbOption.route,\n          pathRoute: verbOption.pathRoute,\n          override: output.override,\n          context,\n          mock: output.mock,\n          output: output.target,\n        },\n        output.client,\n      ),\n    ),\n  );\n\n  const allMutators = new Map(\n    zods.flatMap((z) => z.mutators ?? []).map((m) => [m.name, m]),\n  )\n    .values()\n    .toArray();\n\n  const mutatorsImports = generateMutatorImports({\n    mutators: allMutators,\n  });\n\n  let content = `${header}import { z as zod } from 'zod';\\n${mutatorsImports}\\n`;\n\n  const zodPath = upath.join(dirname, `tool-schemas.zod${extension}`);\n\n  content += zods.map((zod) => zod.implementation).join('\\n');\n\n  return [\n    {\n      content,\n      path: zodPath,\n    },\n  ];\n};\n\nconst generateHttpClientFiles = async (\n  verbOptions: Record<string, GeneratorVerbOptions>,\n  output: NormalizedOutputOptions,\n  context: ContextSpec,\n) => {\n  const { extension, dirname, filename } = getFileInfo(output.target);\n\n  const header = getHeader(output.override.header, context.spec.info);\n\n  const clients = await Promise.all(\n    Object.values(verbOptions).map(async (verbOption) => {\n      const fullRoute = getFullRoute(\n        verbOption.route,\n        context.spec.servers,\n        output.baseUrl,\n      );\n\n      const options = {\n        route: fullRoute,\n        pathRoute: verbOption.pathRoute,\n        override: output.override,\n        context,\n        mock: output.mock,\n        output: output.target,\n      };\n\n      return generateClient(verbOption, options, output.client, output);\n    }),\n  );\n\n  const clientImplementation = clients\n    .map((client) => client.implementation)\n    .join('\\n');\n\n  const isZodSchemaOutput =\n    isObject(output.schemas) && output.schemas.type === 'zod';\n  const schemasPath = isObject(output.schemas)\n    ? output.schemas.path\n    : output.schemas;\n  const basePath = schemasPath ? getFileInfo(schemasPath).dirname : undefined;\n  const relativeSchemasPath = basePath\n    ? isZodSchemaOutput && output.indexFiles\n      ? upath.relativeSafe(dirname, upath.joinSafe(basePath, 'index.zod'))\n      : upath.relativeSafe(dirname, basePath)\n    : './' + filename + '.schemas';\n\n  const importNames = clients\n    .flatMap((client) => client.imports)\n    .map((imp) => imp.name);\n  const uniqueImportNames = new Set(importNames).values().toArray();\n\n  const importImplementation = `import { ${uniqueImportNames.join(\n    ',\\n',\n  )} } from '${relativeSchemasPath}';`;\n\n  const fetchHeader = generateFetchHeader({\n    title: '',\n    isRequestOptions: false,\n    isMutator: false,\n    noFunction: false,\n    isGlobalMutator: false,\n    provideIn: false,\n    hasAwaitedType: false,\n    output,\n    verbOptions,\n    clientImplementation,\n  });\n\n  const content = [\n    header,\n    importImplementation,\n    fetchHeader,\n    clientImplementation,\n  ].join('\\n');\n  const outputPath = upath.join(dirname, `http-client${extension}`);\n\n  return [\n    {\n      content,\n      path: outputPath,\n    },\n  ];\n};\n\nexport const generateExtraFiles: ClientExtraFilesBuilder = async (\n  verbOptions,\n  output,\n  context,\n) => {\n  const server = generateServer(verbOptions, output, context);\n  const [zods, httpClients] = await Promise.all([\n    generateZodFiles(verbOptions, output, context),\n    generateHttpClientFiles(verbOptions, output, context),\n  ]);\n\n  return [...server, ...zods, ...httpClients];\n};\n\nconst mcpClientBuilder: ClientGeneratorsBuilder = {\n  client: generateMcp,\n  header: getMcpHeader,\n  extraFiles: generateExtraFiles,\n};\n\nexport const builder = () => () => mcpClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}