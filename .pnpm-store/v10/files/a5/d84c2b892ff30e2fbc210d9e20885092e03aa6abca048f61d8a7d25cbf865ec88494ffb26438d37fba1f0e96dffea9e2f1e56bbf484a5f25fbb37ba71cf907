{"version":3,"file":"index.mjs","names":["ZOD_DEPENDENCIES: GeneratorDependency[]","type","constsUniqueCounter: Record<string, number>","consts: string[]","functions: [string, any][]","schema","defaultVarName: string | undefined","defaultValue: string | undefined","mergedProperties: Record<string, ZodValidationSchemaDefinition>","value","childContext: ContextSpec","propertyOverrides: Record<string, ZodValidationSchemaDefinition>","fileFunctions: [string, unknown][]","headers: ZodValidationSchemaDefinition","queryParams: ZodValidationSchemaDefinition","params: ZodValidationSchemaDefinition","generateZod: ClientBuilder","zodClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/compatible-v4.ts","../src/index.ts"],"sourcesContent":["import { compareVersions, type PackageJson } from '@orval/core';\n\nconst getZodPackageVersion = (packageJson: PackageJson) => {\n  return (\n    packageJson.dependencies?.zod ??\n    packageJson.devDependencies?.zod ??\n    packageJson.peerDependencies?.zod\n  );\n};\n\nexport const isZodVersionV4 = (packageJson: PackageJson) => {\n  const version = getZodPackageVersion(packageJson);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '4.0.0');\n};\n\nexport const getZodDateFormat = (isZodV4: boolean) => {\n  return isZodV4 ? 'iso.date' : 'date';\n};\n\nexport const getZodTimeFormat = (isZodV4: boolean) => {\n  return isZodV4 ? 'iso.time' : 'time';\n};\n\nexport const getZodDateTimeFormat = (isZodV4: boolean) => {\n  return isZodV4 ? 'iso.datetime' : 'datetime';\n};\n\nexport const getParameterFunctions = (\n  isZodV4: boolean,\n  strict: boolean,\n  parameters: Record<string, any>,\n): [string, any][] => {\n  if (isZodV4 && strict) {\n    return [['strictObject', parameters]];\n  } else {\n    return strict\n      ? [\n          ['object', parameters],\n          ['strict', undefined],\n        ]\n      : [['object', parameters]];\n  }\n};\n\nexport const getObjectFunctionName = (isZodV4: boolean, strict: boolean) => {\n  return isZodV4 && strict ? 'strictObject' : 'object';\n};\n","import {\n  camel,\n  type ClientBuilder,\n  type ClientGeneratorsBuilder,\n  type ContextSpec,\n  escape,\n  generateMutator,\n  type GeneratorDependency,\n  type GeneratorMutator,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  getFormDataFieldFileType,\n  getNumberWord,\n  getPropertySafe,\n  getRefInfo,\n  isBoolean,\n  isObject,\n  isString,\n  jsStringEscape,\n  type OpenApiParameterObject,\n  type OpenApiReferenceObject,\n  type OpenApiRequestBodyObject,\n  type OpenApiResponseObject,\n  type OpenApiSchemaObject,\n  pascal,\n  resolveRef,\n  stringify,\n  type ZodCoerceType,\n} from '@orval/core';\nimport { unique } from 'remeda';\n\nimport {\n  getObjectFunctionName,\n  getParameterFunctions,\n  getZodDateFormat,\n  getZodDateTimeFormat,\n  getZodTimeFormat,\n  isZodVersionV4,\n} from './compatible-v4';\n\nconst ZOD_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        default: false,\n        name: 'zod',\n        syntheticDefaultImport: false,\n        namespaceImport: true,\n        values: true,\n      },\n    ],\n    dependency: 'zod',\n  },\n];\n\nexport const getZodDependencies = () => ZOD_DEPENDENCIES;\n\n/**\n * values that may appear in \"type\". Equals SchemaObjectType\n */\nconst possibleSchemaTypes = new Set([\n  'integer',\n  'number',\n  'string',\n  'boolean',\n  'object',\n  'strictObject',\n  'null',\n  'array',\n]);\n\nconst resolveZodType = (schema: OpenApiSchemaObject) => {\n  const schemaTypeValue = schema.type;\n\n  // Handle array of types (OpenAPI 3.1+)\n  if (Array.isArray(schemaTypeValue)) {\n    // Filter out 'null' type as it's handled separately via nullable\n    const nonNullTypes = schemaTypeValue\n      .filter((t) => t !== 'null' && possibleSchemaTypes.has(t))\n      .map((t) => (t === 'integer' ? 'number' : t));\n\n    // If multiple types, return a special marker for union handling\n    if (nonNullTypes.length > 1) {\n      return { multiType: nonNullTypes };\n    }\n\n    // Single type\n    const type = nonNullTypes[0];\n\n    // Handle prefixItems for tuples\n    if (type === 'array' && 'prefixItems' in schema) {\n      return 'tuple';\n    }\n\n    return type;\n  }\n\n  // Handle single type value\n  const type = schemaTypeValue;\n\n  // TODO: if \"prefixItems\" exists and type is \"array\", then generate a \"tuple\"\n  if (schema.type === 'array' && 'prefixItems' in schema) {\n    return 'tuple';\n  }\n\n  switch (type) {\n    case 'integer': {\n      return 'number';\n    }\n    default: {\n      return type ?? 'unknown';\n    }\n  }\n};\n\nconst constsUniqueCounter: Record<string, number> = {};\n\n// https://github.com/colinhacks/zod#coercion-for-primitives\nconst COERCIBLE_TYPES = new Set([\n  'string',\n  'number',\n  'boolean',\n  'bigint',\n  'date',\n]);\n\nexport type ZodValidationSchemaDefinition = {\n  functions: [string, any][];\n  consts: string[];\n};\n\nconst minAndMaxTypes = new Set(['number', 'string', 'array']);\n\nconst removeReadOnlyProperties = (\n  schema: OpenApiSchemaObject,\n): OpenApiSchemaObject => {\n  if (schema.properties) {\n    return {\n      ...schema,\n      properties: Object.entries(schema.properties).reduce<\n        Record<string, OpenApiSchemaObject>\n      >((acc, [key, value]) => {\n        if ('readOnly' in value && value.readOnly) return acc;\n        acc[key] = value as OpenApiSchemaObject;\n        return acc;\n      }, {}),\n    };\n  }\n  if (schema.items && 'properties' in schema.items) {\n    return {\n      ...schema,\n      items: removeReadOnlyProperties(schema.items as OpenApiSchemaObject),\n    };\n  }\n  return schema;\n};\n\ntype DateTimeOptions = {\n  offset?: boolean;\n  local?: boolean;\n  precision?: number;\n};\n\ntype TimeOptions = {\n  precision?: -1 | 0 | 1 | 2 | 3;\n};\n\nexport const generateZodValidationSchemaDefinition = (\n  schema: OpenApiSchemaObject | undefined,\n  context: ContextSpec,\n  name: string,\n  strict: boolean,\n  isZodV4: boolean,\n  rules?: {\n    required?: boolean;\n    dateTimeOptions?: DateTimeOptions;\n    timeOptions?: TimeOptions;\n    /**\n     * Override schemas for properties at THIS level only.\n     * Not passed to nested schemas. Used by form-data for file type handling.\n     */\n    propertyOverrides?: Record<string, ZodValidationSchemaDefinition>;\n  },\n): ZodValidationSchemaDefinition => {\n  if (!schema) return { functions: [], consts: [] };\n\n  const consts: string[] = [];\n  const constsCounter =\n    typeof constsUniqueCounter[name] === 'number'\n      ? constsUniqueCounter[name] + 1\n      : 0;\n\n  const constsCounterValue = constsCounter\n    ? pascal(getNumberWord(constsCounter))\n    : '';\n\n  constsUniqueCounter[name] = constsCounter;\n\n  const functions: [string, any][] = [];\n  const type = resolveZodType(schema);\n  const required = rules?.required ?? false;\n  const nullable =\n    // changing to ?? here changes behavior - so don't\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    ('nullable' in schema && schema.nullable) ||\n    (Array.isArray(schema.type) && schema.type.includes('null'));\n  const min = schema.minimum ?? schema.minLength ?? schema.minItems;\n  const max = schema.maximum ?? schema.maxLength ?? schema.maxItems;\n\n  // Handle exclusiveMinimum and exclusiveMaximum (OpenAPI 3.0 vs 3.1 compatibility)\n  // OpenAPI 3.0: exclusiveMinimum/exclusiveMaximum are booleans indicating if minimum/maximum is exclusive\n  // OpenAPI 3.1: exclusiveMinimum/exclusiveMaximum are numbers (the value itself)\n  const exclusiveMinRaw =\n    'exclusiveMinimum' in schema ? schema.exclusiveMinimum : undefined;\n  const exclusiveMaxRaw =\n    'exclusiveMaximum' in schema ? schema.exclusiveMaximum : undefined;\n\n  // Convert boolean to number if using OpenAPI 3.0 format\n  const exclusiveMin =\n    typeof exclusiveMinRaw === 'boolean' && exclusiveMinRaw\n      ? min\n      : exclusiveMinRaw;\n  const exclusiveMax =\n    typeof exclusiveMaxRaw === 'boolean' && exclusiveMaxRaw\n      ? max\n      : exclusiveMaxRaw;\n\n  const multipleOf = schema.multipleOf;\n  const matches = schema.pattern ?? undefined;\n\n  // Check for allOf/oneOf/anyOf BEFORE processing by type\n  // This ensures these constraints work with any base type (string, number, object, etc.)\n  let skipSwitchStatement = false;\n  if (schema.allOf || schema.oneOf || schema.anyOf) {\n    const separator = schema.allOf ? 'allOf' : schema.oneOf ? 'oneOf' : 'anyOf';\n\n    const schemas = (schema.allOf ?? schema.oneOf ?? schema.anyOf) as (\n      | OpenApiSchemaObject\n      | OpenApiReferenceObject\n    )[];\n\n    // Use index-based naming to ensure uniqueness when processing multiple schemas\n    // This prevents duplicate schema names when nullable refs are used\n    const baseSchemas = schemas.map((schema, index) =>\n      generateZodValidationSchemaDefinition(\n        schema as OpenApiSchemaObject,\n        context,\n        `${camel(name)}${pascal(getNumberWord(index + 1))}`,\n        strict,\n        isZodV4,\n        {\n          required: true,\n        },\n      ),\n    );\n\n    // Handle allOf/oneOf/anyOf with additional properties - merge additional properties into the schema\n    if ((schema.allOf || schema.oneOf || schema.anyOf) && schema.properties) {\n      const additionalPropertiesSchema = {\n        properties: schema.properties,\n        required: schema.required,\n        additionalProperties: schema.additionalProperties,\n        type: schema.type,\n      } as OpenApiSchemaObject;\n\n      // Use index-based naming to ensure uniqueness\n      const additionalIndex = baseSchemas.length + 1;\n      const additionalPropertiesDefinition =\n        generateZodValidationSchemaDefinition(\n          additionalPropertiesSchema,\n          context,\n          `${camel(name)}${pascal(getNumberWord(additionalIndex))}`,\n          strict,\n          isZodV4,\n          {\n            required: true,\n          },\n        );\n\n      // For oneOf/anyOf, use allOf to combine union with common properties\n      // This generates: zod.union([...]).and(commonProperties)\n      if (schema.oneOf || schema.anyOf) {\n        functions.push([\n          'allOf',\n          [\n            { functions: [[separator, baseSchemas]], consts: [] },\n            additionalPropertiesDefinition,\n          ],\n        ]);\n      } else {\n        // For allOf, just add to the list\n        baseSchemas.push(additionalPropertiesDefinition);\n        functions.push([separator, baseSchemas]);\n      }\n    } else {\n      functions.push([separator, baseSchemas]);\n    }\n    skipSwitchStatement = true;\n  }\n\n  let defaultVarName: string | undefined;\n  if (schema.default !== undefined) {\n    defaultVarName = `${name}Default${constsCounterValue}`;\n    let defaultValue: string | undefined;\n\n    const isDateType =\n      schema.type === 'string' &&\n      (schema.format === 'date' || schema.format === 'date-time') &&\n      context.output.override.useDates;\n\n    if (isDateType) {\n      // OpenApiSchemaObject defines default as 'any'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      defaultValue = `new Date(\"${escape(schema.default)}\")`;\n    } else if (isObject(schema.default)) {\n      const entries = Object.entries(schema.default)\n        .map(([key, value]) => {\n          if (isString(value)) {\n            return `${key}: \"${escape(value)}\"`;\n          }\n\n          if (Array.isArray(value)) {\n            const arrayItems = value.map((item) =>\n              isString(item) ? `\"${escape(item)}\"` : `${item}`,\n            );\n            return `${key}: [${arrayItems.join(', ')}]`;\n          }\n\n          if (\n            value === null ||\n            value === undefined ||\n            typeof value === 'number' ||\n            typeof value === 'boolean'\n          )\n            return `${key}: ${value}`;\n        })\n        .join(', ');\n      defaultValue = `{ ${entries} }`;\n    } else {\n      // OpenApiSchemaObject defines default as 'any'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      const rawStringified = stringify(schema.default);\n      defaultValue =\n        rawStringified === undefined\n          ? 'null'\n          : rawStringified.replaceAll(\"'\", '`');\n\n      // If the schema is an array with enum items, inject inplace to avoid issues with default values\n      const isArrayWithEnumItems =\n        Array.isArray(schema.default) &&\n        type === 'array' &&\n        schema.items &&\n        'enum' in schema.items &&\n        schema.default.length > 0;\n\n      if (isArrayWithEnumItems) {\n        defaultVarName = defaultValue;\n        defaultValue = undefined;\n      }\n    }\n    if (defaultValue) {\n      consts.push(`export const ${defaultVarName} = ${defaultValue};`);\n    }\n  }\n\n  // Handle multi-type schemas (OpenAPI 3.1+ type arrays)\n  if (typeof type === 'object' && 'multiType' in type) {\n    const types = type.multiType;\n    functions.push([\n      'oneOf',\n      types.map((t) =>\n        generateZodValidationSchemaDefinition(\n          { ...schema, type: t },\n          context,\n          name,\n          strict,\n          isZodV4,\n          { required: true },\n        ),\n      ),\n    ]);\n\n    if (!required && nullable) {\n      functions.push(['nullish', undefined]);\n    } else if (nullable) {\n      functions.push(['nullable', undefined]);\n    } else if (!required) {\n      functions.push(['optional', undefined]);\n    }\n\n    return { functions, consts };\n  }\n\n  if (!skipSwitchStatement) {\n    switch (type) {\n      case 'tuple': {\n        /**\n         *\n         * > 10.3.1.1. prefixItems\n         * > The value of \"prefixItems\" MUST be a non-empty array of valid JSON Schemas.\n         * >\n         * > Validation succeeds if each element of the instance validates against the schema at the same position, if any.\n         * > This keyword does not constrain the length of the array. If the array is longer than this keyword's value,\n         * > this keyword validates only the prefix of matching length.\n         * >\n         * > This keyword produces an annotation value which is the largest index to which this keyword applied a subschema.\n         * > The value MAY be a boolean true if a subschema was applied to every index of the instance, such as is produced by the \"items\" keyword.\n         * > This annotation affects the behavior of \"items\" and \"unevaluatedItems\".\n         * >\n         * > Omitting this keyword has the same assertion behavior as an empty array.\n         */\n        if ('prefixItems' in schema) {\n          const schema31 = schema as OpenApiSchemaObject;\n\n          if (schema31.prefixItems && schema31.prefixItems.length > 0) {\n            functions.push([\n              'tuple',\n              schema31.prefixItems.map((item, idx) =>\n                generateZodValidationSchemaDefinition(\n                  dereference(\n                    item as OpenApiSchemaObject | OpenApiReferenceObject,\n                    context,\n                  ),\n                  context,\n                  camel(`${name}-${idx}-item`),\n                  isZodV4,\n                  strict,\n                  {\n                    required: true,\n                  },\n                ),\n              ),\n            ]);\n\n            if (\n              schema.items &&\n              (max ?? Number.POSITIVE_INFINITY) > schema31.prefixItems.length\n            ) {\n              // only add zod.rest() if number of tuple elements can exceed provided prefixItems:\n              functions.push([\n                'rest',\n                generateZodValidationSchemaDefinition(\n                  schema.items as OpenApiSchemaObject | undefined,\n                  context,\n                  camel(`${name}-item`),\n                  strict,\n                  isZodV4,\n                  {\n                    required: true,\n                  },\n                ),\n              ]);\n            }\n          }\n        }\n        break;\n      }\n      case 'array': {\n        functions.push([\n          'array',\n          generateZodValidationSchemaDefinition(\n            schema.items as OpenApiSchemaObject | undefined,\n            context,\n            camel(`${name}-item`),\n            strict,\n            isZodV4,\n            {\n              required: true,\n            },\n          ),\n        ]);\n        break;\n      }\n      case 'string': {\n        if (schema.enum) {\n          break;\n        }\n\n        if (\n          context.output.override.useDates &&\n          (schema.format === 'date' || schema.format === 'date-time')\n        ) {\n          functions.push(['date', undefined]);\n          break;\n        }\n\n        if (schema.format === 'binary') {\n          functions.push(['instanceof', 'File']);\n          break;\n        }\n\n        if (isZodV4) {\n          if (\n            ![\n              'date',\n              'time',\n              'date-time',\n              'email',\n              'uri',\n              'hostname',\n              'uuid',\n            ].includes(schema.format ?? '')\n          ) {\n            if ('const' in schema) {\n              functions.push(['literal', `\"${schema.const}\"`]);\n            } else {\n              functions.push([type as string, undefined]);\n            }\n            break;\n          }\n        } else {\n          if ('const' in schema) {\n            functions.push(['literal', `\"${schema.const}\"`]);\n          } else {\n            functions.push([type as string, undefined]);\n          }\n        }\n\n        if (schema.format === 'date') {\n          const formatAPI = getZodDateFormat(isZodV4);\n\n          functions.push([formatAPI, undefined]);\n          break;\n        }\n\n        if (schema.format === 'time') {\n          const options = context.output.override.zod.timeOptions;\n          const formatAPI = getZodTimeFormat(isZodV4);\n\n          functions.push([formatAPI, JSON.stringify(options)]);\n          break;\n        }\n\n        if (schema.format === 'date-time') {\n          const options = context.output.override.zod.dateTimeOptions;\n          const formatAPI = getZodDateTimeFormat(isZodV4);\n\n          functions.push([formatAPI, JSON.stringify(options)]);\n          break;\n        }\n\n        if (schema.format === 'email') {\n          functions.push(['email', undefined]);\n          break;\n        }\n\n        if (schema.format === 'uri' || schema.format === 'hostname') {\n          functions.push(['url', undefined]);\n          break;\n        }\n\n        if (schema.format === 'uuid') {\n          functions.push(['uuid', undefined]);\n          break;\n        }\n\n        break;\n      }\n      default: {\n        if (schema.properties) {\n          const objectType = getObjectFunctionName(isZodV4, strict);\n\n          functions.push([\n            objectType,\n            Object.keys(schema.properties)\n              .map((key) => ({\n                [key]:\n                  rules?.propertyOverrides?.[key] ??\n                  generateZodValidationSchemaDefinition(\n                    schema.properties?.[key] as OpenApiSchemaObject | undefined,\n                    context,\n                    camel(`${name}-${key}`),\n                    strict,\n                    isZodV4,\n                    { required: schema.required?.includes(key) },\n                  ),\n              }))\n              .reduce((acc, curr) => ({ ...acc, ...curr }), {}),\n          ]);\n\n          if (strict && !isZodV4) {\n            functions.push(['strict', undefined]);\n          }\n\n          break;\n        }\n\n        if (schema.additionalProperties) {\n          functions.push([\n            'additionalProperties',\n            generateZodValidationSchemaDefinition(\n              isBoolean(schema.additionalProperties)\n                ? {}\n                : (schema.additionalProperties as OpenApiSchemaObject),\n              context,\n              name,\n              strict,\n              isZodV4,\n              {\n                required: true,\n              },\n            ),\n          ]);\n\n          break;\n        }\n\n        if (schema.enum) {\n          break;\n        }\n\n        functions.push([type as string, undefined]);\n\n        break;\n      }\n    }\n  }\n\n  if (minAndMaxTypes.has(type)) {\n    // Handle minimum constraints: exclusiveMinimum (>.gt()) takes priority over minimum (.min())\n    // Check if exclusive flag was set (boolean format in OpenAPI 3.0) or a different value (OpenAPI 3.1)\n    const shouldUseExclusiveMin = exclusiveMinRaw !== undefined;\n    const shouldUseExclusiveMax = exclusiveMaxRaw !== undefined;\n\n    if (shouldUseExclusiveMin && exclusiveMin !== undefined) {\n      consts.push(\n        `export const ${name}ExclusiveMin${constsCounterValue} = ${exclusiveMin};`,\n      );\n      // Generate .gt() for exclusive minimum (> instead of >=)\n      functions.push(['gt', `${name}ExclusiveMin${constsCounterValue}`]);\n    } else if (min !== undefined) {\n      if (min === 1) {\n        functions.push(['min', `${min}`]);\n      } else {\n        consts.push(`export const ${name}Min${constsCounterValue} = ${min};`);\n        functions.push(['min', `${name}Min${constsCounterValue}`]);\n      }\n    }\n\n    // Handle maximum constraints: exclusiveMaximum (<.lt()) takes priority over maximum (.max())\n    if (shouldUseExclusiveMax && exclusiveMax !== undefined) {\n      consts.push(\n        `export const ${name}ExclusiveMax${constsCounterValue} = ${exclusiveMax};`,\n      );\n      // Generate .lt() for exclusive maximum (< instead of <=)\n      functions.push(['lt', `${name}ExclusiveMax${constsCounterValue}`]);\n    } else if (max !== undefined) {\n      consts.push(`export const ${name}Max${constsCounterValue} = ${max};`);\n      functions.push(['max', `${name}Max${constsCounterValue}`]);\n    }\n\n    if (multipleOf !== undefined) {\n      consts.push(\n        `export const ${name}MultipleOf${constsCounterValue} = ${multipleOf.toString()};`,\n      );\n      functions.push(['multipleOf', `${name}MultipleOf${constsCounterValue}`]);\n    }\n    if (\n      exclusiveMin !== undefined ||\n      min !== undefined ||\n      exclusiveMax !== undefined ||\n      multipleOf !== undefined ||\n      max !== undefined\n    ) {\n      consts.push(`\\n`);\n    }\n  }\n\n  if (matches) {\n    const isStartWithSlash = matches.startsWith('/');\n    const isEndWithSlash = matches.endsWith('/');\n\n    const regexp = `new RegExp('${jsStringEscape(\n      matches.slice(isStartWithSlash ? 1 : 0, isEndWithSlash ? -1 : undefined),\n    )}')`;\n\n    consts.push(\n      `export const ${name}RegExp${constsCounterValue} = ${regexp};\\n`,\n    );\n    functions.push(['regex', `${name}RegExp${constsCounterValue}`]);\n  }\n\n  if (schema.enum) {\n    if (schema.enum.every((value) => isString(value))) {\n      functions.push([\n        'enum',\n        `[${schema.enum.map((value) => `'${escape(value)}'`).join(', ')}]`,\n      ]);\n    } else {\n      functions.push([\n        'oneOf',\n        schema.enum.map((value) => ({\n          functions: [\n            ['literal', isString(value) ? `'${escape(value)}'` : value],\n          ],\n          consts: [],\n        })),\n      ]);\n    }\n  }\n\n  if (!required && schema.default !== undefined) {\n    functions.push(['default', defaultVarName]);\n  } else if (!required && nullable) {\n    functions.push(['nullish', undefined]);\n  } else if (nullable) {\n    functions.push(['nullable', undefined]);\n  } else if (!required) {\n    functions.push(['optional', undefined]);\n  }\n\n  if (schema.description) {\n    functions.push(['describe', `'${jsStringEscape(schema.description)}'`]);\n  }\n\n  return { functions, consts: unique(consts) };\n};\n\nexport const parseZodValidationSchemaDefinition = (\n  input: ZodValidationSchemaDefinition,\n  context: ContextSpec,\n  coerceTypes: boolean | ZodCoerceType[] = false,\n  strict: boolean,\n  isZodV4: boolean,\n  preprocess?: GeneratorMutator,\n): { zod: string; consts: string } => {\n  if (input.functions.length === 0) {\n    return { zod: '', consts: '' };\n  }\n\n  let consts = '';\n\n  const parseProperty = (property: [string, any]): string => {\n    const [fn, args = ''] = property;\n\n    // File | string for text contentMediaType/encoding (user can pass string, runtime wraps in Blob)\n    if (fn === 'fileOrString') {\n      return 'zod.instanceof(File).or(zod.string())';\n    }\n\n    if (fn === 'allOf') {\n      const allOfArgs = args as ZodValidationSchemaDefinition[];\n      // Check if all parts are objects and we need to merge them for strict mode\n      const allAreObjects =\n        strict &&\n        allOfArgs.length > 0 &&\n        allOfArgs.every((partSchema) => {\n          if (partSchema.functions.length === 0) return false;\n          const firstFn = partSchema.functions[0][0];\n          // Check if first function is object or strictObject\n          // For Zod v3 with strict, it will be object followed by strict\n          return firstFn === 'object' || firstFn === 'strictObject';\n        });\n\n      if (allAreObjects) {\n        // Merge all object properties into a single object\n        const mergedProperties: Record<string, ZodValidationSchemaDefinition> =\n          {};\n        let allConsts = '';\n\n        for (const partSchema of allOfArgs) {\n          if (partSchema.consts.length > 0) {\n            allConsts += partSchema.consts.join('\\n');\n          }\n\n          // Find the object function (might be first or second after strict)\n          const objectFunctionIndex = partSchema.functions.findIndex(\n            ([fnName]) => fnName === 'object' || fnName === 'strictObject',\n          );\n\n          if (objectFunctionIndex !== -1) {\n            const objectArgs = partSchema.functions[objectFunctionIndex][1];\n            if (\n              objectArgs &&\n              typeof objectArgs === 'object' &&\n              !Array.isArray(objectArgs)\n            ) {\n              // Merge properties (later schemas override earlier ones)\n              Object.assign(\n                mergedProperties,\n                objectArgs as Record<string, ZodValidationSchemaDefinition>,\n              );\n            }\n          }\n        }\n\n        if (allConsts.length > 0) {\n          consts += allConsts;\n        }\n\n        // Generate merged object\n        const objectType = getObjectFunctionName(isZodV4, strict);\n        const mergedObjectString = `zod.${objectType}({\n${Object.entries(mergedProperties)\n  .map(([key, schema]) => {\n    const value = schema.functions.map((prop) => parseProperty(prop)).join('');\n    consts += schema.consts.join('\\n');\n    return `  \"${key}\": ${value.startsWith('.') ? 'zod' : ''}${value}`;\n  })\n  .join(',\\n')}\n})`;\n\n        // Apply strict only once for Zod v3 (v4 uses strictObject)\n        if (!isZodV4) {\n          return `${mergedObjectString}.strict()`;\n        }\n\n        return mergedObjectString;\n      }\n\n      // Fallback to original .and() approach for non-object or non-strict cases\n      let acc = '';\n      for (const partSchema of allOfArgs) {\n        const value = partSchema.functions\n          .map((prop) => parseProperty(prop))\n          .join('');\n        const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n\n        if (partSchema.consts.length > 0) {\n          consts += partSchema.consts.join('\\n');\n        }\n\n        if (acc.length === 0) {\n          acc = valueWithZod;\n        } else {\n          acc += `.and(${valueWithZod})`;\n        }\n      }\n\n      return acc;\n    }\n    if (fn === 'oneOf' || fn === 'anyOf') {\n      // Can't use zod.union() with a single item\n      if (args.length === 1) {\n        return args[0].functions\n          .map((prop: any) => parseProperty(prop))\n          .join('');\n      }\n\n      const union = args.map(\n        ({\n          functions,\n          consts: argConsts,\n        }: {\n          functions: [string, any][];\n          consts: string[];\n        }) => {\n          const value = functions.map((prop) => parseProperty(prop)).join('');\n          const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n          // consts are missing here\n          consts += argConsts.join('\\n');\n          return valueWithZod;\n        },\n      );\n\n      return `.union([${union}])`;\n    }\n\n    if (fn === 'additionalProperties') {\n      const value = args.functions\n        .map((prop: any) => parseProperty(prop))\n        .join('');\n      const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n      consts += args.consts;\n      return `zod.record(zod.string(), ${valueWithZod})`;\n    }\n\n    if (fn === 'object' || fn === 'strictObject') {\n      const objectType = getObjectFunctionName(isZodV4, strict);\n\n      return `zod.${objectType}({\n${Object.entries(args)\n  .map(([key, schema]) => {\n    const value = (schema as ZodValidationSchemaDefinition).functions\n      .map((prop) => parseProperty(prop))\n      .join('');\n    consts += (schema as ZodValidationSchemaDefinition).consts.join('\\n');\n    return `  \"${key}\": ${value.startsWith('.') ? 'zod' : ''}${value}`;\n  })\n  .join(',\\n')}\n})`;\n    }\n    if (fn === 'array') {\n      const value = args.functions\n        .map((prop: any) => parseProperty(prop))\n        .join('');\n      if (typeof args.consts === 'string') {\n        consts += args.consts;\n      } else if (Array.isArray(args.consts)) {\n        consts += args.consts.join('\\n');\n      }\n      return `.array(${value.startsWith('.') ? 'zod' : ''}${value})`;\n    }\n\n    if (fn === 'strict' && !isZodV4) {\n      return '.strict()';\n    }\n\n    if (fn === 'tuple') {\n      return `zod.tuple([${(args as ZodValidationSchemaDefinition[])\n        .map((x) => {\n          const value = x.functions.map((prop) => parseProperty(prop)).join('');\n          return `${value.startsWith('.') ? 'zod' : ''}${value}`;\n        })\n        .join(',\\n')}])`;\n    }\n    if (fn === 'rest') {\n      return `.rest(zod${(args as ZodValidationSchemaDefinition).functions.map((prop) => parseProperty(prop))})`;\n    }\n    const shouldCoerceType =\n      coerceTypes &&\n      (Array.isArray(coerceTypes)\n        ? coerceTypes.includes(fn as ZodCoerceType)\n        : COERCIBLE_TYPES.has(fn));\n\n    if (\n      (fn !== 'date' && shouldCoerceType) ||\n      (fn === 'date' && shouldCoerceType && context.output.override.useDates)\n    ) {\n      return `.coerce.${fn}(${args})`;\n    }\n\n    return `.${fn}(${args})`;\n  };\n\n  consts += input.consts.join('\\n');\n\n  const schema = input.functions.map((prop) => parseProperty(prop)).join('');\n  const value = preprocess\n    ? `.preprocess(${preprocess.name}, ${\n        schema.startsWith('.') ? 'zod' : ''\n      }${schema})`\n    : schema;\n\n  const zod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n  // Some export consts includes `,` as prefix, adding replace to remove those\n  if (consts.includes(',export')) {\n    consts = consts.replaceAll(',export', '\\nexport');\n  }\n  return { zod, consts };\n};\n\nconst dereferenceScalar = (value: any, context: ContextSpec): unknown => {\n  if (isObject(value)) {\n    return dereference(value, context);\n  } else if (Array.isArray(value)) {\n    return value.map((item) => dereferenceScalar(item, context));\n  } else {\n    return value;\n  }\n};\n\nexport const dereference = (\n  schema: OpenApiSchemaObject | OpenApiReferenceObject,\n  context: ContextSpec,\n): OpenApiSchemaObject => {\n  const refName = '$ref' in schema ? schema.$ref : undefined;\n  if (refName && context.parents?.includes(refName)) {\n    return {};\n  }\n\n  const childContext: ContextSpec = {\n    ...context,\n    ...(refName\n      ? { parents: [...(context.parents ?? []), refName] }\n      : undefined),\n  };\n\n  const { schema: resolvedSchema } = resolveRef<OpenApiSchemaObject>(\n    schema,\n    childContext,\n  );\n\n  const resolvedContext = childContext;\n\n  return Object.entries(resolvedSchema).reduce<any>((acc, [key, value]) => {\n    if (key === 'properties' && isObject(value)) {\n      acc[key] = Object.entries(value).reduce<\n        Record<string, OpenApiSchemaObject>\n      >((props, [propKey, propSchema]) => {\n        props[propKey] = dereference(\n          propSchema as OpenApiSchemaObject | OpenApiReferenceObject,\n          resolvedContext,\n        );\n        return props;\n      }, {});\n    } else if (key === 'default' || key === 'example' || key === 'examples') {\n      acc[key] = value;\n    } else {\n      acc[key] = dereferenceScalar(value, resolvedContext);\n    }\n\n    return acc;\n  }, {});\n};\n\n/**\n * Generate zod schema for form-data request body.\n * Handles file type detection for top-level properties based on encoding.contentType\n * and contentMediaType. Mirrors type gen's resolveFormDataRootObject.\n */\nconst generateFormDataZodSchema = (\n  schema: OpenApiSchemaObject,\n  context: ContextSpec,\n  name: string,\n  strict: boolean,\n  isZodV4: boolean,\n  encoding?: Record<string, { contentType?: string }>,\n): ZodValidationSchemaDefinition => {\n  // Precompute file type overrides for top-level properties only\n  const propertyOverrides: Record<string, ZodValidationSchemaDefinition> = {};\n\n  if (schema.properties) {\n    for (const key of Object.keys(schema.properties)) {\n      const propSchema = schema.properties[key];\n      const resolvedPropSchema = propSchema\n        ? dereference(\n            propSchema as OpenApiSchemaObject | OpenApiReferenceObject,\n            context,\n          )\n        : undefined;\n\n      const fileType = resolvedPropSchema\n        ? getFormDataFieldFileType(\n            resolvedPropSchema,\n            encoding?.[key]?.contentType,\n          )\n        : undefined;\n\n      if (fileType) {\n        const isRequired = schema.required?.includes(key);\n        const fileFunctions: [string, unknown][] = [\n          fileType === 'binary'\n            ? ['instanceof', 'File']\n            : ['fileOrString', undefined],\n        ];\n        if (!isRequired) {\n          fileFunctions.push(['optional', undefined]);\n        }\n        propertyOverrides[key] = { functions: fileFunctions, consts: [] };\n      }\n    }\n  }\n\n  // Delegate to generic handler with file type overrides\n  return generateZodValidationSchemaDefinition(\n    schema,\n    context,\n    name,\n    strict,\n    isZodV4,\n    {\n      required: true,\n      propertyOverrides:\n        Object.keys(propertyOverrides).length > 0\n          ? propertyOverrides\n          : undefined,\n    },\n  );\n};\n\nconst parseBodyAndResponse = ({\n  data,\n  context,\n  name,\n  strict,\n  generate,\n  isZodV4,\n  parseType,\n}: {\n  data:\n    | OpenApiResponseObject\n    | OpenApiRequestBodyObject\n    | OpenApiReferenceObject\n    | undefined;\n  context: ContextSpec;\n  name: string;\n  strict: boolean;\n  generate: boolean;\n  isZodV4: boolean;\n  parseType: 'body' | 'response';\n}): {\n  input: ZodValidationSchemaDefinition;\n  isArray: boolean;\n  rules?: {\n    min?: number;\n    max?: number;\n  };\n} => {\n  if (!data || !generate) {\n    return {\n      input: { functions: [], consts: [] },\n      isArray: false,\n    };\n  }\n\n  const resolvedRef = resolveRef<\n    OpenApiResponseObject | OpenApiRequestBodyObject\n  >(data, context).schema;\n\n  // Only handle JSON and form-data; other content types (e.g., application/octet-stream)\n  // are skipped - unclear if this is correct behavior for root-level binary/text bodies\n  const jsonMedia = resolvedRef.content?.['application/json'];\n  const formDataMedia = resolvedRef.content?.['multipart/form-data'];\n  const [contentType, mediaType] = jsonMedia\n    ? (['application/json', jsonMedia] as const)\n    : formDataMedia\n      ? (['multipart/form-data', formDataMedia] as const)\n      : [undefined, undefined];\n\n  const schema = mediaType?.schema;\n\n  if (!schema) {\n    return {\n      input: { functions: [], consts: [] },\n      isArray: false,\n    };\n  }\n\n  const encoding = mediaType.encoding;\n\n  const resolvedJsonSchema = dereference(schema, context);\n\n  // keep the same behaviour for array\n  if (resolvedJsonSchema.items) {\n    const min =\n      resolvedJsonSchema.minimum ??\n      resolvedJsonSchema.minLength ??\n      resolvedJsonSchema.minItems;\n    const max =\n      resolvedJsonSchema.maximum ??\n      resolvedJsonSchema.maxLength ??\n      resolvedJsonSchema.maxItems;\n\n    return {\n      input: generateZodValidationSchemaDefinition(\n        parseType === 'body'\n          ? removeReadOnlyProperties(\n              resolvedJsonSchema.items as OpenApiSchemaObject,\n            )\n          : (resolvedJsonSchema.items as OpenApiSchemaObject),\n        context,\n        name,\n        strict,\n        isZodV4,\n        {\n          required: true,\n        },\n      ),\n      isArray: true,\n      rules: {\n        ...(min === undefined ? {} : { min }),\n        ...(max === undefined ? {} : { max }),\n      },\n    };\n  }\n\n  const effectiveSchema =\n    parseType === 'body'\n      ? removeReadOnlyProperties(resolvedJsonSchema)\n      : resolvedJsonSchema;\n\n  const isFormData = contentType === 'multipart/form-data';\n\n  return {\n    input: isFormData\n      ? generateFormDataZodSchema(\n          effectiveSchema,\n          context,\n          name,\n          strict,\n          isZodV4,\n          encoding,\n        )\n      : generateZodValidationSchemaDefinition(\n          effectiveSchema,\n          context,\n          name,\n          strict,\n          isZodV4,\n          { required: true },\n        ),\n    isArray: false,\n  };\n};\n\nexport const parseParameters = ({\n  data,\n  context,\n  operationName,\n  isZodV4,\n  strict,\n  generate,\n}: {\n  data: (OpenApiParameterObject | OpenApiReferenceObject)[] | undefined;\n  context: ContextSpec;\n  operationName: string;\n  isZodV4: boolean;\n  strict: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n  generate: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n}): {\n  headers: ZodValidationSchemaDefinition;\n  queryParams: ZodValidationSchemaDefinition;\n  params: ZodValidationSchemaDefinition;\n} => {\n  if (!data) {\n    return {\n      headers: {\n        functions: [],\n        consts: [],\n      },\n      queryParams: {\n        functions: [],\n        consts: [],\n      },\n      params: {\n        functions: [],\n        consts: [],\n      },\n    };\n  }\n\n  const defintionsByParameters = data.reduce<\n    Record<\n      'headers' | 'queryParams' | 'params',\n      Record<string, { functions: [string, any][]; consts: string[] }>\n    >\n  >(\n    (acc, val) => {\n      const { schema: parameter } = resolveRef<OpenApiParameterObject>(\n        val,\n        context,\n      );\n\n      if (!parameter.schema) {\n        return acc;\n      }\n\n      const schema = dereference(parameter.schema, context);\n      schema.description = parameter.description;\n\n      const mapStrict = {\n        path: strict.param,\n        query: strict.query,\n        header: strict.header,\n      };\n\n      const mapGenerate = {\n        path: generate.param,\n        query: generate.query,\n        header: generate.header,\n      };\n\n      const definition = generateZodValidationSchemaDefinition(\n        schema,\n        context,\n        camel(`${operationName}-${parameter.in}-${parameter.name}`),\n        getPropertySafe(mapStrict, parameter.in).value ?? false,\n        isZodV4,\n        {\n          required: parameter.required,\n        },\n      );\n\n      if (parameter.in === 'header' && mapGenerate.header) {\n        return {\n          ...acc,\n          headers: { ...acc.headers, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'query' && mapGenerate.query) {\n        return {\n          ...acc,\n          queryParams: { ...acc.queryParams, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'path' && mapGenerate.path) {\n        return {\n          ...acc,\n          params: { ...acc.params, [parameter.name]: definition },\n        };\n      }\n\n      return acc;\n    },\n    {\n      headers: {},\n      queryParams: {},\n      params: {},\n    },\n  );\n\n  const headers: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.headers).length > 0) {\n    const parameterFunctions = getParameterFunctions(\n      isZodV4,\n      strict.header,\n      defintionsByParameters.headers,\n    );\n\n    headers.functions.push(...parameterFunctions);\n  }\n\n  const queryParams: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.queryParams).length > 0) {\n    const parameterFunctions = getParameterFunctions(\n      isZodV4,\n      strict.query,\n      defintionsByParameters.queryParams,\n    );\n\n    queryParams.functions.push(...parameterFunctions);\n  }\n\n  const params: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.params).length > 0) {\n    const parameterFunctions = getParameterFunctions(\n      isZodV4,\n      strict.param,\n      defintionsByParameters.params,\n    );\n\n    params.functions.push(...parameterFunctions);\n  }\n\n  return {\n    headers,\n    queryParams,\n    params,\n  };\n};\n\nconst generateZodRoute = async (\n  { operationName, verb, override }: GeneratorVerbOptions,\n  { pathRoute, context, output }: GeneratorOptions,\n) => {\n  const isZodV4 =\n    !!context.output.packageJson && isZodVersionV4(context.output.packageJson);\n  const spec = context.spec.paths?.[pathRoute];\n\n  if (spec == undefined) {\n    throw new Error(`No such path ${pathRoute} in ${context.projectName}`);\n  }\n\n  const parameters = [\n    ...(spec.parameters ?? []),\n    ...(spec[verb]?.parameters ?? []),\n  ];\n\n  const parsedParameters = parseParameters({\n    data: parameters,\n    context,\n    operationName,\n    isZodV4,\n    strict: override.zod.strict,\n    generate: override.zod.generate,\n  });\n\n  const requestBody = spec[verb]?.requestBody;\n  const parsedBody = parseBodyAndResponse({\n    data: requestBody,\n    context,\n    name: camel(`${operationName}-body`),\n    strict: override.zod.strict.body,\n    generate: override.zod.generate.body,\n    isZodV4,\n    parseType: 'body',\n  });\n\n  const responses = (\n    context.output.override.zod.generateEachHttpStatus\n      ? Object.entries(spec[verb]?.responses ?? {})\n      : [['', spec[verb]?.responses[200]]]\n  ) as [string, OpenApiResponseObject | OpenApiReferenceObject][];\n  const parsedResponses = responses.map(([code, response]) =>\n    parseBodyAndResponse({\n      data: response,\n      context,\n      name: camel(`${operationName}-${code}-response`),\n      strict: override.zod.strict.response,\n      generate: override.zod.generate.response,\n      isZodV4,\n      parseType: 'response',\n    }),\n  );\n\n  const preprocessParams = override.zod.preprocess?.param\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessParams`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputParams = parseZodValidationSchemaDefinition(\n    parsedParameters.params,\n    context,\n    override.zod.coerce.param,\n    override.zod.strict.param,\n    isZodV4,\n    preprocessParams,\n  );\n\n  const preprocessQueryParams = override.zod.preprocess?.query\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessQueryParams`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputQueryParams = parseZodValidationSchemaDefinition(\n    parsedParameters.queryParams,\n    context,\n    override.zod.coerce.query,\n    override.zod.strict.query,\n    isZodV4,\n    preprocessQueryParams,\n  );\n\n  const preprocessHeader = override.zod.preprocess?.header\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessHeader`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputHeaders = parseZodValidationSchemaDefinition(\n    parsedParameters.headers,\n    context,\n    override.zod.coerce.header,\n    override.zod.strict.header,\n    isZodV4,\n    preprocessHeader,\n  );\n\n  const preprocessBody = override.zod.preprocess?.body\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessBody`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputBody = parseZodValidationSchemaDefinition(\n    parsedBody.input,\n    context,\n    override.zod.coerce.body,\n    override.zod.strict.body,\n    isZodV4,\n    preprocessBody,\n  );\n\n  const preprocessResponse = override.zod.preprocess?.response\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessResponse`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputResponses = parsedResponses.map((parsedResponse) =>\n    parseZodValidationSchemaDefinition(\n      parsedResponse.input,\n      context,\n      override.zod.coerce.response,\n      override.zod.strict.response,\n      isZodV4,\n      preprocessResponse,\n    ),\n  );\n\n  if (\n    !inputParams.zod &&\n    !inputQueryParams.zod &&\n    !inputHeaders.zod &&\n    !inputBody.zod &&\n    !inputResponses.some((inputResponse) => inputResponse.zod)\n  ) {\n    return {\n      implemtation: '',\n      mutators: [],\n    };\n  }\n\n  const pascalOperationName = pascal(operationName);\n\n  return {\n    implementation: [\n      ...(inputParams.consts ? [inputParams.consts] : []),\n      ...(inputParams.zod\n        ? [`export const ${pascalOperationName}Params = ${inputParams.zod}`]\n        : []),\n      ...(inputQueryParams.consts ? [inputQueryParams.consts] : []),\n      ...(inputQueryParams.zod\n        ? [\n            `export const ${pascalOperationName}QueryParams = ${inputQueryParams.zod}`,\n          ]\n        : []),\n      ...(inputHeaders.consts ? [inputHeaders.consts] : []),\n      ...(inputHeaders.zod\n        ? [`export const ${pascalOperationName}Header = ${inputHeaders.zod}`]\n        : []),\n      ...(inputBody.consts ? [inputBody.consts] : []),\n      ...(inputBody.zod\n        ? [\n            parsedBody.isArray\n              ? `export const ${pascalOperationName}BodyItem = ${inputBody.zod}\nexport const ${pascalOperationName}Body = zod.array(${pascalOperationName}BodyItem)${\n                  parsedBody.rules?.min ? `.min(${parsedBody.rules.min})` : ''\n                }${\n                  parsedBody.rules?.max ? `.max(${parsedBody.rules.max})` : ''\n                }`\n              : `export const ${pascalOperationName}Body = ${inputBody.zod}`,\n          ]\n        : []),\n      ...inputResponses.flatMap((inputResponse, index) => {\n        const operationResponse = pascal(\n          `${operationName}-${responses[index][0]}-response`,\n        );\n        return [\n          ...(inputResponse.consts ? [inputResponse.consts] : []),\n          ...(inputResponse.zod\n            ? [\n                parsedResponses[index].isArray\n                  ? `export const ${operationResponse}Item = ${\n                      inputResponse.zod\n                    }\nexport const ${operationResponse} = zod.array(${operationResponse}Item)${\n                      parsedResponses[index].rules?.min\n                        ? `.min(${parsedResponses[index].rules.min})`\n                        : ''\n                    }${\n                      parsedResponses[index].rules?.max\n                        ? `.max(${parsedResponses[index].rules.max})`\n                        : ''\n                    }`\n                  : `export const ${operationResponse} = ${inputResponse.zod}`,\n              ]\n            : []),\n        ];\n      }),\n    ].join('\\n\\n'),\n    mutators: preprocessResponse ? [preprocessResponse] : [],\n  };\n};\n\nexport const generateZod: ClientBuilder = async (verbOptions, options) => {\n  const { implementation, mutators } = await generateZodRoute(\n    verbOptions,\n    options,\n  );\n\n  return {\n    implementation: implementation ? `${implementation}\\n\\n` : '',\n    imports: [],\n    mutators,\n  };\n};\n\nconst zodClientBuilder: ClientGeneratorsBuilder = {\n  client: generateZod,\n  dependencies: getZodDependencies,\n};\n\nexport const builder = () => () => zodClientBuilder;\n\nexport { isZodVersionV4 } from './compatible-v4';\n\nexport default builder;\n"],"mappings":"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"}