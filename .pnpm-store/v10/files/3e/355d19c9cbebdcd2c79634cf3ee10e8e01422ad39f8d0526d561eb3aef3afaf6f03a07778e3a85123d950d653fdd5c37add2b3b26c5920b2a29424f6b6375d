{"version":3,"file":"index.mjs","names":["FETCH_DEPENDENCIES: GeneratorDependency[]","headersToAdd: string[]","generateClient: ClientBuilder","generateFetchHeader: ClientHeaderBuilder","fetchClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/index.ts"],"sourcesContent":["import {\n  camel,\n  type ClientBuilder,\n  type ClientGeneratorsBuilder,\n  type ClientHeaderBuilder,\n  generateBodyOptions,\n  generateFormDataAndUrlEncodedFunction,\n  generateVerbImports,\n  type GeneratorDependency,\n  type GeneratorOptions,\n  type GeneratorVerbOptions,\n  GetterPropType,\n  isObject,\n  type OpenApiParameterObject,\n  type OpenApiSchemaObject,\n  pascal,\n  resolveRef,\n  stringify,\n  toObjectString,\n} from '@orval/core';\nimport { isDereferenced } from '@scalar/openapi-types/helpers';\n\nconst WILDCARD_STATUS_CODE_REGEX = /^[1-5]XX$/i;\n\nconst getStatusCodeType = (key: string): string => {\n  if (WILDCARD_STATUS_CODE_REGEX.test(key)) {\n    const prefix = key[0];\n    return `HTTPStatusCode${prefix}xx`;\n  }\n  return key;\n};\n\nconst FETCH_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'z',\n        alias: 'zod',\n        values: true,\n      },\n    ],\n    dependency: 'zod',\n  },\n];\n\nexport const getFetchDependencies = () => FETCH_DEPENDENCIES;\n\nexport const generateRequestFunction = (\n  {\n    queryParams,\n    headers,\n    operationName,\n    response,\n    mutator,\n    body,\n    props,\n    verb,\n    fetchReviver,\n    formData,\n    formUrlEncoded,\n    override,\n  }: GeneratorVerbOptions,\n  { route, context, pathRoute }: GeneratorOptions,\n) => {\n  const isRequestOptions = override.requestOptions !== false;\n  const isFormData = !override.formData.disabled;\n  const isFormUrlEncoded = override.formUrlEncoded !== false;\n\n  const getUrlFnName = camel(`get-${operationName}-url`);\n  const getUrlFnProps = toObjectString(\n    props.filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.QUERY_PARAM,\n    ),\n    'implementation',\n  );\n\n  const spec = context.spec.paths?.[pathRoute];\n  const parameters = spec?.[verb]?.parameters ?? [];\n\n  const explodeParameters = parameters.filter((parameter) => {\n    const { schema } = resolveRef<OpenApiParameterObject>(parameter, context);\n    const schemaObject = schema.schema as OpenApiSchemaObject;\n\n    return (\n      schema.in === 'query' && schemaObject.type === 'array' && schema.explode\n    );\n  });\n\n  const explodeParametersNames = explodeParameters.map((parameter) => {\n    const { schema } = resolveRef<OpenApiParameterObject>(parameter, context);\n\n    return schema.name;\n  });\n  const hasExplodedDateParams =\n    context.output.override.useDates &&\n    explodeParameters.some(\n      (p) => isDereferenced(p) && p.schema?.format === 'date-time',\n    );\n\n  const explodeArrayImplementation =\n    explodeParameters.length > 0\n      ? `const explodeParameters = ${JSON.stringify(explodeParametersNames)};\n\n    if (Array.isArray(value) && explodeParameters.includes(key)) {\n      value.forEach((v) => {\n        normalizedParams.append(key, v === null ? 'null' : ${hasExplodedDateParams ? 'v instanceof Date ? v.toISOString() : ' : ''}v.toString());\n      });\n      return;\n    }\n      `\n      : '';\n\n  const isExplodeParametersOnly =\n    explodeParameters.length === parameters.length;\n\n  const hasDateParams =\n    context.output.override.useDates &&\n    parameters.some(\n      (p) => isDereferenced(p) && p.schema?.format === 'date-time',\n    );\n\n  const normalParamsImplementation = `if (value !== undefined) {\n      normalizedParams.append(key, value === null ? 'null' : ${hasDateParams ? 'value instanceof Date ? value.toISOString() : ' : ''}value.toString())\n    }`;\n\n  const getUrlFnImplementation = `export const ${getUrlFnName} = (${getUrlFnProps}) => {\n${\n  queryParams\n    ? `  const normalizedParams = new URLSearchParams();\n\n  Object.entries(params || {}).forEach(([key, value]) => {\n    ${explodeArrayImplementation}\n    ${isExplodeParametersOnly ? '' : normalParamsImplementation}\n  });`\n    : ''\n}\n\n  ${queryParams ? `const stringifiedParams = normalizedParams.toString();` : ``}\n\n  ${\n    queryParams\n      ? `return stringifiedParams.length > 0 ? \\`${route}?\\${stringifiedParams}\\` : \\`${route}\\``\n      : `return \\`${route}\\``\n  }\n}\\n`;\n\n  const isContentTypeNdJson = (contentType: string) =>\n    contentType === 'application/nd-json' ||\n    contentType === 'application/x-ndjson';\n\n  const isNdJson = response.contentTypes.some((contentType) =>\n    isContentTypeNdJson(contentType),\n  );\n  const responseTypeName = fetchResponseTypeName(\n    override.fetch.includeHttpResponseReturnType,\n    isNdJson ? 'Response' : response.definition.success,\n    operationName,\n  );\n\n  const responseType = response.definition.success;\n\n  const isPrimitiveType = [\n    'string',\n    'number',\n    'boolean',\n    'void',\n    'unknown',\n  ].includes(responseType);\n  const hasSchema = response.imports.some((imp) => imp.name === responseType);\n\n  const isValidateResponse =\n    override.fetch.runtimeValidation &&\n    !isPrimitiveType &&\n    hasSchema &&\n    !isNdJson;\n\n  const allResponses = [...response.types.success, ...response.types.errors];\n  if (allResponses.length === 0) {\n    allResponses.push({\n      contentType: '',\n      hasReadonlyProps: false,\n      imports: [],\n      isEnum: false,\n      isRef: false,\n      key: 'default',\n      schemas: [],\n      type: 'unknown',\n      value: 'unknown',\n      dependencies: [],\n    });\n  }\n  const nonDefaultStatuses = allResponses\n    .filter((r) => r.key !== 'default')\n    .map((r) => getStatusCodeType(r.key));\n  const responseDataTypes = allResponses\n    .map((r) =>\n      allResponses.filter((r2) => r2.key === r.key).length > 1\n        ? { ...r, suffix: pascal(r.contentType) }\n        : r,\n    )\n    .map((r) => {\n      const name = `${responseTypeName}${pascal(r.key)}${'suffix' in r ? r.suffix : ''}`;\n      const dataType = r.value || 'unknown';\n\n      return {\n        name,\n        success: response.types.success.some((s) => s.key === r.key),\n        value: `export type ${name} = {\n  ${isContentTypeNdJson(r.contentType) ? `stream: TypedResponse<${dataType}>` : `data: ${dataType}`}\n  status: ${\n    r.key === 'default'\n      ? nonDefaultStatuses.length > 0\n        ? `Exclude<HTTPStatusCodes, ${nonDefaultStatuses.join(' | ')}>`\n        : 'number'\n      : getStatusCodeType(r.key)\n  }\n}`,\n      };\n    });\n\n  const successName = `${responseTypeName}Success`;\n  const errorName = `${responseTypeName}Error`;\n  const hasSuccess = responseDataTypes.some((r) => r.success);\n  const hasError = responseDataTypes.some((r) => !r.success);\n\n  const responseTypeImplementation = override.fetch\n    .includeHttpResponseReturnType\n    ? `${responseDataTypes.map((r) => r.value).join('\\n\\n')}\n    \n${\n  hasSuccess\n    ? `export type ${successName} = (${responseDataTypes\n        .filter((r) => r.success)\n        .map((r) => r.name)\n        .join(' | ')}) & {\n  headers: Headers;\n}`\n    : ''\n};\n${\n  hasError\n    ? `export type ${errorName} = (${responseDataTypes\n        .filter((r) => !r.success)\n        .map((r) => r.name)\n        .join(' | ')}) & {\n  headers: Headers;\n}`\n    : ''\n};\n\n${override.fetch.forceSuccessResponse && hasSuccess ? '' : `export type ${responseTypeName} = (${hasError && hasSuccess ? `${successName} | ${errorName}` : hasSuccess ? successName : errorName})\\n\\n`}`\n    : '';\n\n  const getUrlFnProperties = props\n    .filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.QUERY_PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS,\n    )\n    .map((param) => {\n      return param.type === GetterPropType.NAMED_PATH_PARAMS\n        ? param.destructured\n        : param.name;\n    })\n    .join(',');\n\n  const args = `${toObjectString(props, 'implementation')} ${isRequestOptions ? `options?: RequestInit` : ''}`;\n  const returnType =\n    override.fetch.forceSuccessResponse && hasSuccess\n      ? `Promise<${successName}>`\n      : `Promise<${responseTypeName}>`;\n\n  const fetchMethodOption = `method: '${verb.toUpperCase()}'`;\n  const ignoreContentTypes = ['multipart/form-data'];\n  const overrideHeaders =\n    isObject(override.requestOptions) && override.requestOptions.headers\n      ? Object.entries(override.requestOptions.headers).map(\n          ([key, value]) => `'${key}': \\`${value}\\``,\n        )\n      : [];\n\n  const headersToAdd: string[] = [\n    ...(body.contentType && !ignoreContentTypes.includes(body.contentType)\n      ? [`'Content-Type': '${body.contentType}'`]\n      : []),\n    ...(isNdJson && response.contentTypes.length === 1\n      ? [\n          `Accept: ${\n            response.contentTypes[0] === 'application/x-ndjson'\n              ? \"'application/x-ndjson'\"\n              : \"'application/nd-json'\"\n          }`,\n        ]\n      : []),\n    ...overrideHeaders,\n    ...(headers ? ['...headers'] : []),\n  ];\n\n  let globalFetchOptions;\n  if (isObject(override.requestOptions)) {\n    // If both requestOptions and fetchHeadersOptions will be adding a header, we must merge them to avoid multiple properties with the same name\n    const shouldMergeFetchOptionHeaders =\n      headersToAdd.length > 0 && 'headers' in override.requestOptions;\n    const globalFetchOptionsObject = { ...override.requestOptions };\n    if (shouldMergeFetchOptionHeaders && override.requestOptions.headers) {\n      // Remove the headers from the object going into globalFetchOptions\n      delete globalFetchOptionsObject.headers;\n      // Add it to the dedicated headers object\n    }\n    globalFetchOptions = stringify(globalFetchOptionsObject)\n      ?.slice(1, -1)\n      .trim();\n  } else {\n    globalFetchOptions = '';\n  }\n  const fetchHeadersOption =\n    headersToAdd.length > 0\n      ? `headers: { ${headersToAdd.join(',')}, ...options?.headers }`\n      : '';\n  const requestBodyParams = generateBodyOptions(\n    body,\n    isFormData,\n    isFormUrlEncoded,\n  );\n  const fetchBodyOption = requestBodyParams\n    ? (isFormData && body.formData) ||\n      (isFormUrlEncoded && body.formUrlEncoded) ||\n      body.contentType === 'text/plain'\n      ? `body: ${requestBodyParams}`\n      : `body: JSON.stringify(${requestBodyParams})`\n    : '';\n  const fetchFnOptions = `${getUrlFnName}(${getUrlFnProperties}),\n  {${globalFetchOptions ? '\\n' : ''}      ${globalFetchOptions}\n    ${isRequestOptions ? '...options,' : ''}\n    ${fetchMethodOption}${fetchHeadersOption ? ',' : ''}\n    ${fetchHeadersOption}${fetchBodyOption ? ',' : ''}\n    ${fetchBodyOption}\n  }\n`;\n  const reviver = fetchReviver ? `, ${fetchReviver.name}` : '';\n  const throwOnErrorImplementation = `if (!${isNdJson ? 'stream' : 'res'}.ok) {\n    ${isNdJson ? 'const body = [204, 205, 304].includes(stream.status) ? null : await stream.text();' : ''}\n    const err: globalThis.Error & {info?: ${hasError ? `${errorName}${override.fetch.includeHttpResponseReturnType ? \"['data']\" : ''}` : 'any'}, status?: number} = new globalThis.Error();\n    const data ${hasError ? `: ${errorName}${override.fetch.includeHttpResponseReturnType ? `['data']` : ''}` : ''} = body ? JSON.parse(body${reviver}) : {}\n    err.info = data;\n    err.status = ${isNdJson ? 'stream' : 'res'}.status;\n    throw err;\n  }`;\n  const fetchResponseImplementation = isNdJson\n    ? `  const stream = await fetch(${fetchFnOptions});\n  ${override.fetch.forceSuccessResponse ? throwOnErrorImplementation : ''}\n  ${override.fetch.includeHttpResponseReturnType ? `return { status: stream.status, stream, headers: stream.headers } as ${override.fetch.forceSuccessResponse && hasSuccess ? successName : responseTypeName}` : `return stream`}\n  `\n    : `const res = await fetch(${fetchFnOptions})\n\n  const body = [204, 205, 304].includes(res.status) ? null : await res.text();\n  ${override.fetch.forceSuccessResponse ? throwOnErrorImplementation : ''}\n  ${\n    isValidateResponse\n      ? `const parsedBody = body ? JSON.parse(body${reviver}) : {}\n  const data = ${responseType}.parse(parsedBody)`\n      : `const data: ${override.fetch.forceSuccessResponse && hasSuccess ? successName : responseTypeName}${override.fetch.includeHttpResponseReturnType ? `['data']` : ''} = body ? JSON.parse(body${reviver}) : {}`\n  }\n  ${override.fetch.includeHttpResponseReturnType ? `return { data, status: res.status, headers: res.headers } as ${override.fetch.forceSuccessResponse && hasSuccess ? successName : responseTypeName}` : 'return data'}\n`;\n  const customFetchResponseImplementation = `return ${mutator?.name}<${override.fetch.forceSuccessResponse && hasSuccess ? successName : responseTypeName}>(${fetchFnOptions});`;\n\n  const bodyForm = generateFormDataAndUrlEncodedFunction({\n    formData,\n    formUrlEncoded,\n    body,\n    isFormData,\n    isFormUrlEncoded,\n  });\n\n  const fetchImplementationBody = mutator\n    ? customFetchResponseImplementation\n    : fetchResponseImplementation;\n\n  const fetchImplementation = `export const ${operationName} = async (${args}): ${returnType} => {\n  ${bodyForm ? `  ${bodyForm}` : ''}\n  ${fetchImplementationBody}}\n`;\n\n  const implementation =\n    responseTypeImplementation +\n    `${getUrlFnImplementation}\\n` +\n    `${fetchImplementation}\\n`;\n\n  return implementation;\n};\n\nexport const fetchResponseTypeName = (\n  includeHttpResponseReturnType: boolean | undefined,\n  definitionSuccessResponse: string,\n  operationName: string,\n) => {\n  return includeHttpResponseReturnType\n    ? `${operationName}Response`\n    : definitionSuccessResponse;\n};\n\nexport const generateClient: ClientBuilder = (verbOptions, options) => {\n  const imports = generateVerbImports(verbOptions);\n  const functionImplementation = generateRequestFunction(verbOptions, options);\n\n  return {\n    implementation: `${functionImplementation}\\n`,\n    imports,\n  };\n};\n\nconst getHTTPStatusCodes = () => `\nexport type HTTPStatusCode1xx = 100 | 101 | 102 | 103;\nexport type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;\nexport type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;\nexport type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;\nexport type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;\nexport type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;\n\n`;\n\nexport const generateFetchHeader: ClientHeaderBuilder = ({\n  clientImplementation,\n}) => {\n  const needsStatusCodeTypes = /HTTPStatusCode[1-5]xx|<HTTPStatusCodes,/.test(\n    clientImplementation,\n  );\n  return needsStatusCodeTypes ? getHTTPStatusCodes() : '';\n};\n\nconst fetchClientBuilder: ClientGeneratorsBuilder = {\n  client: generateClient,\n  header: generateFetchHeader,\n  dependencies: getFetchDependencies,\n};\n\nexport const builder = () => () => fetchClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}